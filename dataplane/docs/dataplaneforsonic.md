# Virtual Dataplane For SONiC

## Overview

The dataplane can be used with SONiC (and other NOS). The [standalone dataplane](../standalone/) is a C++ library the implements the SAI API. This library serializes and deserializes the C structs to equalivalent protobuf objects and performs gRPC requests to saiserver.

```plaintext
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  ┌─────────────────────────────────────────────┐  ┌──────────────────┐  │
│  │                                             │  │                  │  │
│  │  ┌───────────────────────────────────────┐  │  │                  │  │
│  │  │                                       │  │  │                  │  │
│  │  │   ┌───────────────────┐            ┌──┴──┴──┴──┐               │  │
│  │  │   │                   │            │ Ethernet0 │               │  │
│  │  │   │ ┌──────────────┐  │            └──┬──┬──┬──┘               │  │
│  │  │   │ │              │  │               │  │  │                  │  │
│  │  │   │ │ CPU Port MGR │  │               │  │  │                  │  │
│  │  │   │ │ SAI Impl  ───┼──┼─────gRPC──────┼──┼──┼───► saiserver    │  │
│  │  │   │ │              │  │               │  │  │                  │  │
│  │  │   │ │ libsai.so    │  │               │  │  │                  │  │
│  │  │   │ └──────────────┘  │               │  │  │                  │  │
│  │  │   │                   │               │  │  │                  │  │
│  │  │   │                   │               │  │  │                  │  │
│  │  │   │ syncd             │               │  │  │                  │  │
│  │  │   └───────────────────┘            ┌──┴──┴──┴──┐               │  │
│  │  │                                    │ Ethernet4 │               │  │
│  │  │                                    └──┬──┬──┬──┘               │  │
│  │  │ VM                                    │  │  │                  │  │
│  │  └───────────────────────────────────────┘  │  │                  │  │
│  │                                             │  │                  │  │
│  │  SONiC VM Runner                            │  │ Dataplane        │  │
│  └─────────────────────────────────────────────┘  └──────────────────┘  │
│                                                                         │
│                                                                         │
│                                                    ┌──────┐  ┌──────┐   │
│ pod                                                │ eth1 │  │ eth2 │   │
└────────────────────────────────────────────────────┴──────┴──┴──────┴───┘
```

## libsai

The dataplane libsai is shared object that implements the SAI API. The libsai is the code owned by Lemming in the SONiC VM. It composed of almost entirely autogenerated code that converts the C structs to protobuf struct. The code is generated by the [apigen](../apigen/apigen.go) (run manually if there are any changes to SAI version or generation logic) Go library and checked in the repo: [sai folder](../standalone/sai/).

In addition to SAI implementation, the CPU Port manager runs as a another thread in the library. The CPU port manager is responsible for handling IPs address assigned to the interfaces inside the VM.
This example shows the flow of the API calls when adding an interface and assigning an IP to it.

1. A hostif is created called Ethernet0
2. saiserver receives the request and sets up the dataplane
3. saiserver notifies the CPU manager that a hostif is created
4. the user assigns the IP 192.168.1.100/24 to the Ethernet0
5. syncd created a route with prefix 192.168.1.100/32 and next hop the CPU port ID.
6. CPU port MGR reacts to new IP (netlink message) and an entry to a dataplane table:  
   1. If output port is CPU and IP DST header is 192.168.1.100 then output the Ethernet0 device

The CPU port manager also handles [SAI GNETLINK Hostif](https://github.com/opencomputeproject/SAI/blob/master/inc/saihostif.h#L832). These are special hostif types that use the [generic netlink](https://wiki.linuxfoundation.org/networking/generic_netlink_howto) to received packets from the CPU port. Since this API is local the kernel, the packets must be written from inside the VM.

## Dataplane Container

The dataplane container runs the saiserver and forwarding packets between the veths present in the pod. Since all containers in a Kubernetes pod share the same namespace, the dataplane container communicates with VM using the TAP interfaces. These TAP interface are the hostifs that appear inside the VM.

## Topologies and KNE

Using [KNE](https://github.com/openconfig/kne), topologies containing multiple devices can be created. An Alpine topology node is a exactly 1 Kubernetes pod containing 1 VM runner and 1 dataplane containers. A topology with multiple nodes, would multiple pods each with the 2 containers.
