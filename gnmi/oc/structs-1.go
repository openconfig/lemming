/*
Package oc is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by ygnmi version: v0.11.1: (ygot: v0.29.21-0.20250212000509-7956ee9146e0)
using the following YANG input files:
  - public/release/models/acl/openconfig-acl.yang
  - public/release/models/acl/openconfig-packet-match.yang
  - public/release/models/aft/openconfig-aft-network-instance.yang
  - public/release/models/aft/openconfig-aft-summary.yang
  - public/release/models/aft/openconfig-aft.yang
  - public/release/models/bfd/openconfig-bfd.yang
  - public/release/models/bgp/openconfig-bgp-policy.yang
  - public/release/models/bgp/openconfig-bgp-types.yang
  - public/release/models/extensions/openconfig-metadata.yang
  - public/release/models/gnsi/openconfig-gnsi-acctz.yang
  - public/release/models/gnsi/openconfig-gnsi-authz.yang
  - public/release/models/gnsi/openconfig-gnsi-certz.yang
  - public/release/models/gnsi/openconfig-gnsi-credentialz.yang
  - public/release/models/gnsi/openconfig-gnsi-pathz.yang
  - public/release/models/gnsi/openconfig-gnsi.yang
  - public/release/models/gribi/openconfig-gribi.yang
  - public/release/models/interfaces/openconfig-if-aggregate.yang
  - public/release/models/interfaces/openconfig-if-ethernet-ext.yang
  - public/release/models/interfaces/openconfig-if-ethernet.yang
  - public/release/models/interfaces/openconfig-if-ip-ext.yang
  - public/release/models/interfaces/openconfig-if-ip.yang
  - public/release/models/interfaces/openconfig-if-sdn-ext.yang
  - public/release/models/interfaces/openconfig-interfaces.yang
  - public/release/models/isis/openconfig-isis-policy.yang
  - public/release/models/isis/openconfig-isis.yang
  - public/release/models/lacp/openconfig-lacp.yang
  - public/release/models/lldp/openconfig-lldp-types.yang
  - public/release/models/lldp/openconfig-lldp.yang
  - public/release/models/local-routing/openconfig-local-routing.yang
  - public/release/models/mpls/openconfig-mpls-types.yang
  - public/release/models/multicast/openconfig-pim.yang
  - public/release/models/network-instance/openconfig-network-instance.yang
  - public/release/models/openconfig-extensions.yang
  - public/release/models/optical-transport/openconfig-transport-types.yang
  - public/release/models/ospf/openconfig-ospf-policy.yang
  - public/release/models/ospf/openconfig-ospfv2.yang
  - public/release/models/p4rt/openconfig-p4rt.yang
  - public/release/models/platform/openconfig-platform-common.yang
  - public/release/models/platform/openconfig-platform-controller-card.yang
  - public/release/models/platform/openconfig-platform-cpu.yang
  - public/release/models/platform/openconfig-platform-ext.yang
  - public/release/models/platform/openconfig-platform-fabric.yang
  - public/release/models/platform/openconfig-platform-fan.yang
  - public/release/models/platform/openconfig-platform-integrated-circuit.yang
  - public/release/models/platform/openconfig-platform-linecard.yang
  - public/release/models/platform/openconfig-platform-pipeline-counters.yang
  - public/release/models/platform/openconfig-platform-psu.yang
  - public/release/models/platform/openconfig-platform-software.yang
  - public/release/models/platform/openconfig-platform-transceiver.yang
  - public/release/models/platform/openconfig-platform.yang
  - public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
  - public/release/models/policy/openconfig-policy-types.yang
  - public/release/models/qos/openconfig-qos-elements.yang
  - public/release/models/qos/openconfig-qos-interfaces.yang
  - public/release/models/qos/openconfig-qos-types.yang
  - public/release/models/qos/openconfig-qos.yang
  - public/release/models/relay-agent/openconfig-relay-agent.yang
  - public/release/models/rib/openconfig-rib-bgp.yang
  - public/release/models/sampling/openconfig-sampling-sflow.yang
  - public/release/models/segment-routing/openconfig-segment-routing-types.yang
  - public/release/models/system/openconfig-system-bootz.yang
  - public/release/models/system/openconfig-system-controlplane.yang
  - public/release/models/system/openconfig-system-utilization.yang
  - public/release/models/system/openconfig-system.yang
  - public/release/models/types/openconfig-inet-types.yang
  - public/release/models/types/openconfig-types.yang
  - public/release/models/types/openconfig-yang-types.yang
  - public/release/models/vlan/openconfig-vlan.yang
  - public/third_party/ietf/iana-if-type.yang
  - public/third_party/ietf/ietf-inet-types.yang
  - public/third_party/ietf/ietf-interfaces.yang
  - public/third_party/ietf/ietf-yang-types.yang
  - yang/openconfig-bgp-gue.yang

Imported modules were sourced from:
  - public/release/models/...
  - public/third_party/ietf/...
*/
package oc

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList struct {
	InnerVlanIds []uint16 `path:"state/inner-vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId  *uint16  `path:"state/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) IsYANGGoStruct() {}

// GetInnerVlanIds retrieves the value of the leaf InnerVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanIds is set, it can
// safely use t.GetInnerVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetInnerVlanIds() []uint16 {
	if t == nil || t.InnerVlanIds == nil {
		return nil
	}
	return t.InnerVlanIds
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// SetInnerVlanIds sets the value of the leaf InnerVlanIds in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) SetInnerVlanIds(v []uint16) {
	t.InnerVlanIds = v
}

// SetOuterVlanId sets the value of the leaf OuterVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) SetOuterVlanId(v uint16) {
	t.OuterVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange struct {
	InnerHighVlanId *uint16 `path:"state/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InnerLowVlanId  *uint16 `path:"state/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterHighVlanId *uint16 `path:"state/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterLowVlanId  *uint16 `path:"state/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// SetInnerHighVlanId sets the value of the leaf InnerHighVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) SetInnerHighVlanId(v uint16) {
	t.InnerHighVlanId = &v
}

// SetInnerLowVlanId sets the value of the leaf InnerLowVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) SetInnerLowVlanId(v uint16) {
	t.InnerLowVlanId = &v
}

// SetOuterHighVlanId sets the value of the leaf OuterHighVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) SetOuterHighVlanId(v uint16) {
	t.OuterHighVlanId = &v
}

// SetOuterLowVlanId sets the value of the leaf OuterLowVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) SetOuterLowVlanId(v uint16) {
	t.OuterLowVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange struct {
	InnerHighVlanId *uint16  `path:"state/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InnerLowVlanId  *uint16  `path:"state/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId     []uint16 `path:"state/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetOuterVlanId() []uint16 {
	if t == nil || t.OuterVlanId == nil {
		return nil
	}
	return t.OuterVlanId
}

// SetInnerHighVlanId sets the value of the leaf InnerHighVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) SetInnerHighVlanId(v uint16) {
	t.InnerHighVlanId = &v
}

// SetInnerLowVlanId sets the value of the leaf InnerLowVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) SetInnerLowVlanId(v uint16) {
	t.InnerLowVlanId = &v
}

// SetOuterVlanId sets the value of the leaf OuterVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) SetOuterVlanId(v []uint16) {
	t.OuterVlanId = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList struct {
	InnerVlanId  *uint16  `path:"state/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanIds []uint16 `path:"state/outer-vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanIds retrieves the value of the leaf OuterVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanIds is set, it can
// safely use t.GetOuterVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetOuterVlanIds() []uint16 {
	if t == nil || t.OuterVlanIds == nil {
		return nil
	}
	return t.OuterVlanIds
}

// SetInnerVlanId sets the value of the leaf InnerVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) SetInnerVlanId(v uint16) {
	t.InnerVlanId = &v
}

// SetOuterVlanIds sets the value of the leaf OuterVlanIds in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) SetOuterVlanIds(v []uint16) {
	t.OuterVlanIds = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange struct {
	InnerVlanId     *uint16 `path:"state/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterHighVlanId *uint16 `path:"state/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterLowVlanId  *uint16 `path:"state/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// SetInnerVlanId sets the value of the leaf InnerVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) SetInnerVlanId(v uint16) {
	t.InnerVlanId = &v
}

// SetOuterHighVlanId sets the value of the leaf OuterHighVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) SetOuterHighVlanId(v uint16) {
	t.OuterHighVlanId = &v
}

// SetOuterLowVlanId sets the value of the leaf OuterLowVlanId in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) SetOuterLowVlanId(v uint16) {
	t.OuterLowVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTagged struct {
	VlanId *uint16 `path:"state/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) IsYANGGoStruct() {}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_Match_SingleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// SetVlanId sets the value of the leaf VlanId in the Interface_Subinterface_Vlan_Match_SingleTagged
// struct.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) SetVlanId(v uint16) {
	t.VlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTagged.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-list YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedList struct {
	VlanIds []uint16 `path:"state/vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) IsYANGGoStruct() {}

// GetVlanIds retrieves the value of the leaf VlanIds from the Interface_Subinterface_Vlan_Match_SingleTaggedList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanIds is set, it can
// safely use t.GetVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) GetVlanIds() []uint16 {
	if t == nil || t.VlanIds == nil {
		return nil
	}
	return t.VlanIds
}

// SetVlanIds sets the value of the leaf VlanIds in the Interface_Subinterface_Vlan_Match_SingleTaggedList
// struct.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) SetVlanIds(v []uint16) {
	t.VlanIds = v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTaggedList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedList.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-range YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedRange struct {
	HighVlanId *uint16 `path:"state/high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	LowVlanId  *uint16 `path:"state/low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) IsYANGGoStruct() {}

// GetHighVlanId retrieves the value of the leaf HighVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighVlanId is set, it can
// safely use t.GetHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetHighVlanId() uint16 {
	if t == nil || t.HighVlanId == nil {
		return 0
	}
	return *t.HighVlanId
}

// GetLowVlanId retrieves the value of the leaf LowVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowVlanId is set, it can
// safely use t.GetLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetLowVlanId() uint16 {
	if t == nil || t.LowVlanId == nil {
		return 0
	}
	return *t.LowVlanId
}

// SetHighVlanId sets the value of the leaf HighVlanId in the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) SetHighVlanId(v uint16) {
	t.HighVlanId = &v
}

// SetLowVlanId sets the value of the leaf LowVlanId in the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) SetLowVlanId(v uint16) {
	t.LowVlanId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedRange.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Keychain represents the /openconfig-keychain/keychains/keychain YANG schema element.
type Keychain struct {
	Key       map[Keychain_Key_KeyId_Union]*Keychain_Key `path:"keys/key" module:"openconfig-keychain/openconfig-keychain"`
	Name      *string                                    `path:"state/name|name" module:"openconfig-keychain/openconfig-keychain|openconfig-keychain" shadow-path:"config/name|name" shadow-module:"openconfig-keychain/openconfig-keychain|openconfig-keychain"`
	Tolerance Keychain_Tolerance_Union                   `path:"state/tolerance" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/tolerance" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain) IsYANGGoStruct() {}

// NewKey creates a new entry in the Key list of the
// Keychain struct. The keys of the list are populated from the input
// arguments.
func (t *Keychain) NewKey(KeyId Keychain_Key_KeyId_Union) (*Keychain_Key, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[Keychain_Key_KeyId_Union]*Keychain_Key)
	}

	key := KeyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Key[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Key", key)
	}

	t.Key[key] = &Keychain_Key{
		KeyId: KeyId,
	}

	return t.Key[key], nil
}

// RenameKey renames an entry in the list Key within
// the Keychain struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Keychain) RenameKey(oldK, newK Keychain_Key_KeyId_Union) error {
	if _, ok := t.Key[newK]; ok {
		return fmt.Errorf("key %v already exists in Key", newK)
	}

	e, ok := t.Key[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Key", oldK)
	}
	e.KeyId = newK

	t.Key[newK] = e
	delete(t.Key, oldK)
	return nil
}

// GetOrCreateKeyMap returns the list (map) from Keychain.
//
// It initializes the field if not already initialized.
func (t *Keychain) GetOrCreateKeyMap() map[Keychain_Key_KeyId_Union]*Keychain_Key {
	if t.Key == nil {
		t.Key = make(map[Keychain_Key_KeyId_Union]*Keychain_Key)
	}
	return t.Key
}

// GetOrCreateKey retrieves the value with the specified keys from
// the receiver Keychain. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Keychain) GetOrCreateKey(KeyId Keychain_Key_KeyId_Union) *Keychain_Key {

	key := KeyId

	if v, ok := t.Key[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewKey(KeyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateKey got unexpected error: %v", err))
	}
	return v
}

// GetKey retrieves the value with the specified key from
// the Key map field of Keychain. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Keychain) GetKey(KeyId Keychain_Key_KeyId_Union) *Keychain_Key {

	if t == nil {
		return nil
	}

	key := KeyId

	if lm, ok := t.Key[key]; ok {
		return lm
	}
	return nil
}

// DeleteKey deletes the value with the specified keys from
// the receiver Keychain. If there is no such element, the function
// is a no-op.
func (t *Keychain) DeleteKey(KeyId Keychain_Key_KeyId_Union) {
	key := KeyId

	delete(t.Key, key)
}

// AppendKey appends the supplied Keychain_Key struct to the
// list Key of Keychain. If the key value(s) specified in
// the supplied Keychain_Key already exist in the list, an error is
// returned.
func (t *Keychain) AppendKey(v *Keychain_Key) error {
	key := v.KeyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[Keychain_Key_KeyId_Union]*Keychain_Key)
	}

	if _, ok := t.Key[key]; ok {
		return fmt.Errorf("duplicate key for list Key %v", key)
	}

	t.Key[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Keychain) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTolerance retrieves the value of the leaf Tolerance from the Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tolerance is set, it can
// safely use t.GetTolerance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tolerance == nil' before retrieving the leaf's value.
func (t *Keychain) GetTolerance() Keychain_Tolerance_Union {
	if t == nil || t.Tolerance == nil {
		return nil
	}
	return t.Tolerance
}

// SetName sets the value of the leaf Name in the Keychain
// struct.
func (t *Keychain) SetName(v string) {
	t.Name = &v
}

// SetTolerance sets the value of the leaf Tolerance in the Keychain
// struct.
func (t *Keychain) SetTolerance(v Keychain_Tolerance_Union) {
	t.Tolerance = v
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Key {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Keychain struct, which is a YANG list entry.
func (t *Keychain) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain.
func (*Keychain) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key represents the /openconfig-keychain/keychains/keychain/keys/key YANG schema element.
type Keychain_Key struct {
	CryptoAlgorithm E_KeychainTypes_CRYPTO_TYPE   `path:"state/crypto-algorithm" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/crypto-algorithm" shadow-module:"openconfig-keychain/openconfig-keychain"`
	KeyId           Keychain_Key_KeyId_Union      `path:"state/key-id|key-id" module:"openconfig-keychain/openconfig-keychain|openconfig-keychain" shadow-path:"config/key-id|key-id" shadow-module:"openconfig-keychain/openconfig-keychain|openconfig-keychain"`
	ReceiveLifetime *Keychain_Key_ReceiveLifetime `path:"receive-lifetime" module:"openconfig-keychain"`
	SecretKey       *string                       `path:"state/secret-key" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/secret-key" shadow-module:"openconfig-keychain/openconfig-keychain"`
	SendLifetime    *Keychain_Key_SendLifetime    `path:"send-lifetime" module:"openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key) IsYANGGoStruct() {}

// GetOrCreateReceiveLifetime retrieves the value of the ReceiveLifetime field
// or returns the existing field if it already exists.
func (t *Keychain_Key) GetOrCreateReceiveLifetime() *Keychain_Key_ReceiveLifetime {
	if t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	t.ReceiveLifetime = &Keychain_Key_ReceiveLifetime{}
	return t.ReceiveLifetime
}

// GetOrCreateSendLifetime retrieves the value of the SendLifetime field
// or returns the existing field if it already exists.
func (t *Keychain_Key) GetOrCreateSendLifetime() *Keychain_Key_SendLifetime {
	if t.SendLifetime != nil {
		return t.SendLifetime
	}
	t.SendLifetime = &Keychain_Key_SendLifetime{}
	return t.SendLifetime
}

// GetReceiveLifetime returns the value of the ReceiveLifetime struct pointer
// from Keychain_Key. If the receiver or the field ReceiveLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Keychain_Key) GetReceiveLifetime() *Keychain_Key_ReceiveLifetime {
	if t != nil && t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	return nil
}

// GetSendLifetime returns the value of the SendLifetime struct pointer
// from Keychain_Key. If the receiver or the field SendLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Keychain_Key) GetSendLifetime() *Keychain_Key_SendLifetime {
	if t != nil && t.SendLifetime != nil {
		return t.SendLifetime
	}
	return nil
}

// GetCryptoAlgorithm retrieves the value of the leaf CryptoAlgorithm from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CryptoAlgorithm is set, it can
// safely use t.GetCryptoAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CryptoAlgorithm == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetCryptoAlgorithm() E_KeychainTypes_CRYPTO_TYPE {
	if t == nil || t.CryptoAlgorithm == 0 {
		return 0
	}
	return t.CryptoAlgorithm
}

// GetKeyId retrieves the value of the leaf KeyId from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyId is set, it can
// safely use t.GetKeyId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyId == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetKeyId() Keychain_Key_KeyId_Union {
	if t == nil || t.KeyId == nil {
		return nil
	}
	return t.KeyId
}

// GetSecretKey retrieves the value of the leaf SecretKey from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecretKey is set, it can
// safely use t.GetSecretKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecretKey == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetSecretKey() string {
	if t == nil || t.SecretKey == nil {
		return ""
	}
	return *t.SecretKey
}

// SetCryptoAlgorithm sets the value of the leaf CryptoAlgorithm in the Keychain_Key
// struct.
func (t *Keychain_Key) SetCryptoAlgorithm(v E_KeychainTypes_CRYPTO_TYPE) {
	t.CryptoAlgorithm = v
}

// SetKeyId sets the value of the leaf KeyId in the Keychain_Key
// struct.
func (t *Keychain_Key) SetKeyId(v Keychain_Key_KeyId_Union) {
	t.KeyId = v
}

// SetSecretKey sets the value of the leaf SecretKey in the Keychain_Key
// struct.
func (t *Keychain_Key) SetSecretKey(v string) {
	t.SecretKey = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ReceiveLifetime.PopulateDefaults()
	t.SendLifetime.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Keychain_Key struct, which is a YANG list entry.
func (t *Keychain_Key) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"key-id": t.KeyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key.
func (*Keychain_Key) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key_ReceiveLifetime represents the /openconfig-keychain/keychains/keychain/keys/key/receive-lifetime YANG schema element.
type Keychain_Key_ReceiveLifetime struct {
	EndTime   *uint64 `path:"state/end-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/end-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
	StartTime *uint64 `path:"state/start-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/start-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key_ReceiveLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key_ReceiveLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_ReceiveLifetime) GetEndTime() uint64 {
	if t == nil || t.EndTime == nil {
		return 0
	}
	return *t.EndTime
}

// GetStartTime retrieves the value of the leaf StartTime from the Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_ReceiveLifetime) GetStartTime() uint64 {
	if t == nil || t.StartTime == nil {
		return 0
	}
	return *t.StartTime
}

// SetEndTime sets the value of the leaf EndTime in the Keychain_Key_ReceiveLifetime
// struct.
func (t *Keychain_Key_ReceiveLifetime) SetEndTime(v uint64) {
	t.EndTime = &v
}

// SetStartTime sets the value of the leaf StartTime in the Keychain_Key_ReceiveLifetime
// struct.
func (t *Keychain_Key_ReceiveLifetime) SetStartTime(v uint64) {
	t.StartTime = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key_ReceiveLifetime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key_ReceiveLifetime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_ReceiveLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key_ReceiveLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_ReceiveLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key_ReceiveLifetime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key_ReceiveLifetime.
func (*Keychain_Key_ReceiveLifetime) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key_SendLifetime represents the /openconfig-keychain/keychains/keychain/keys/key/send-lifetime YANG schema element.
type Keychain_Key_SendLifetime struct {
	EndTime        *uint64 `path:"state/end-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/end-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
	SendAndReceive *bool   `path:"state/send-and-receive" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/send-and-receive" shadow-module:"openconfig-keychain/openconfig-keychain"`
	StartTime      *uint64 `path:"state/start-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/start-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key_SendLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key_SendLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetEndTime() uint64 {
	if t == nil || t.EndTime == nil {
		return 0
	}
	return *t.EndTime
}

// GetSendAndReceive retrieves the value of the leaf SendAndReceive from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendAndReceive is set, it can
// safely use t.GetSendAndReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendAndReceive == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetSendAndReceive() bool {
	if t == nil || t.SendAndReceive == nil {
		return true
	}
	return *t.SendAndReceive
}

// GetStartTime retrieves the value of the leaf StartTime from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetStartTime() uint64 {
	if t == nil || t.StartTime == nil {
		return 0
	}
	return *t.StartTime
}

// SetEndTime sets the value of the leaf EndTime in the Keychain_Key_SendLifetime
// struct.
func (t *Keychain_Key_SendLifetime) SetEndTime(v uint64) {
	t.EndTime = &v
}

// SetSendAndReceive sets the value of the leaf SendAndReceive in the Keychain_Key_SendLifetime
// struct.
func (t *Keychain_Key_SendLifetime) SetSendAndReceive(v bool) {
	t.SendAndReceive = &v
}

// SetStartTime sets the value of the leaf StartTime in the Keychain_Key_SendLifetime
// struct.
func (t *Keychain_Key_SendLifetime) SetStartTime(v uint64) {
	t.StartTime = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key_SendLifetime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key_SendLifetime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SendAndReceive == nil {
		var v bool = true
		t.SendAndReceive = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_SendLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key_SendLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_SendLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key_SendLifetime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key_SendLifetime.
func (*Keychain_Key_SendLifetime) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Lacp represents the /openconfig-lacp/lacp YANG schema element.
type Lacp struct {
	Interface      map[string]*Lacp_Interface `path:"interfaces/interface" module:"openconfig-lacp/openconfig-lacp"`
	SystemPriority *uint16                    `path:"state/system-priority" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/system-priority" shadow-module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Lacp struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp) NewInterface(Name string) (*Lacp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lacp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lacp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from Lacp.
//
// It initializes the field if not already initialized.
func (t *Lacp) GetOrCreateInterfaceMap() map[string]*Lacp_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lacp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp) GetOrCreateInterface(Name string) *Lacp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lacp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp) GetInterface(Name string) *Lacp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lacp. If there is no such element, the function
// is a no-op.
func (t *Lacp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lacp_Interface struct to the
// list Interface of Lacp. If the key value(s) specified in
// the supplied Lacp_Interface already exist in the list, an error is
// returned.
func (t *Lacp) AppendInterface(v *Lacp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *Lacp) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// SetSystemPriority sets the value of the leaf SystemPriority in the Lacp
// struct.
func (t *Lacp) SetSystemPriority(v uint16) {
	t.SystemPriority = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp.
func (*Lacp) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface represents the /openconfig-lacp/lacp/interfaces/interface YANG schema element.
type Lacp_Interface struct {
	Fallback       *bool                             `path:"state/fallback" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/fallback" shadow-module:"openconfig-lacp/openconfig-lacp"`
	Interval       E_Lacp_LacpPeriodType             `path:"state/interval" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/interval" shadow-module:"openconfig-lacp/openconfig-lacp"`
	LacpMode       E_Lacp_LacpActivityType           `path:"state/lacp-mode" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/lacp-mode" shadow-module:"openconfig-lacp/openconfig-lacp"`
	Member         map[string]*Lacp_Interface_Member `path:"members/member" module:"openconfig-lacp/openconfig-lacp"`
	Name           *string                           `path:"state/name|name" module:"openconfig-lacp/openconfig-lacp|openconfig-lacp" shadow-path:"config/name|name" shadow-module:"openconfig-lacp/openconfig-lacp|openconfig-lacp"`
	SystemIdMac    *string                           `path:"state/system-id-mac" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/system-id-mac" shadow-module:"openconfig-lacp/openconfig-lacp"`
	SystemPriority *uint16                           `path:"state/system-priority" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/system-priority" shadow-module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface) IsYANGGoStruct() {}

// NewMember creates a new entry in the Member list of the
// Lacp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp_Interface) NewMember(Interface string) (*Lacp_Interface_Member, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Member[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Member", key)
	}

	t.Member[key] = &Lacp_Interface_Member{
		Interface: &Interface,
	}

	return t.Member[key], nil
}

// RenameMember renames an entry in the list Member within
// the Lacp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp_Interface) RenameMember(oldK, newK string) error {
	if _, ok := t.Member[newK]; ok {
		return fmt.Errorf("key %v already exists in Member", newK)
	}

	e, ok := t.Member[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Member", oldK)
	}
	e.Interface = &newK

	t.Member[newK] = e
	delete(t.Member, oldK)
	return nil
}

// GetOrCreateMemberMap returns the list (map) from Lacp_Interface.
//
// It initializes the field if not already initialized.
func (t *Lacp_Interface) GetOrCreateMemberMap() map[string]*Lacp_Interface_Member {
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}
	return t.Member
}

// GetOrCreateMember retrieves the value with the specified keys from
// the receiver Lacp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp_Interface) GetOrCreateMember(Interface string) *Lacp_Interface_Member {

	key := Interface

	if v, ok := t.Member[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMember(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMember got unexpected error: %v", err))
	}
	return v
}

// GetMember retrieves the value with the specified key from
// the Member map field of Lacp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp_Interface) GetMember(Interface string) *Lacp_Interface_Member {

	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.Member[key]; ok {
		return lm
	}
	return nil
}

// DeleteMember deletes the value with the specified keys from
// the receiver Lacp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lacp_Interface) DeleteMember(Interface string) {
	key := Interface

	delete(t.Member, key)
}

// AppendMember appends the supplied Lacp_Interface_Member struct to the
// list Member of Lacp_Interface. If the key value(s) specified in
// the supplied Lacp_Interface_Member already exist in the list, an error is
// returned.
func (t *Lacp_Interface) AppendMember(v *Lacp_Interface_Member) error {
	if v.Interface == nil {
		return fmt.Errorf("invalid nil key received for Interface")
	}

	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	if _, ok := t.Member[key]; ok {
		return fmt.Errorf("duplicate key for list Member %v", key)
	}

	t.Member[key] = v
	return nil
}

// GetFallback retrieves the value of the leaf Fallback from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fallback is set, it can
// safely use t.GetFallback() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fallback == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetFallback() bool {
	if t == nil || t.Fallback == nil {
		return false
	}
	return *t.Fallback
}

// GetInterval retrieves the value of the leaf Interval from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetInterval() E_Lacp_LacpPeriodType {
	if t == nil || t.Interval == 0 {
		return Lacp_LacpPeriodType_SLOW
	}
	return t.Interval
}

// GetLacpMode retrieves the value of the leaf LacpMode from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpMode is set, it can
// safely use t.GetLacpMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpMode == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetLacpMode() E_Lacp_LacpActivityType {
	if t == nil || t.LacpMode == 0 {
		return Lacp_LacpActivityType_ACTIVE
	}
	return t.LacpMode
}

// GetName retrieves the value of the leaf Name from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSystemIdMac retrieves the value of the leaf SystemIdMac from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemIdMac is set, it can
// safely use t.GetSystemIdMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemIdMac == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetSystemIdMac() string {
	if t == nil || t.SystemIdMac == nil {
		return ""
	}
	return *t.SystemIdMac
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// SetFallback sets the value of the leaf Fallback in the Lacp_Interface
// struct.
func (t *Lacp_Interface) SetFallback(v bool) {
	t.Fallback = &v
}

// SetInterval sets the value of the leaf Interval in the Lacp_Interface
// struct.
func (t *Lacp_Interface) SetInterval(v E_Lacp_LacpPeriodType) {
	t.Interval = v
}

// SetLacpMode sets the value of the leaf LacpMode in the Lacp_Interface
// struct.
func (t *Lacp_Interface) SetLacpMode(v E_Lacp_LacpActivityType) {
	t.LacpMode = v
}

// SetName sets the value of the leaf Name in the Lacp_Interface
// struct.
func (t *Lacp_Interface) SetName(v string) {
	t.Name = &v
}

// SetSystemIdMac sets the value of the leaf SystemIdMac in the Lacp_Interface
// struct.
func (t *Lacp_Interface) SetSystemIdMac(v string) {
	t.SystemIdMac = &v
}

// SetSystemPriority sets the value of the leaf SystemPriority in the Lacp_Interface
// struct.
func (t *Lacp_Interface) SetSystemPriority(v uint16) {
	t.SystemPriority = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Interval == 0 {
		t.Interval = Lacp_LacpPeriodType_SLOW
	}
	if t.LacpMode == 0 {
		t.LacpMode = Lacp_LacpActivityType_ACTIVE
	}
	for _, e := range t.Member {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lacp_Interface struct, which is a YANG list entry.
func (t *Lacp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface.
func (*Lacp_Interface) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface_Member represents the /openconfig-lacp/lacp/interfaces/interface/members/member YANG schema element.
type Lacp_Interface_Member struct {
	Activity            E_Lacp_LacpActivityType         `path:"state/activity" module:"openconfig-lacp/openconfig-lacp"`
	Aggregatable        *bool                           `path:"state/aggregatable" module:"openconfig-lacp/openconfig-lacp"`
	Collecting          *bool                           `path:"state/collecting" module:"openconfig-lacp/openconfig-lacp"`
	Counters            *Lacp_Interface_Member_Counters `path:"state/counters" module:"openconfig-lacp/openconfig-lacp"`
	Distributing        *bool                           `path:"state/distributing" module:"openconfig-lacp/openconfig-lacp"`
	Interface           *string                         `path:"state/interface|interface" module:"openconfig-lacp/openconfig-lacp|openconfig-lacp" shadow-path:"config/interface|interface" shadow-module:"openconfig-lacp/openconfig-lacp|openconfig-lacp"`
	LastChange          *uint64                         `path:"state/last-change" module:"openconfig-lacp/openconfig-lacp"`
	OperKey             *uint16                         `path:"state/oper-key" module:"openconfig-lacp/openconfig-lacp"`
	PartnerId           *string                         `path:"state/partner-id" module:"openconfig-lacp/openconfig-lacp"`
	PartnerKey          *uint16                         `path:"state/partner-key" module:"openconfig-lacp/openconfig-lacp"`
	PartnerPortNum      *uint16                         `path:"state/partner-port-num" module:"openconfig-lacp/openconfig-lacp"`
	PartnerPortPriority *uint16                         `path:"state/partner-port-priority" module:"openconfig-lacp/openconfig-lacp"`
	PortNum             *uint16                         `path:"state/port-num" module:"openconfig-lacp/openconfig-lacp"`
	PortPriority        *uint16                         `path:"state/port-priority" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/port-priority" shadow-module:"openconfig-lacp/openconfig-lacp"`
	Synchronization     E_Lacp_LacpSynchronizationType  `path:"state/synchronization" module:"openconfig-lacp/openconfig-lacp"`
	SystemId            *string                         `path:"state/system-id" module:"openconfig-lacp/openconfig-lacp"`
	Timeout             E_Lacp_LacpTimeoutType          `path:"state/timeout" module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface_Member implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface_Member) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lacp_Interface_Member) GetOrCreateCounters() *Lacp_Interface_Member_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lacp_Interface_Member_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lacp_Interface_Member. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lacp_Interface_Member) GetCounters() *Lacp_Interface_Member_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetActivity retrieves the value of the leaf Activity from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Activity is set, it can
// safely use t.GetActivity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Activity == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetActivity() E_Lacp_LacpActivityType {
	if t == nil || t.Activity == 0 {
		return 0
	}
	return t.Activity
}

// GetAggregatable retrieves the value of the leaf Aggregatable from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Aggregatable is set, it can
// safely use t.GetAggregatable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Aggregatable == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetAggregatable() bool {
	if t == nil || t.Aggregatable == nil {
		return false
	}
	return *t.Aggregatable
}

// GetCollecting retrieves the value of the leaf Collecting from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Collecting is set, it can
// safely use t.GetCollecting() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Collecting == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetCollecting() bool {
	if t == nil || t.Collecting == nil {
		return false
	}
	return *t.Collecting
}

// GetDistributing retrieves the value of the leaf Distributing from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Distributing is set, it can
// safely use t.GetDistributing() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Distributing == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetDistributing() bool {
	if t == nil || t.Distributing == nil {
		return false
	}
	return *t.Distributing
}

// GetInterface retrieves the value of the leaf Interface from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLastChange retrieves the value of the leaf LastChange from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetOperKey retrieves the value of the leaf OperKey from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperKey is set, it can
// safely use t.GetOperKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperKey == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetOperKey() uint16 {
	if t == nil || t.OperKey == nil {
		return 0
	}
	return *t.OperKey
}

// GetPartnerId retrieves the value of the leaf PartnerId from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerId is set, it can
// safely use t.GetPartnerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerId == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerId() string {
	if t == nil || t.PartnerId == nil {
		return ""
	}
	return *t.PartnerId
}

// GetPartnerKey retrieves the value of the leaf PartnerKey from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerKey is set, it can
// safely use t.GetPartnerKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerKey == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerKey() uint16 {
	if t == nil || t.PartnerKey == nil {
		return 0
	}
	return *t.PartnerKey
}

// GetPartnerPortNum retrieves the value of the leaf PartnerPortNum from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerPortNum is set, it can
// safely use t.GetPartnerPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerPortNum == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerPortNum() uint16 {
	if t == nil || t.PartnerPortNum == nil {
		return 0
	}
	return *t.PartnerPortNum
}

// GetPartnerPortPriority retrieves the value of the leaf PartnerPortPriority from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerPortPriority is set, it can
// safely use t.GetPartnerPortPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerPortPriority == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerPortPriority() uint16 {
	if t == nil || t.PartnerPortPriority == nil {
		return 0
	}
	return *t.PartnerPortPriority
}

// GetPortNum retrieves the value of the leaf PortNum from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortNum is set, it can
// safely use t.GetPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortNum == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPortNum() uint16 {
	if t == nil || t.PortNum == nil {
		return 0
	}
	return *t.PortNum
}

// GetPortPriority retrieves the value of the leaf PortPriority from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortPriority is set, it can
// safely use t.GetPortPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortPriority == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPortPriority() uint16 {
	if t == nil || t.PortPriority == nil {
		return 0
	}
	return *t.PortPriority
}

// GetSynchronization retrieves the value of the leaf Synchronization from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Synchronization is set, it can
// safely use t.GetSynchronization() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Synchronization == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetSynchronization() E_Lacp_LacpSynchronizationType {
	if t == nil || t.Synchronization == 0 {
		return 0
	}
	return t.Synchronization
}

// GetSystemId retrieves the value of the leaf SystemId from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// GetTimeout retrieves the value of the leaf Timeout from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetTimeout() E_Lacp_LacpTimeoutType {
	if t == nil || t.Timeout == 0 {
		return 0
	}
	return t.Timeout
}

// SetActivity sets the value of the leaf Activity in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetActivity(v E_Lacp_LacpActivityType) {
	t.Activity = v
}

// SetAggregatable sets the value of the leaf Aggregatable in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetAggregatable(v bool) {
	t.Aggregatable = &v
}

// SetCollecting sets the value of the leaf Collecting in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetCollecting(v bool) {
	t.Collecting = &v
}

// SetDistributing sets the value of the leaf Distributing in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetDistributing(v bool) {
	t.Distributing = &v
}

// SetInterface sets the value of the leaf Interface in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetInterface(v string) {
	t.Interface = &v
}

// SetLastChange sets the value of the leaf LastChange in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetLastChange(v uint64) {
	t.LastChange = &v
}

// SetOperKey sets the value of the leaf OperKey in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetOperKey(v uint16) {
	t.OperKey = &v
}

// SetPartnerId sets the value of the leaf PartnerId in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetPartnerId(v string) {
	t.PartnerId = &v
}

// SetPartnerKey sets the value of the leaf PartnerKey in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetPartnerKey(v uint16) {
	t.PartnerKey = &v
}

// SetPartnerPortNum sets the value of the leaf PartnerPortNum in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetPartnerPortNum(v uint16) {
	t.PartnerPortNum = &v
}

// SetPartnerPortPriority sets the value of the leaf PartnerPortPriority in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetPartnerPortPriority(v uint16) {
	t.PartnerPortPriority = &v
}

// SetPortNum sets the value of the leaf PortNum in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetPortNum(v uint16) {
	t.PortNum = &v
}

// SetPortPriority sets the value of the leaf PortPriority in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetPortPriority(v uint16) {
	t.PortPriority = &v
}

// SetSynchronization sets the value of the leaf Synchronization in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetSynchronization(v E_Lacp_LacpSynchronizationType) {
	t.Synchronization = v
}

// SetSystemId sets the value of the leaf SystemId in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetSystemId(v string) {
	t.SystemId = &v
}

// SetTimeout sets the value of the leaf Timeout in the Lacp_Interface_Member
// struct.
func (t *Lacp_Interface_Member) SetTimeout(v E_Lacp_LacpTimeoutType) {
	t.Timeout = v
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface_Member
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface_Member) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Lacp_Interface_Member struct, which is a YANG list entry.
func (t *Lacp_Interface_Member) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface_Member.
func (*Lacp_Interface_Member) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface_Member_Counters represents the /openconfig-lacp/lacp/interfaces/interface/members/member/state/counters YANG schema element.
type Lacp_Interface_Member_Counters struct {
	LacpErrors             *uint64 `path:"lacp-errors" module:"openconfig-lacp"`
	LacpInPkts             *uint64 `path:"lacp-in-pkts" module:"openconfig-lacp"`
	LacpOutPkts            *uint64 `path:"lacp-out-pkts" module:"openconfig-lacp"`
	LacpRxErrors           *uint64 `path:"lacp-rx-errors" module:"openconfig-lacp"`
	LacpTimeoutTransitions *uint64 `path:"lacp-timeout-transitions" module:"openconfig-lacp"`
	LacpTxErrors           *uint64 `path:"lacp-tx-errors" module:"openconfig-lacp"`
	LacpUnknownErrors      *uint64 `path:"lacp-unknown-errors" module:"openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface_Member_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface_Member_Counters) IsYANGGoStruct() {}

// GetLacpErrors retrieves the value of the leaf LacpErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpErrors is set, it can
// safely use t.GetLacpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpErrors() uint64 {
	if t == nil || t.LacpErrors == nil {
		return 0
	}
	return *t.LacpErrors
}

// GetLacpInPkts retrieves the value of the leaf LacpInPkts from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpInPkts is set, it can
// safely use t.GetLacpInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpInPkts == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpInPkts() uint64 {
	if t == nil || t.LacpInPkts == nil {
		return 0
	}
	return *t.LacpInPkts
}

// GetLacpOutPkts retrieves the value of the leaf LacpOutPkts from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpOutPkts is set, it can
// safely use t.GetLacpOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpOutPkts == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpOutPkts() uint64 {
	if t == nil || t.LacpOutPkts == nil {
		return 0
	}
	return *t.LacpOutPkts
}

// GetLacpRxErrors retrieves the value of the leaf LacpRxErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpRxErrors is set, it can
// safely use t.GetLacpRxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpRxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpRxErrors() uint64 {
	if t == nil || t.LacpRxErrors == nil {
		return 0
	}
	return *t.LacpRxErrors
}

// GetLacpTimeoutTransitions retrieves the value of the leaf LacpTimeoutTransitions from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpTimeoutTransitions is set, it can
// safely use t.GetLacpTimeoutTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpTimeoutTransitions == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpTimeoutTransitions() uint64 {
	if t == nil || t.LacpTimeoutTransitions == nil {
		return 0
	}
	return *t.LacpTimeoutTransitions
}

// GetLacpTxErrors retrieves the value of the leaf LacpTxErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpTxErrors is set, it can
// safely use t.GetLacpTxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpTxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpTxErrors() uint64 {
	if t == nil || t.LacpTxErrors == nil {
		return 0
	}
	return *t.LacpTxErrors
}

// GetLacpUnknownErrors retrieves the value of the leaf LacpUnknownErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpUnknownErrors is set, it can
// safely use t.GetLacpUnknownErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpUnknownErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpUnknownErrors() uint64 {
	if t == nil || t.LacpUnknownErrors == nil {
		return 0
	}
	return *t.LacpUnknownErrors
}

// SetLacpErrors sets the value of the leaf LacpErrors in the Lacp_Interface_Member_Counters
// struct.
func (t *Lacp_Interface_Member_Counters) SetLacpErrors(v uint64) {
	t.LacpErrors = &v
}

// SetLacpInPkts sets the value of the leaf LacpInPkts in the Lacp_Interface_Member_Counters
// struct.
func (t *Lacp_Interface_Member_Counters) SetLacpInPkts(v uint64) {
	t.LacpInPkts = &v
}

// SetLacpOutPkts sets the value of the leaf LacpOutPkts in the Lacp_Interface_Member_Counters
// struct.
func (t *Lacp_Interface_Member_Counters) SetLacpOutPkts(v uint64) {
	t.LacpOutPkts = &v
}

// SetLacpRxErrors sets the value of the leaf LacpRxErrors in the Lacp_Interface_Member_Counters
// struct.
func (t *Lacp_Interface_Member_Counters) SetLacpRxErrors(v uint64) {
	t.LacpRxErrors = &v
}

// SetLacpTimeoutTransitions sets the value of the leaf LacpTimeoutTransitions in the Lacp_Interface_Member_Counters
// struct.
func (t *Lacp_Interface_Member_Counters) SetLacpTimeoutTransitions(v uint64) {
	t.LacpTimeoutTransitions = &v
}

// SetLacpTxErrors sets the value of the leaf LacpTxErrors in the Lacp_Interface_Member_Counters
// struct.
func (t *Lacp_Interface_Member_Counters) SetLacpTxErrors(v uint64) {
	t.LacpTxErrors = &v
}

// SetLacpUnknownErrors sets the value of the leaf LacpUnknownErrors in the Lacp_Interface_Member_Counters
// struct.
func (t *Lacp_Interface_Member_Counters) SetLacpUnknownErrors(v uint64) {
	t.LacpUnknownErrors = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface_Member_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface_Member_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface_Member_Counters.
func (*Lacp_Interface_Member_Counters) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lldp represents the /openconfig-lldp/lldp YANG schema element.
type Lldp struct {
	ChassisId                *string                    `path:"state/chassis-id" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/chassis-id" shadow-module:"openconfig-lldp/openconfig-lldp"`
	ChassisIdType            E_LldpTypes_ChassisIdType  `path:"state/chassis-id-type" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/chassis-id-type" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Counters                 *Lldp_Counters             `path:"state/counters" module:"openconfig-lldp/openconfig-lldp"`
	Enabled                  *bool                      `path:"state/enabled" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/enabled" shadow-module:"openconfig-lldp/openconfig-lldp"`
	HelloTimer               *uint64                    `path:"state/hello-timer" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/hello-timer" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Interface                map[string]*Lldp_Interface `path:"interfaces/interface" module:"openconfig-lldp/openconfig-lldp"`
	SuppressTlvAdvertisement []E_LldpTypes_LLDP_TLV     `path:"state/suppress-tlv-advertisement" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/suppress-tlv-advertisement" shadow-module:"openconfig-lldp/openconfig-lldp"`
	SystemDescription        *string                    `path:"state/system-description" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/system-description" shadow-module:"openconfig-lldp/openconfig-lldp"`
	SystemName               *string                    `path:"state/system-name" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/system-name" shadow-module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp) NewInterface(Name string) (*Lldp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from Lldp.
//
// It initializes the field if not already initialized.
func (t *Lldp) GetOrCreateInterfaceMap() map[string]*Lldp_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp) GetOrCreateInterface(Name string) *Lldp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp) GetInterface(Name string) *Lldp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lldp. If there is no such element, the function
// is a no-op.
func (t *Lldp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lldp_Interface struct to the
// list Interface of Lldp. If the key value(s) specified in
// the supplied Lldp_Interface already exist in the list, an error is
// returned.
func (t *Lldp) AppendInterface(v *Lldp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp) GetOrCreateCounters() *Lldp_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp) GetCounters() *Lldp_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetChassisId retrieves the value of the leaf ChassisId from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisId is set, it can
// safely use t.GetChassisId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisId == nil' before retrieving the leaf's value.
func (t *Lldp) GetChassisId() string {
	if t == nil || t.ChassisId == nil {
		return ""
	}
	return *t.ChassisId
}

// GetChassisIdType retrieves the value of the leaf ChassisIdType from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisIdType is set, it can
// safely use t.GetChassisIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisIdType == nil' before retrieving the leaf's value.
func (t *Lldp) GetChassisIdType() E_LldpTypes_ChassisIdType {
	if t == nil || t.ChassisIdType == 0 {
		return 0
	}
	return t.ChassisIdType
}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetHelloTimer retrieves the value of the leaf HelloTimer from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloTimer is set, it can
// safely use t.GetHelloTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloTimer == nil' before retrieving the leaf's value.
func (t *Lldp) GetHelloTimer() uint64 {
	if t == nil || t.HelloTimer == nil {
		return 0
	}
	return *t.HelloTimer
}

// GetSuppressTlvAdvertisement retrieves the value of the leaf SuppressTlvAdvertisement from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressTlvAdvertisement is set, it can
// safely use t.GetSuppressTlvAdvertisement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressTlvAdvertisement == nil' before retrieving the leaf's value.
func (t *Lldp) GetSuppressTlvAdvertisement() []E_LldpTypes_LLDP_TLV {
	if t == nil || t.SuppressTlvAdvertisement == nil {
		return nil
	}
	return t.SuppressTlvAdvertisement
}

// GetSystemDescription retrieves the value of the leaf SystemDescription from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemDescription is set, it can
// safely use t.GetSystemDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemDescription == nil' before retrieving the leaf's value.
func (t *Lldp) GetSystemDescription() string {
	if t == nil || t.SystemDescription == nil {
		return ""
	}
	return *t.SystemDescription
}

// GetSystemName retrieves the value of the leaf SystemName from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemName is set, it can
// safely use t.GetSystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemName == nil' before retrieving the leaf's value.
func (t *Lldp) GetSystemName() string {
	if t == nil || t.SystemName == nil {
		return ""
	}
	return *t.SystemName
}

// SetChassisId sets the value of the leaf ChassisId in the Lldp
// struct.
func (t *Lldp) SetChassisId(v string) {
	t.ChassisId = &v
}

// SetChassisIdType sets the value of the leaf ChassisIdType in the Lldp
// struct.
func (t *Lldp) SetChassisIdType(v E_LldpTypes_ChassisIdType) {
	t.ChassisIdType = v
}

// SetEnabled sets the value of the leaf Enabled in the Lldp
// struct.
func (t *Lldp) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetHelloTimer sets the value of the leaf HelloTimer in the Lldp
// struct.
func (t *Lldp) SetHelloTimer(v uint64) {
	t.HelloTimer = &v
}

// SetSuppressTlvAdvertisement sets the value of the leaf SuppressTlvAdvertisement in the Lldp
// struct.
func (t *Lldp) SetSuppressTlvAdvertisement(v []E_LldpTypes_LLDP_TLV) {
	t.SuppressTlvAdvertisement = v
}

// SetSystemDescription sets the value of the leaf SystemDescription in the Lldp
// struct.
func (t *Lldp) SetSystemDescription(v string) {
	t.SystemDescription = &v
}

// SetSystemName sets the value of the leaf SystemName in the Lldp
// struct.
func (t *Lldp) SetSystemName(v string) {
	t.SystemName = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp.
func (*Lldp) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Counters represents the /openconfig-lldp/lldp/state/counters YANG schema element.
type Lldp_Counters struct {
	EntriesAgedOut *uint64 `path:"entries-aged-out" module:"openconfig-lldp"`
	FrameDiscard   *uint64 `path:"frame-discard" module:"openconfig-lldp"`
	FrameErrorIn   *uint64 `path:"frame-error-in" module:"openconfig-lldp"`
	FrameIn        *uint64 `path:"frame-in" module:"openconfig-lldp"`
	FrameOut       *uint64 `path:"frame-out" module:"openconfig-lldp"`
	LastClear      *string `path:"last-clear" module:"openconfig-lldp"`
	TlvAccepted    *uint64 `path:"tlv-accepted" module:"openconfig-lldp"`
	TlvDiscard     *uint64 `path:"tlv-discard" module:"openconfig-lldp"`
	TlvUnknown     *uint64 `path:"tlv-unknown" module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Counters) IsYANGGoStruct() {}

// GetEntriesAgedOut retrieves the value of the leaf EntriesAgedOut from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntriesAgedOut is set, it can
// safely use t.GetEntriesAgedOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntriesAgedOut == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetEntriesAgedOut() uint64 {
	if t == nil || t.EntriesAgedOut == nil {
		return 0
	}
	return *t.EntriesAgedOut
}

// GetFrameDiscard retrieves the value of the leaf FrameDiscard from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameDiscard is set, it can
// safely use t.GetFrameDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameDiscard() uint64 {
	if t == nil || t.FrameDiscard == nil {
		return 0
	}
	return *t.FrameDiscard
}

// GetFrameErrorIn retrieves the value of the leaf FrameErrorIn from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorIn is set, it can
// safely use t.GetFrameErrorIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorIn == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameErrorIn() uint64 {
	if t == nil || t.FrameErrorIn == nil {
		return 0
	}
	return *t.FrameErrorIn
}

// GetFrameIn retrieves the value of the leaf FrameIn from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameIn is set, it can
// safely use t.GetFrameIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameIn == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameIn() uint64 {
	if t == nil || t.FrameIn == nil {
		return 0
	}
	return *t.FrameIn
}

// GetFrameOut retrieves the value of the leaf FrameOut from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameOut is set, it can
// safely use t.GetFrameOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameOut == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameOut() uint64 {
	if t == nil || t.FrameOut == nil {
		return 0
	}
	return *t.FrameOut
}

// GetLastClear retrieves the value of the leaf LastClear from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetLastClear() string {
	if t == nil || t.LastClear == nil {
		return ""
	}
	return *t.LastClear
}

// GetTlvAccepted retrieves the value of the leaf TlvAccepted from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvAccepted is set, it can
// safely use t.GetTlvAccepted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvAccepted == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvAccepted() uint64 {
	if t == nil || t.TlvAccepted == nil {
		return 0
	}
	return *t.TlvAccepted
}

// GetTlvDiscard retrieves the value of the leaf TlvDiscard from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvDiscard is set, it can
// safely use t.GetTlvDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvDiscard() uint64 {
	if t == nil || t.TlvDiscard == nil {
		return 0
	}
	return *t.TlvDiscard
}

// GetTlvUnknown retrieves the value of the leaf TlvUnknown from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvUnknown is set, it can
// safely use t.GetTlvUnknown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvUnknown == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvUnknown() uint64 {
	if t == nil || t.TlvUnknown == nil {
		return 0
	}
	return *t.TlvUnknown
}

// SetEntriesAgedOut sets the value of the leaf EntriesAgedOut in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetEntriesAgedOut(v uint64) {
	t.EntriesAgedOut = &v
}

// SetFrameDiscard sets the value of the leaf FrameDiscard in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetFrameDiscard(v uint64) {
	t.FrameDiscard = &v
}

// SetFrameErrorIn sets the value of the leaf FrameErrorIn in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetFrameErrorIn(v uint64) {
	t.FrameErrorIn = &v
}

// SetFrameIn sets the value of the leaf FrameIn in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetFrameIn(v uint64) {
	t.FrameIn = &v
}

// SetFrameOut sets the value of the leaf FrameOut in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetFrameOut(v uint64) {
	t.FrameOut = &v
}

// SetLastClear sets the value of the leaf LastClear in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetLastClear(v string) {
	t.LastClear = &v
}

// SetTlvAccepted sets the value of the leaf TlvAccepted in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetTlvAccepted(v uint64) {
	t.TlvAccepted = &v
}

// SetTlvDiscard sets the value of the leaf TlvDiscard in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetTlvDiscard(v uint64) {
	t.TlvDiscard = &v
}

// SetTlvUnknown sets the value of the leaf TlvUnknown in the Lldp_Counters
// struct.
func (t *Lldp_Counters) SetTlvUnknown(v uint64) {
	t.TlvUnknown = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Counters.
func (*Lldp_Counters) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface represents the /openconfig-lldp/lldp/interfaces/interface YANG schema element.
type Lldp_Interface struct {
	Counters *Lldp_Interface_Counters            `path:"state/counters" module:"openconfig-lldp/openconfig-lldp"`
	Enabled  *bool                               `path:"state/enabled" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/enabled" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Name     *string                             `path:"state/name|name" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"config/name|name" shadow-module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	Neighbor map[string]*Lldp_Interface_Neighbor `path:"neighbors/neighbor" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// Lldp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface) NewNeighbor(Id string) (*Lldp_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Lldp_Interface_Neighbor{
		Id: &Id,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Lldp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Id = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighborMap returns the list (map) from Lldp_Interface.
//
// It initializes the field if not already initialized.
func (t *Lldp_Interface) GetOrCreateNeighborMap() map[string]*Lldp_Interface_Neighbor {
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}
	return t.Neighbor
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Lldp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface) GetOrCreateNeighbor(Id string) *Lldp_Interface_Neighbor {

	key := Id

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Lldp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface) GetNeighbor(Id string) *Lldp_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Lldp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface) DeleteNeighbor(Id string) {
	key := Id

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Lldp_Interface_Neighbor struct to the
// list Neighbor of Lldp_Interface. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *Lldp_Interface) AppendNeighbor(v *Lldp_Interface_Neighbor) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp_Interface) GetOrCreateCounters() *Lldp_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Interface_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp_Interface) GetCounters() *Lldp_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp_Interface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetName retrieves the value of the leaf Name from the Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lldp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// SetEnabled sets the value of the leaf Enabled in the Lldp_Interface
// struct.
func (t *Lldp_Interface) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetName sets the value of the leaf Name in the Lldp_Interface
// struct.
func (t *Lldp_Interface) SetName(v string) {
	t.Name = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lldp_Interface struct, which is a YANG list entry.
func (t *Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface.
func (*Lldp_Interface) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Counters represents the /openconfig-lldp/lldp/interfaces/interface/state/counters YANG schema element.
type Lldp_Interface_Counters struct {
	FrameDiscard  *uint64 `path:"frame-discard" module:"openconfig-lldp"`
	FrameErrorIn  *uint64 `path:"frame-error-in" module:"openconfig-lldp"`
	FrameErrorOut *uint64 `path:"frame-error-out" module:"openconfig-lldp"`
	FrameIn       *uint64 `path:"frame-in" module:"openconfig-lldp"`
	FrameOut      *uint64 `path:"frame-out" module:"openconfig-lldp"`
	LastClear     *string `path:"last-clear" module:"openconfig-lldp"`
	TlvDiscard    *uint64 `path:"tlv-discard" module:"openconfig-lldp"`
	TlvUnknown    *uint64 `path:"tlv-unknown" module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Counters) IsYANGGoStruct() {}

// GetFrameDiscard retrieves the value of the leaf FrameDiscard from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameDiscard is set, it can
// safely use t.GetFrameDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameDiscard() uint64 {
	if t == nil || t.FrameDiscard == nil {
		return 0
	}
	return *t.FrameDiscard
}

// GetFrameErrorIn retrieves the value of the leaf FrameErrorIn from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorIn is set, it can
// safely use t.GetFrameErrorIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorIn == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameErrorIn() uint64 {
	if t == nil || t.FrameErrorIn == nil {
		return 0
	}
	return *t.FrameErrorIn
}

// GetFrameErrorOut retrieves the value of the leaf FrameErrorOut from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorOut is set, it can
// safely use t.GetFrameErrorOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorOut == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameErrorOut() uint64 {
	if t == nil || t.FrameErrorOut == nil {
		return 0
	}
	return *t.FrameErrorOut
}

// GetFrameIn retrieves the value of the leaf FrameIn from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameIn is set, it can
// safely use t.GetFrameIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameIn == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameIn() uint64 {
	if t == nil || t.FrameIn == nil {
		return 0
	}
	return *t.FrameIn
}

// GetFrameOut retrieves the value of the leaf FrameOut from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameOut is set, it can
// safely use t.GetFrameOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameOut == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameOut() uint64 {
	if t == nil || t.FrameOut == nil {
		return 0
	}
	return *t.FrameOut
}

// GetLastClear retrieves the value of the leaf LastClear from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetLastClear() string {
	if t == nil || t.LastClear == nil {
		return ""
	}
	return *t.LastClear
}

// GetTlvDiscard retrieves the value of the leaf TlvDiscard from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvDiscard is set, it can
// safely use t.GetTlvDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetTlvDiscard() uint64 {
	if t == nil || t.TlvDiscard == nil {
		return 0
	}
	return *t.TlvDiscard
}

// GetTlvUnknown retrieves the value of the leaf TlvUnknown from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvUnknown is set, it can
// safely use t.GetTlvUnknown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvUnknown == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetTlvUnknown() uint64 {
	if t == nil || t.TlvUnknown == nil {
		return 0
	}
	return *t.TlvUnknown
}

// SetFrameDiscard sets the value of the leaf FrameDiscard in the Lldp_Interface_Counters
// struct.
func (t *Lldp_Interface_Counters) SetFrameDiscard(v uint64) {
	t.FrameDiscard = &v
}

// SetFrameErrorIn sets the value of the leaf FrameErrorIn in the Lldp_Interface_Counters
// struct.
func (t *Lldp_Interface_Counters) SetFrameErrorIn(v uint64) {
	t.FrameErrorIn = &v
}

// SetFrameErrorOut sets the value of the leaf FrameErrorOut in the Lldp_Interface_Counters
// struct.
func (t *Lldp_Interface_Counters) SetFrameErrorOut(v uint64) {
	t.FrameErrorOut = &v
}

// SetFrameIn sets the value of the leaf FrameIn in the Lldp_Interface_Counters
// struct.
func (t *Lldp_Interface_Counters) SetFrameIn(v uint64) {
	t.FrameIn = &v
}

// SetFrameOut sets the value of the leaf FrameOut in the Lldp_Interface_Counters
// struct.
func (t *Lldp_Interface_Counters) SetFrameOut(v uint64) {
	t.FrameOut = &v
}

// SetLastClear sets the value of the leaf LastClear in the Lldp_Interface_Counters
// struct.
func (t *Lldp_Interface_Counters) SetLastClear(v string) {
	t.LastClear = &v
}

// SetTlvDiscard sets the value of the leaf TlvDiscard in the Lldp_Interface_Counters
// struct.
func (t *Lldp_Interface_Counters) SetTlvDiscard(v uint64) {
	t.TlvDiscard = &v
}

// SetTlvUnknown sets the value of the leaf TlvUnknown in the Lldp_Interface_Counters
// struct.
func (t *Lldp_Interface_Counters) SetTlvUnknown(v uint64) {
	t.TlvUnknown = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Counters.
func (*Lldp_Interface_Counters) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor YANG schema element.
type Lldp_Interface_Neighbor struct {
	Age                   *uint64                                                                    `path:"state/age" module:"openconfig-lldp/openconfig-lldp"`
	Capability            map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability `path:"capabilities/capability" module:"openconfig-lldp/openconfig-lldp"`
	ChassisId             *string                                                                    `path:"state/chassis-id" module:"openconfig-lldp/openconfig-lldp"`
	ChassisIdType         E_LldpTypes_ChassisIdType                                                  `path:"state/chassis-id-type" module:"openconfig-lldp/openconfig-lldp"`
	Id                    *string                                                                    `path:"state/id|id" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"id" shadow-module:"openconfig-lldp"`
	LastUpdate            *int64                                                                     `path:"state/last-update" module:"openconfig-lldp/openconfig-lldp"`
	ManagementAddress     *string                                                                    `path:"state/management-address" module:"openconfig-lldp/openconfig-lldp"`
	ManagementAddressType *string                                                                    `path:"state/management-address-type" module:"openconfig-lldp/openconfig-lldp"`
	PortDescription       *string                                                                    `path:"state/port-description" module:"openconfig-lldp/openconfig-lldp"`
	PortId                *string                                                                    `path:"state/port-id" module:"openconfig-lldp/openconfig-lldp"`
	PortIdType            E_LldpTypes_PortIdType                                                     `path:"state/port-id-type" module:"openconfig-lldp/openconfig-lldp"`
	SystemDescription     *string                                                                    `path:"state/system-description" module:"openconfig-lldp/openconfig-lldp"`
	SystemName            *string                                                                    `path:"state/system-name" module:"openconfig-lldp/openconfig-lldp"`
	Tlv                   map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv           `path:"custom-tlvs/tlv" module:"openconfig-lldp/openconfig-lldp"`
	Ttl                   *uint16                                                                    `path:"state/ttl" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor) IsYANGGoStruct() {}

// Lldp_Interface_Neighbor_Tlv_Key represents the key for list Tlv of element /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor.
type Lldp_Interface_Neighbor_Tlv_Key struct {
	Type       int32  `path:"type"`
	Oui        string `path:"oui"`
	OuiSubtype string `path:"oui-subtype"`
}

// IsYANGGoKeyStruct ensures that Lldp_Interface_Neighbor_Tlv_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Lldp_Interface_Neighbor_Tlv_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the Lldp_Interface_Neighbor_Tlv_Key key struct.
func (t Lldp_Interface_Neighbor_Tlv_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"type":        t.Type,
		"oui":         t.Oui,
		"oui-subtype": t.OuiSubtype,
	}, nil
}

// NewCapability creates a new entry in the Capability list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) (*Lldp_Interface_Neighbor_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &Lldp_Interface_Neighbor_Capability{
		Name: Name,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameCapability(oldK, newK E_LldpTypes_LLDP_SYSTEM_CAPABILITY) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.Name = newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapabilityMap returns the list (map) from Lldp_Interface_Neighbor.
//
// It initializes the field if not already initialized.
func (t *Lldp_Interface_Neighbor) GetOrCreateCapabilityMap() map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability {
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}
	return t.Capability
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	key := Name

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// DeleteCapability deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) {
	key := Name

	delete(t.Capability, key)
}

// AppendCapability appends the supplied Lldp_Interface_Neighbor_Capability struct to the
// list Capability of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Capability already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendCapability(v *Lldp_Interface_Neighbor_Capability) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewTlv creates a new entry in the Tlv list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewTlv(Type int32, Oui string, OuiSubtype string) (*Lldp_Interface_Neighbor_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &Lldp_Interface_Neighbor_Tlv{
		Type:       &Type,
		Oui:        &Oui,
		OuiSubtype: &OuiSubtype,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameTlv(oldK, newK Lldp_Interface_Neighbor_Tlv_Key) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = &newK.Type
	e.Oui = &newK.Oui
	e.OuiSubtype = &newK.OuiSubtype

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlvMap returns the list (map) from Lldp_Interface_Neighbor.
//
// It initializes the field if not already initialized.
func (t *Lldp_Interface_Neighbor) GetOrCreateTlvMap() map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv {
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}
	return t.Tlv
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type, Oui, OuiSubtype)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	if t == nil {
		return nil
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteTlv deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteTlv(Type int32, Oui string, OuiSubtype string) {
	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	delete(t.Tlv, key)
}

// AppendTlv appends the supplied Lldp_Interface_Neighbor_Tlv struct to the
// list Tlv of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Tlv already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendTlv(v *Lldp_Interface_Neighbor_Tlv) error {
	if v.Type == nil {
		return fmt.Errorf("invalid nil key for Type")
	}

	if v.Oui == nil {
		return fmt.Errorf("invalid nil key for Oui")
	}

	if v.OuiSubtype == nil {
		return fmt.Errorf("invalid nil key for OuiSubtype")
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       *v.Type,
		Oui:        *v.Oui,
		OuiSubtype: *v.OuiSubtype,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// GetAge retrieves the value of the leaf Age from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Age is set, it can
// safely use t.GetAge() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Age == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetAge() uint64 {
	if t == nil || t.Age == nil {
		return 0
	}
	return *t.Age
}

// GetChassisId retrieves the value of the leaf ChassisId from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisId is set, it can
// safely use t.GetChassisId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisId == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetChassisId() string {
	if t == nil || t.ChassisId == nil {
		return ""
	}
	return *t.ChassisId
}

// GetChassisIdType retrieves the value of the leaf ChassisIdType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisIdType is set, it can
// safely use t.GetChassisIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisIdType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetChassisIdType() E_LldpTypes_ChassisIdType {
	if t == nil || t.ChassisIdType == 0 {
		return 0
	}
	return t.ChassisIdType
}

// GetId retrieves the value of the leaf Id from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetLastUpdate retrieves the value of the leaf LastUpdate from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastUpdate is set, it can
// safely use t.GetLastUpdate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastUpdate == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetLastUpdate() int64 {
	if t == nil || t.LastUpdate == nil {
		return 0
	}
	return *t.LastUpdate
}

// GetManagementAddress retrieves the value of the leaf ManagementAddress from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagementAddress is set, it can
// safely use t.GetManagementAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagementAddress == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetManagementAddress() string {
	if t == nil || t.ManagementAddress == nil {
		return ""
	}
	return *t.ManagementAddress
}

// GetManagementAddressType retrieves the value of the leaf ManagementAddressType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagementAddressType is set, it can
// safely use t.GetManagementAddressType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagementAddressType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetManagementAddressType() string {
	if t == nil || t.ManagementAddressType == nil {
		return ""
	}
	return *t.ManagementAddressType
}

// GetPortDescription retrieves the value of the leaf PortDescription from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortDescription is set, it can
// safely use t.GetPortDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortDescription == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortDescription() string {
	if t == nil || t.PortDescription == nil {
		return ""
	}
	return *t.PortDescription
}

// GetPortId retrieves the value of the leaf PortId from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortId is set, it can
// safely use t.GetPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortId == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortId() string {
	if t == nil || t.PortId == nil {
		return ""
	}
	return *t.PortId
}

// GetPortIdType retrieves the value of the leaf PortIdType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortIdType is set, it can
// safely use t.GetPortIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortIdType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortIdType() E_LldpTypes_PortIdType {
	if t == nil || t.PortIdType == 0 {
		return 0
	}
	return t.PortIdType
}

// GetSystemDescription retrieves the value of the leaf SystemDescription from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemDescription is set, it can
// safely use t.GetSystemDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemDescription == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetSystemDescription() string {
	if t == nil || t.SystemDescription == nil {
		return ""
	}
	return *t.SystemDescription
}

// GetSystemName retrieves the value of the leaf SystemName from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemName is set, it can
// safely use t.GetSystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemName == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetSystemName() string {
	if t == nil || t.SystemName == nil {
		return ""
	}
	return *t.SystemName
}

// GetTtl retrieves the value of the leaf Ttl from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ttl is set, it can
// safely use t.GetTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ttl == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetTtl() uint16 {
	if t == nil || t.Ttl == nil {
		return 0
	}
	return *t.Ttl
}

// SetAge sets the value of the leaf Age in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetAge(v uint64) {
	t.Age = &v
}

// SetChassisId sets the value of the leaf ChassisId in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetChassisId(v string) {
	t.ChassisId = &v
}

// SetChassisIdType sets the value of the leaf ChassisIdType in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetChassisIdType(v E_LldpTypes_ChassisIdType) {
	t.ChassisIdType = v
}

// SetId sets the value of the leaf Id in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetId(v string) {
	t.Id = &v
}

// SetLastUpdate sets the value of the leaf LastUpdate in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetLastUpdate(v int64) {
	t.LastUpdate = &v
}

// SetManagementAddress sets the value of the leaf ManagementAddress in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetManagementAddress(v string) {
	t.ManagementAddress = &v
}

// SetManagementAddressType sets the value of the leaf ManagementAddressType in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetManagementAddressType(v string) {
	t.ManagementAddressType = &v
}

// SetPortDescription sets the value of the leaf PortDescription in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetPortDescription(v string) {
	t.PortDescription = &v
}

// SetPortId sets the value of the leaf PortId in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetPortId(v string) {
	t.PortId = &v
}

// SetPortIdType sets the value of the leaf PortIdType in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetPortIdType(v E_LldpTypes_PortIdType) {
	t.PortIdType = v
}

// SetSystemDescription sets the value of the leaf SystemDescription in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetSystemDescription(v string) {
	t.SystemDescription = &v
}

// SetSystemName sets the value of the leaf SystemName in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetSystemName(v string) {
	t.SystemName = &v
}

// SetTtl sets the value of the leaf Ttl in the Lldp_Interface_Neighbor
// struct.
func (t *Lldp_Interface_Neighbor) SetTtl(v uint16) {
	t.Ttl = &v
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Capability {
		e.PopulateDefaults()
	}
	for _, e := range t.Tlv {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor.
func (*Lldp_Interface_Neighbor) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor_Capability represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor/capabilities/capability YANG schema element.
type Lldp_Interface_Neighbor_Capability struct {
	Enabled *bool                              `path:"state/enabled" module:"openconfig-lldp/openconfig-lldp"`
	Name    E_LldpTypes_LLDP_SYSTEM_CAPABILITY `path:"state/name|name" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"name" shadow-module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor_Capability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor_Capability) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp_Interface_Neighbor_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Capability) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetName retrieves the value of the leaf Name from the Lldp_Interface_Neighbor_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Capability) GetName() E_LldpTypes_LLDP_SYSTEM_CAPABILITY {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// SetEnabled sets the value of the leaf Enabled in the Lldp_Interface_Neighbor_Capability
// struct.
func (t *Lldp_Interface_Neighbor_Capability) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetName sets the value of the leaf Name in the Lldp_Interface_Neighbor_Capability
// struct.
func (t *Lldp_Interface_Neighbor_Capability) SetName(v E_LldpTypes_LLDP_SYSTEM_CAPABILITY) {
	t.Name = v
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor_Capability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor_Capability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Capability struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Capability) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Capability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor_Capability.
func (*Lldp_Interface_Neighbor_Capability) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor_Tlv represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor/custom-tlvs/tlv YANG schema element.
type Lldp_Interface_Neighbor_Tlv struct {
	Oui        *string `path:"state/oui|oui" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"oui" shadow-module:"openconfig-lldp"`
	OuiSubtype *string `path:"state/oui-subtype|oui-subtype" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"oui-subtype" shadow-module:"openconfig-lldp"`
	Type       *int32  `path:"state/type|type" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"type" shadow-module:"openconfig-lldp"`
	Value      Binary  `path:"state/value" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor_Tlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor_Tlv) IsYANGGoStruct() {}

// GetOui retrieves the value of the leaf Oui from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Oui is set, it can
// safely use t.GetOui() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Oui == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetOui() string {
	if t == nil || t.Oui == nil {
		return ""
	}
	return *t.Oui
}

// GetOuiSubtype retrieves the value of the leaf OuiSubtype from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuiSubtype is set, it can
// safely use t.GetOuiSubtype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuiSubtype == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetOuiSubtype() string {
	if t == nil || t.OuiSubtype == nil {
		return ""
	}
	return *t.OuiSubtype
}

// GetType retrieves the value of the leaf Type from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetType() int32 {
	if t == nil || t.Type == nil {
		return 0
	}
	return *t.Type
}

// GetValue retrieves the value of the leaf Value from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetValue() Binary {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// SetOui sets the value of the leaf Oui in the Lldp_Interface_Neighbor_Tlv
// struct.
func (t *Lldp_Interface_Neighbor_Tlv) SetOui(v string) {
	t.Oui = &v
}

// SetOuiSubtype sets the value of the leaf OuiSubtype in the Lldp_Interface_Neighbor_Tlv
// struct.
func (t *Lldp_Interface_Neighbor_Tlv) SetOuiSubtype(v string) {
	t.OuiSubtype = &v
}

// SetType sets the value of the leaf Type in the Lldp_Interface_Neighbor_Tlv
// struct.
func (t *Lldp_Interface_Neighbor_Tlv) SetType(v int32) {
	t.Type = &v
}

// SetValue sets the value of the leaf Value in the Lldp_Interface_Neighbor_Tlv
// struct.
func (t *Lldp_Interface_Neighbor_Tlv) SetValue(v Binary) {
	t.Value = v
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor_Tlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor_Tlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Tlv struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Tlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Oui == nil {
		return nil, fmt.Errorf("nil value for key Oui")
	}

	if t.OuiSubtype == nil {
		return nil, fmt.Errorf("nil value for key OuiSubtype")
	}

	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"oui":         *t.Oui,
		"oui-subtype": *t.OuiSubtype,
		"type":        *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Tlv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor_Tlv.
func (*Lldp_Interface_Neighbor_Tlv) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// NetworkInstance represents the /openconfig-network-instance/network-instances/network-instance YANG schema element.
type NetworkInstance struct {
	Afts                    *NetworkInstance_Afts                                                    `path:"afts" module:"openconfig-network-instance"`
	ConnectionPoint         map[string]*NetworkInstance_ConnectionPoint                              `path:"connection-points/connection-point" module:"openconfig-network-instance/openconfig-network-instance"`
	Description             *string                                                                  `path:"state/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Encapsulation           *NetworkInstance_Encapsulation                                           `path:"encapsulation" module:"openconfig-network-instance"`
	Evpn                    *NetworkInstance_Evpn                                                    `path:"evpn" module:"openconfig-network-instance"`
	FallbackNetworkInstance *string                                                                  `path:"state/fallback-network-instance" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/fallback-network-instance" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Fdb                     *NetworkInstance_Fdb                                                     `path:"fdb" module:"openconfig-network-instance"`
	InterInstancePolicies   *NetworkInstance_InterInstancePolicies                                   `path:"inter-instance-policies" module:"openconfig-network-instance"`
	Interface               map[string]*NetworkInstance_Interface                                    `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Mpls                    *NetworkInstance_Mpls                                                    `path:"mpls" module:"openconfig-network-instance"`
	Name                    *string                                                                  `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	PolicyForwarding        *NetworkInstance_PolicyForwarding                                        `path:"policy-forwarding" module:"openconfig-network-instance"`
	Protocol                map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol               `path:"protocols/protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	RouteDistinguisher      *string                                                                  `path:"state/route-distinguisher" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/route-distinguisher" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RouteLimit              map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit                   `path:"route-limits/route-limit" module:"openconfig-network-instance/openconfig-network-instance"`
	RouterId                *string                                                                  `path:"state/router-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/router-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SegmentRouting          *NetworkInstance_SegmentRouting                                          `path:"segment-routing" module:"openconfig-network-instance"`
	Table                   map[NetworkInstance_Table_Key]*NetworkInstance_Table                     `path:"tables/table" module:"openconfig-network-instance/openconfig-network-instance"`
	TableConnection         map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection `path:"table-connections/table-connection" module:"openconfig-network-instance/openconfig-network-instance"`
	Type                    E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE                             `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan                    map[uint16]*NetworkInstance_Vlan                                         `path:"vlans/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance) IsYANGGoStruct() {}

// NetworkInstance_Protocol_Key represents the key for list Protocol of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_Protocol_Key struct {
	Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"identifier"`
	Name       string                              `path:"name"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Protocol_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Protocol_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Protocol_Key key struct.
func (t NetworkInstance_Protocol_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"identifier": t.Identifier,
		"name":       t.Name,
	}, nil
}

// NetworkInstance_Table_Key represents the key for list Table of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_Table_Key struct {
	Protocol      E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"protocol"`
	AddressFamily E_Types_ADDRESS_FAMILY              `path:"address-family"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Table_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Table_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Table_Key key struct.
func (t NetworkInstance_Table_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"protocol":       t.Protocol,
		"address-family": t.AddressFamily,
	}, nil
}

// NetworkInstance_TableConnection_Key represents the key for list TableConnection of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_TableConnection_Key struct {
	SrcProtocol   E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"src-protocol"`
	DstProtocol   E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"dst-protocol"`
	AddressFamily E_Types_ADDRESS_FAMILY              `path:"address-family"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_TableConnection_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_TableConnection_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_TableConnection_Key key struct.
func (t NetworkInstance_TableConnection_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"src-protocol":   t.SrcProtocol,
		"dst-protocol":   t.DstProtocol,
		"address-family": t.AddressFamily,
	}, nil
}

// NewConnectionPoint creates a new entry in the ConnectionPoint list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewConnectionPoint(ConnectionPointId string) (*NetworkInstance_ConnectionPoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	key := ConnectionPointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConnectionPoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConnectionPoint", key)
	}

	t.ConnectionPoint[key] = &NetworkInstance_ConnectionPoint{
		ConnectionPointId: &ConnectionPointId,
	}

	return t.ConnectionPoint[key], nil
}

// RenameConnectionPoint renames an entry in the list ConnectionPoint within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameConnectionPoint(oldK, newK string) error {
	if _, ok := t.ConnectionPoint[newK]; ok {
		return fmt.Errorf("key %v already exists in ConnectionPoint", newK)
	}

	e, ok := t.ConnectionPoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConnectionPoint", oldK)
	}
	e.ConnectionPointId = &newK

	t.ConnectionPoint[newK] = e
	delete(t.ConnectionPoint, oldK)
	return nil
}

// GetOrCreateConnectionPointMap returns the list (map) from NetworkInstance.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance) GetOrCreateConnectionPointMap() map[string]*NetworkInstance_ConnectionPoint {
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}
	return t.ConnectionPoint
}

// GetOrCreateConnectionPoint retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	key := ConnectionPointId

	if v, ok := t.ConnectionPoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConnectionPoint(ConnectionPointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConnectionPoint got unexpected error: %v", err))
	}
	return v
}

// GetConnectionPoint retrieves the value with the specified key from
// the ConnectionPoint map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	if t == nil {
		return nil
	}

	key := ConnectionPointId

	if lm, ok := t.ConnectionPoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConnectionPoint deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteConnectionPoint(ConnectionPointId string) {
	key := ConnectionPointId

	delete(t.ConnectionPoint, key)
}

// AppendConnectionPoint appends the supplied NetworkInstance_ConnectionPoint struct to the
// list ConnectionPoint of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendConnectionPoint(v *NetworkInstance_ConnectionPoint) error {
	if v.ConnectionPointId == nil {
		return fmt.Errorf("invalid nil key received for ConnectionPointId")
	}

	key := *v.ConnectionPointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	if _, ok := t.ConnectionPoint[key]; ok {
		return fmt.Errorf("duplicate key for list ConnectionPoint %v", key)
	}

	t.ConnectionPoint[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewInterface(Id string) (*NetworkInstance_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from NetworkInstance.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance) GetOrCreateInterfaceMap() map[string]*NetworkInstance_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateInterface(Id string) *NetworkInstance_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetInterface(Id string) *NetworkInstance_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteInterface(Id string) {
	key := Id

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Interface struct to the
// list Interface of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendInterface(v *NetworkInstance_Interface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewProtocol creates a new entry in the Protocol list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) (*NetworkInstance_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NetworkInstance_Protocol{
		Identifier: Identifier,
		Name:       &Name,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameProtocol(oldK, newK NetworkInstance_Protocol_Key) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.Identifier = newK.Identifier
	e.Name = &newK.Name

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocolMap returns the list (map) from NetworkInstance.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance) GetOrCreateProtocolMap() map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol {
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}
	return t.Protocol
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(Identifier, Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocol deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) {
	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	delete(t.Protocol, key)
}

// AppendProtocol appends the supplied NetworkInstance_Protocol struct to the
// list Protocol of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendProtocol(v *NetworkInstance_Protocol) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key for Name")
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: v.Identifier,
		Name:       *v.Name,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// NewRouteLimit creates a new entry in the RouteLimit list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewRouteLimit(Afi E_Types_ADDRESS_FAMILY) (*NetworkInstance_RouteLimit, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	key := Afi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RouteLimit[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RouteLimit", key)
	}

	t.RouteLimit[key] = &NetworkInstance_RouteLimit{
		Afi: Afi,
	}

	return t.RouteLimit[key], nil
}

// RenameRouteLimit renames an entry in the list RouteLimit within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameRouteLimit(oldK, newK E_Types_ADDRESS_FAMILY) error {
	if _, ok := t.RouteLimit[newK]; ok {
		return fmt.Errorf("key %v already exists in RouteLimit", newK)
	}

	e, ok := t.RouteLimit[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RouteLimit", oldK)
	}
	e.Afi = newK

	t.RouteLimit[newK] = e
	delete(t.RouteLimit, oldK)
	return nil
}

// GetOrCreateRouteLimitMap returns the list (map) from NetworkInstance.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance) GetOrCreateRouteLimitMap() map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit {
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}
	return t.RouteLimit
}

// GetOrCreateRouteLimit retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateRouteLimit(Afi E_Types_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	key := Afi

	if v, ok := t.RouteLimit[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRouteLimit(Afi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRouteLimit got unexpected error: %v", err))
	}
	return v
}

// GetRouteLimit retrieves the value with the specified key from
// the RouteLimit map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetRouteLimit(Afi E_Types_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	if t == nil {
		return nil
	}

	key := Afi

	if lm, ok := t.RouteLimit[key]; ok {
		return lm
	}
	return nil
}

// DeleteRouteLimit deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteRouteLimit(Afi E_Types_ADDRESS_FAMILY) {
	key := Afi

	delete(t.RouteLimit, key)
}

// AppendRouteLimit appends the supplied NetworkInstance_RouteLimit struct to the
// list RouteLimit of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_RouteLimit already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendRouteLimit(v *NetworkInstance_RouteLimit) error {
	key := v.Afi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	if _, ok := t.RouteLimit[key]; ok {
		return fmt.Errorf("duplicate key for list RouteLimit %v", key)
	}

	t.RouteLimit[key] = v
	return nil
}

// NewTable creates a new entry in the Table list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) (*NetworkInstance_Table, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Table[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Table", key)
	}

	t.Table[key] = &NetworkInstance_Table{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	return t.Table[key], nil
}

// RenameTable renames an entry in the list Table within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTable(oldK, newK NetworkInstance_Table_Key) error {
	if _, ok := t.Table[newK]; ok {
		return fmt.Errorf("key %v already exists in Table", newK)
	}

	e, ok := t.Table[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Table", oldK)
	}
	e.Protocol = newK.Protocol
	e.AddressFamily = newK.AddressFamily

	t.Table[newK] = e
	delete(t.Table, oldK)
	return nil
}

// GetOrCreateTableMap returns the list (map) from NetworkInstance.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance) GetOrCreateTableMap() map[NetworkInstance_Table_Key]*NetworkInstance_Table {
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}
	return t.Table
}

// GetOrCreateTable retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_Table {

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.Table[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTable(Protocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTable got unexpected error: %v", err))
	}
	return v
}

// GetTable retrieves the value with the specified key from
// the Table map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_Table {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.Table[key]; ok {
		return lm
	}
	return nil
}

// DeleteTable deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) {
	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	delete(t.Table, key)
}

// AppendTable appends the supplied NetworkInstance_Table struct to the
// list Table of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Table already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTable(v *NetworkInstance_Table) error {
	key := NetworkInstance_Table_Key{
		Protocol:      v.Protocol,
		AddressFamily: v.AddressFamily,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	if _, ok := t.Table[key]; ok {
		return fmt.Errorf("duplicate key for list Table %v", key)
	}

	t.Table[key] = v
	return nil
}

// NewTableConnection creates a new entry in the TableConnection list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) (*NetworkInstance_TableConnection, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TableConnection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TableConnection", key)
	}

	t.TableConnection[key] = &NetworkInstance_TableConnection{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	return t.TableConnection[key], nil
}

// RenameTableConnection renames an entry in the list TableConnection within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTableConnection(oldK, newK NetworkInstance_TableConnection_Key) error {
	if _, ok := t.TableConnection[newK]; ok {
		return fmt.Errorf("key %v already exists in TableConnection", newK)
	}

	e, ok := t.TableConnection[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TableConnection", oldK)
	}
	e.SrcProtocol = newK.SrcProtocol
	e.DstProtocol = newK.DstProtocol
	e.AddressFamily = newK.AddressFamily

	t.TableConnection[newK] = e
	delete(t.TableConnection, oldK)
	return nil
}

// GetOrCreateTableConnectionMap returns the list (map) from NetworkInstance.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance) GetOrCreateTableConnectionMap() map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection {
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}
	return t.TableConnection
}

// GetOrCreateTableConnection retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.TableConnection[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTableConnection(SrcProtocol, DstProtocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTableConnection got unexpected error: %v", err))
	}
	return v
}

// GetTableConnection retrieves the value with the specified key from
// the TableConnection map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	if t == nil {
		return nil
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.TableConnection[key]; ok {
		return lm
	}
	return nil
}

// DeleteTableConnection deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	delete(t.TableConnection, key)
}

// AppendTableConnection appends the supplied NetworkInstance_TableConnection struct to the
// list TableConnection of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_TableConnection already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTableConnection(v *NetworkInstance_TableConnection) error {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   v.SrcProtocol,
		DstProtocol:   v.DstProtocol,
		AddressFamily: v.AddressFamily,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	if _, ok := t.TableConnection[key]; ok {
		return fmt.Errorf("duplicate key for list TableConnection %v", key)
	}

	t.TableConnection[key] = v
	return nil
}

// NewVlan creates a new entry in the Vlan list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewVlan(VlanId uint16) (*NetworkInstance_Vlan, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vlan[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vlan", key)
	}

	t.Vlan[key] = &NetworkInstance_Vlan{
		VlanId: &VlanId,
	}

	return t.Vlan[key], nil
}

// RenameVlan renames an entry in the list Vlan within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameVlan(oldK, newK uint16) error {
	if _, ok := t.Vlan[newK]; ok {
		return fmt.Errorf("key %v already exists in Vlan", newK)
	}

	e, ok := t.Vlan[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vlan", oldK)
	}
	e.VlanId = &newK

	t.Vlan[newK] = e
	delete(t.Vlan, oldK)
	return nil
}

// GetOrCreateVlanMap returns the list (map) from NetworkInstance.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance) GetOrCreateVlanMap() map[uint16]*NetworkInstance_Vlan {
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}
	return t.Vlan
}

// GetOrCreateVlan retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateVlan(VlanId uint16) *NetworkInstance_Vlan {

	key := VlanId

	if v, ok := t.Vlan[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlan(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlan got unexpected error: %v", err))
	}
	return v
}

// GetVlan retrieves the value with the specified key from
// the Vlan map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetVlan(VlanId uint16) *NetworkInstance_Vlan {

	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.Vlan[key]; ok {
		return lm
	}
	return nil
}

// DeleteVlan deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteVlan(VlanId uint16) {
	key := VlanId

	delete(t.Vlan, key)
}

// AppendVlan appends the supplied NetworkInstance_Vlan struct to the
// list Vlan of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Vlan already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendVlan(v *NetworkInstance_Vlan) error {
	if v.VlanId == nil {
		return fmt.Errorf("invalid nil key received for VlanId")
	}

	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	if _, ok := t.Vlan[key]; ok {
		return fmt.Errorf("duplicate key for list Vlan %v", key)
	}

	t.Vlan[key] = v
	return nil
}

// GetOrCreateAfts retrieves the value of the Afts field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateAfts() *NetworkInstance_Afts {
	if t.Afts != nil {
		return t.Afts
	}
	t.Afts = &NetworkInstance_Afts{}
	return t.Afts
}

// GetOrCreateEncapsulation retrieves the value of the Encapsulation field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEncapsulation() *NetworkInstance_Encapsulation {
	if t.Encapsulation != nil {
		return t.Encapsulation
	}
	t.Encapsulation = &NetworkInstance_Encapsulation{}
	return t.Encapsulation
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEvpn() *NetworkInstance_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &NetworkInstance_Evpn{}
	return t.Evpn
}

// GetOrCreateFdb retrieves the value of the Fdb field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateFdb() *NetworkInstance_Fdb {
	if t.Fdb != nil {
		return t.Fdb
	}
	t.Fdb = &NetworkInstance_Fdb{}
	return t.Fdb
}

// GetOrCreateInterInstancePolicies retrieves the value of the InterInstancePolicies field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	t.InterInstancePolicies = &NetworkInstance_InterInstancePolicies{}
	return t.InterInstancePolicies
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateMpls() *NetworkInstance_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Mpls{}
	return t.Mpls
}

// GetOrCreatePolicyForwarding retrieves the value of the PolicyForwarding field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreatePolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	t.PolicyForwarding = &NetworkInstance_PolicyForwarding{}
	return t.PolicyForwarding
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateSegmentRouting() *NetworkInstance_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_SegmentRouting{}
	return t.SegmentRouting
}

// GetAfts returns the value of the Afts struct pointer
// from NetworkInstance. If the receiver or the field Afts is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetAfts() *NetworkInstance_Afts {
	if t != nil && t.Afts != nil {
		return t.Afts
	}
	return nil
}

// GetEncapsulation returns the value of the Encapsulation struct pointer
// from NetworkInstance. If the receiver or the field Encapsulation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEncapsulation() *NetworkInstance_Encapsulation {
	if t != nil && t.Encapsulation != nil {
		return t.Encapsulation
	}
	return nil
}

// GetEvpn returns the value of the Evpn struct pointer
// from NetworkInstance. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEvpn() *NetworkInstance_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetFdb returns the value of the Fdb struct pointer
// from NetworkInstance. If the receiver or the field Fdb is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetFdb() *NetworkInstance_Fdb {
	if t != nil && t.Fdb != nil {
		return t.Fdb
	}
	return nil
}

// GetInterInstancePolicies returns the value of the InterInstancePolicies struct pointer
// from NetworkInstance. If the receiver or the field InterInstancePolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t != nil && t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetMpls() *NetworkInstance_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetPolicyForwarding returns the value of the PolicyForwarding struct pointer
// from NetworkInstance. If the receiver or the field PolicyForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetPolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t != nil && t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetSegmentRouting() *NetworkInstance_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFallbackNetworkInstance retrieves the value of the leaf FallbackNetworkInstance from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallbackNetworkInstance is set, it can
// safely use t.GetFallbackNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallbackNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetFallbackNetworkInstance() string {
	if t == nil || t.FallbackNetworkInstance == nil {
		return ""
	}
	return *t.FallbackNetworkInstance
}

// GetName retrieves the value of the leaf Name from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRouteDistinguisher retrieves the value of the leaf RouteDistinguisher from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteDistinguisher is set, it can
// safely use t.GetRouteDistinguisher() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteDistinguisher == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetRouteDistinguisher() string {
	if t == nil || t.RouteDistinguisher == nil {
		return ""
	}
	return *t.RouteDistinguisher
}

// GetRouterId retrieves the value of the leaf RouterId from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// GetType retrieves the value of the leaf Type from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetType() E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetDescription sets the value of the leaf Description in the NetworkInstance
// struct.
func (t *NetworkInstance) SetDescription(v string) {
	t.Description = &v
}

// SetFallbackNetworkInstance sets the value of the leaf FallbackNetworkInstance in the NetworkInstance
// struct.
func (t *NetworkInstance) SetFallbackNetworkInstance(v string) {
	t.FallbackNetworkInstance = &v
}

// SetName sets the value of the leaf Name in the NetworkInstance
// struct.
func (t *NetworkInstance) SetName(v string) {
	t.Name = &v
}

// SetRouteDistinguisher sets the value of the leaf RouteDistinguisher in the NetworkInstance
// struct.
func (t *NetworkInstance) SetRouteDistinguisher(v string) {
	t.RouteDistinguisher = &v
}

// SetRouterId sets the value of the leaf RouterId in the NetworkInstance
// struct.
func (t *NetworkInstance) SetRouterId(v string) {
	t.RouterId = &v
}

// SetType sets the value of the leaf Type in the NetworkInstance
// struct.
func (t *NetworkInstance) SetType(v E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Afts.PopulateDefaults()
	t.Encapsulation.PopulateDefaults()
	t.Evpn.PopulateDefaults()
	t.Fdb.PopulateDefaults()
	t.InterInstancePolicies.PopulateDefaults()
	t.Mpls.PopulateDefaults()
	t.PolicyForwarding.PopulateDefaults()
	t.SegmentRouting.PopulateDefaults()
	for _, e := range t.ConnectionPoint {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.Protocol {
		e.PopulateDefaults()
	}
	for _, e := range t.RouteLimit {
		e.PopulateDefaults()
	}
	for _, e := range t.Table {
		e.PopulateDefaults()
	}
	for _, e := range t.TableConnection {
		e.PopulateDefaults()
	}
	for _, e := range t.Vlan {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance struct, which is a YANG list entry.
func (t *NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance.
func (*NetworkInstance) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts represents the /openconfig-network-instance/network-instances/network-instance/afts YANG schema element.
type NetworkInstance_Afts struct {
	AftSummaries          *NetworkInstance_Afts_AftSummaries                                               `path:"aft-summaries" module:"openconfig-aft-summary"`
	Ipv4Entry             map[string]*NetworkInstance_Afts_Ipv4Entry                                       `path:"ipv4-unicast/ipv4-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv6Entry             map[string]*NetworkInstance_Afts_Ipv6Entry                                       `path:"ipv6-unicast/ipv6-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	LabelEntry            map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry `path:"mpls/label-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	MacEntry              map[string]*NetworkInstance_Afts_MacEntry                                        `path:"ethernet/mac-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop               map[uint64]*NetworkInstance_Afts_NextHop                                         `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup          map[uint64]*NetworkInstance_Afts_NextHopGroup                                    `path:"next-hop-groups/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	PolicyForwardingEntry map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry                           `path:"policy-forwarding/policy-forwarding-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	StateSynced           *NetworkInstance_Afts_StateSynced                                                `path:"state-synced" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts) IsYANGGoStruct() {}

// NewIpv4Entry creates a new entry in the Ipv4Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv4Entry(Prefix string) (*NetworkInstance_Afts_Ipv4Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Entry", key)
	}

	t.Ipv4Entry[key] = &NetworkInstance_Afts_Ipv4Entry{
		Prefix: &Prefix,
	}

	return t.Ipv4Entry[key], nil
}

// RenameIpv4Entry renames an entry in the list Ipv4Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv4Entry(oldK, newK string) error {
	if _, ok := t.Ipv4Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Entry", newK)
	}

	e, ok := t.Ipv4Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv4Entry[newK] = e
	delete(t.Ipv4Entry, oldK)
	return nil
}

// GetOrCreateIpv4EntryMap returns the list (map) from NetworkInstance_Afts.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts) GetOrCreateIpv4EntryMap() map[string]*NetworkInstance_Afts_Ipv4Entry {
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}
	return t.Ipv4Entry
}

// GetOrCreateIpv4Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	key := Prefix

	if v, ok := t.Ipv4Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Entry retrieves the value with the specified key from
// the Ipv4Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv4Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv4Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv4Entry, key)
}

// AppendIpv4Entry appends the supplied NetworkInstance_Afts_Ipv4Entry struct to the
// list Ipv4Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv4Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv4Entry(v *NetworkInstance_Afts_Ipv4Entry) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	if _, ok := t.Ipv4Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Entry %v", key)
	}

	t.Ipv4Entry[key] = v
	return nil
}

// NewIpv6Entry creates a new entry in the Ipv6Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv6Entry(Prefix string) (*NetworkInstance_Afts_Ipv6Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Entry", key)
	}

	t.Ipv6Entry[key] = &NetworkInstance_Afts_Ipv6Entry{
		Prefix: &Prefix,
	}

	return t.Ipv6Entry[key], nil
}

// RenameIpv6Entry renames an entry in the list Ipv6Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv6Entry(oldK, newK string) error {
	if _, ok := t.Ipv6Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Entry", newK)
	}

	e, ok := t.Ipv6Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv6Entry[newK] = e
	delete(t.Ipv6Entry, oldK)
	return nil
}

// GetOrCreateIpv6EntryMap returns the list (map) from NetworkInstance_Afts.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts) GetOrCreateIpv6EntryMap() map[string]*NetworkInstance_Afts_Ipv6Entry {
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}
	return t.Ipv6Entry
}

// GetOrCreateIpv6Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	key := Prefix

	if v, ok := t.Ipv6Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Entry retrieves the value with the specified key from
// the Ipv6Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv6Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv6Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv6Entry, key)
}

// AppendIpv6Entry appends the supplied NetworkInstance_Afts_Ipv6Entry struct to the
// list Ipv6Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv6Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv6Entry(v *NetworkInstance_Afts_Ipv6Entry) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	if _, ok := t.Ipv6Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Entry %v", key)
	}

	t.Ipv6Entry[key] = v
	return nil
}

// NewLabelEntry creates a new entry in the LabelEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) (*NetworkInstance_Afts_LabelEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	key := Label

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LabelEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LabelEntry", key)
	}

	t.LabelEntry[key] = &NetworkInstance_Afts_LabelEntry{
		Label: Label,
	}

	return t.LabelEntry[key], nil
}

// RenameLabelEntry renames an entry in the list LabelEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameLabelEntry(oldK, newK NetworkInstance_Afts_LabelEntry_Label_Union) error {
	if _, ok := t.LabelEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in LabelEntry", newK)
	}

	e, ok := t.LabelEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LabelEntry", oldK)
	}
	e.Label = newK

	t.LabelEntry[newK] = e
	delete(t.LabelEntry, oldK)
	return nil
}

// GetOrCreateLabelEntryMap returns the list (map) from NetworkInstance_Afts.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts) GetOrCreateLabelEntryMap() map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry {
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}
	return t.LabelEntry
}

// GetOrCreateLabelEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	key := Label

	if v, ok := t.LabelEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLabelEntry(Label)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLabelEntry got unexpected error: %v", err))
	}
	return v
}

// GetLabelEntry retrieves the value with the specified key from
// the LabelEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	if t == nil {
		return nil
	}

	key := Label

	if lm, ok := t.LabelEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteLabelEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) {
	key := Label

	delete(t.LabelEntry, key)
}

// AppendLabelEntry appends the supplied NetworkInstance_Afts_LabelEntry struct to the
// list LabelEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_LabelEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendLabelEntry(v *NetworkInstance_Afts_LabelEntry) error {
	key := v.Label

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	if _, ok := t.LabelEntry[key]; ok {
		return fmt.Errorf("duplicate key for list LabelEntry %v", key)
	}

	t.LabelEntry[key] = v
	return nil
}

// NewMacEntry creates a new entry in the MacEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewMacEntry(MacAddress string) (*NetworkInstance_Afts_MacEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MacEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MacEntry", key)
	}

	t.MacEntry[key] = &NetworkInstance_Afts_MacEntry{
		MacAddress: &MacAddress,
	}

	return t.MacEntry[key], nil
}

// RenameMacEntry renames an entry in the list MacEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameMacEntry(oldK, newK string) error {
	if _, ok := t.MacEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in MacEntry", newK)
	}

	e, ok := t.MacEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MacEntry", oldK)
	}
	e.MacAddress = &newK

	t.MacEntry[newK] = e
	delete(t.MacEntry, oldK)
	return nil
}

// GetOrCreateMacEntryMap returns the list (map) from NetworkInstance_Afts.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts) GetOrCreateMacEntryMap() map[string]*NetworkInstance_Afts_MacEntry {
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}
	return t.MacEntry
}

// GetOrCreateMacEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	key := MacAddress

	if v, ok := t.MacEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacEntry got unexpected error: %v", err))
	}
	return v
}

// GetMacEntry retrieves the value with the specified key from
// the MacEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.MacEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteMacEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteMacEntry(MacAddress string) {
	key := MacAddress

	delete(t.MacEntry, key)
}

// AppendMacEntry appends the supplied NetworkInstance_Afts_MacEntry struct to the
// list MacEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_MacEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendMacEntry(v *NetworkInstance_Afts_MacEntry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key received for MacAddress")
	}

	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	if _, ok := t.MacEntry[key]; ok {
		return fmt.Errorf("duplicate key for list MacEntry %v", key)
	}

	t.MacEntry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHopMap returns the list (map) from NetworkInstance_Afts.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts) GetOrCreateNextHopMap() map[uint64]*NetworkInstance_Afts_NextHop {
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}
	return t.NextHop
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHop struct to the
// list NextHop of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHop(v *NetworkInstance_Afts_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHopGroup(Id uint64) (*NetworkInstance_Afts_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Afts_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroupMap returns the list (map) from NetworkInstance_Afts.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts) GetOrCreateNextHopGroupMap() map[uint64]*NetworkInstance_Afts_NextHopGroup {
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}
	return t.NextHopGroup
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Afts_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHopGroup(v *NetworkInstance_Afts_NextHopGroup) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// NewPolicyForwardingEntry creates a new entry in the PolicyForwardingEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewPolicyForwardingEntry(Index uint64) (*NetworkInstance_Afts_PolicyForwardingEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicyForwardingEntry", key)
	}

	t.PolicyForwardingEntry[key] = &NetworkInstance_Afts_PolicyForwardingEntry{
		Index: &Index,
	}

	return t.PolicyForwardingEntry[key], nil
}

// RenamePolicyForwardingEntry renames an entry in the list PolicyForwardingEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenamePolicyForwardingEntry(oldK, newK uint64) error {
	if _, ok := t.PolicyForwardingEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicyForwardingEntry", newK)
	}

	e, ok := t.PolicyForwardingEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicyForwardingEntry", oldK)
	}
	e.Index = &newK

	t.PolicyForwardingEntry[newK] = e
	delete(t.PolicyForwardingEntry, oldK)
	return nil
}

// GetOrCreatePolicyForwardingEntryMap returns the list (map) from NetworkInstance_Afts.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts) GetOrCreatePolicyForwardingEntryMap() map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry {
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}
	return t.PolicyForwardingEntry
}

// GetOrCreatePolicyForwardingEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreatePolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	key := Index

	if v, ok := t.PolicyForwardingEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicyForwardingEntry(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicyForwardingEntry got unexpected error: %v", err))
	}
	return v
}

// GetPolicyForwardingEntry retrieves the value with the specified key from
// the PolicyForwardingEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetPolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.PolicyForwardingEntry[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicyForwardingEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeletePolicyForwardingEntry(Index uint64) {
	key := Index

	delete(t.PolicyForwardingEntry, key)
}

// AppendPolicyForwardingEntry appends the supplied NetworkInstance_Afts_PolicyForwardingEntry struct to the
// list PolicyForwardingEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_PolicyForwardingEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendPolicyForwardingEntry(v *NetworkInstance_Afts_PolicyForwardingEntry) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return fmt.Errorf("duplicate key for list PolicyForwardingEntry %v", key)
	}

	t.PolicyForwardingEntry[key] = v
	return nil
}

// GetOrCreateAftSummaries retrieves the value of the AftSummaries field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts) GetOrCreateAftSummaries() *NetworkInstance_Afts_AftSummaries {
	if t.AftSummaries != nil {
		return t.AftSummaries
	}
	t.AftSummaries = &NetworkInstance_Afts_AftSummaries{}
	return t.AftSummaries
}

// GetOrCreateStateSynced retrieves the value of the StateSynced field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts) GetOrCreateStateSynced() *NetworkInstance_Afts_StateSynced {
	if t.StateSynced != nil {
		return t.StateSynced
	}
	t.StateSynced = &NetworkInstance_Afts_StateSynced{}
	return t.StateSynced
}

// GetAftSummaries returns the value of the AftSummaries struct pointer
// from NetworkInstance_Afts. If the receiver or the field AftSummaries is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts) GetAftSummaries() *NetworkInstance_Afts_AftSummaries {
	if t != nil && t.AftSummaries != nil {
		return t.AftSummaries
	}
	return nil
}

// GetStateSynced returns the value of the StateSynced struct pointer
// from NetworkInstance_Afts. If the receiver or the field StateSynced is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts) GetStateSynced() *NetworkInstance_Afts_StateSynced {
	if t != nil && t.StateSynced != nil {
		return t.StateSynced
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AftSummaries.PopulateDefaults()
	t.StateSynced.PopulateDefaults()
	for _, e := range t.Ipv4Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.LabelEntry {
		e.PopulateDefaults()
	}
	for _, e := range t.MacEntry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHopGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.PolicyForwardingEntry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts.
func (*NetworkInstance_Afts) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_AftSummaries represents the /openconfig-network-instance/network-instances/network-instance/afts/aft-summaries YANG schema element.
type NetworkInstance_Afts_AftSummaries struct {
	Ipv4Unicast *NetworkInstance_Afts_AftSummaries_Ipv4Unicast `path:"ipv4-unicast" module:"openconfig-aft-summary"`
	Ipv6Unicast *NetworkInstance_Afts_AftSummaries_Ipv6Unicast `path:"ipv6-unicast" module:"openconfig-aft-summary"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_AftSummaries implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_AftSummaries) IsYANGGoStruct() {}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_AftSummaries) GetOrCreateIpv4Unicast() *NetworkInstance_Afts_AftSummaries_Ipv4Unicast {
	if t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	t.Ipv4Unicast = &NetworkInstance_Afts_AftSummaries_Ipv4Unicast{}
	return t.Ipv4Unicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_AftSummaries) GetOrCreateIpv6Unicast() *NetworkInstance_Afts_AftSummaries_Ipv6Unicast {
	if t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	t.Ipv6Unicast = &NetworkInstance_Afts_AftSummaries_Ipv6Unicast{}
	return t.Ipv6Unicast
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from NetworkInstance_Afts_AftSummaries. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_AftSummaries) GetIpv4Unicast() *NetworkInstance_Afts_AftSummaries_Ipv4Unicast {
	if t != nil && t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from NetworkInstance_Afts_AftSummaries. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_AftSummaries) GetIpv6Unicast() *NetworkInstance_Afts_AftSummaries_Ipv6Unicast {
	if t != nil && t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_AftSummaries
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_AftSummaries) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4Unicast.PopulateDefaults()
	t.Ipv6Unicast.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_AftSummaries"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_AftSummaries) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_AftSummaries.
func (*NetworkInstance_Afts_AftSummaries) ΛBelongingModule() string {
	return "openconfig-aft-summary"
}

// NetworkInstance_Afts_AftSummaries_Ipv4Unicast represents the /openconfig-network-instance/network-instances/network-instance/afts/aft-summaries/ipv4-unicast YANG schema element.
type NetworkInstance_Afts_AftSummaries_Ipv4Unicast struct {
	Protocol map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol `path:"protocols/protocol" module:"openconfig-aft-summary/openconfig-aft-summary"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_AftSummaries_Ipv4Unicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_AftSummaries_Ipv4Unicast) IsYANGGoStruct() {}

// NewProtocol creates a new entry in the Protocol list of the
// NetworkInstance_Afts_AftSummaries_Ipv4Unicast struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) NewProtocol(OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE) (*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol)
	}

	key := OriginProtocol

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol{
		OriginProtocol: OriginProtocol,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NetworkInstance_Afts_AftSummaries_Ipv4Unicast struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) RenameProtocol(oldK, newK E_PolicyTypes_INSTALL_PROTOCOL_TYPE) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.OriginProtocol = newK

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocolMap returns the list (map) from NetworkInstance_Afts_AftSummaries_Ipv4Unicast.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) GetOrCreateProtocolMap() map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol {
	if t.Protocol == nil {
		t.Protocol = make(map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol)
	}
	return t.Protocol
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_AftSummaries_Ipv4Unicast. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) GetOrCreateProtocol(OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE) *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol {

	key := OriginProtocol

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(OriginProtocol)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NetworkInstance_Afts_AftSummaries_Ipv4Unicast. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) GetProtocol(OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE) *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol {

	if t == nil {
		return nil
	}

	key := OriginProtocol

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocol deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_AftSummaries_Ipv4Unicast. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) DeleteProtocol(OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE) {
	key := OriginProtocol

	delete(t.Protocol, key)
}

// AppendProtocol appends the supplied NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol struct to the
// list Protocol of NetworkInstance_Afts_AftSummaries_Ipv4Unicast. If the key value(s) specified in
// the supplied NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) AppendProtocol(v *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) error {
	key := v.OriginProtocol

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_AftSummaries_Ipv4Unicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Protocol {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_AftSummaries_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_AftSummaries_Ipv4Unicast.
func (*NetworkInstance_Afts_AftSummaries_Ipv4Unicast) ΛBelongingModule() string {
	return "openconfig-aft-summary"
}

// NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol represents the /openconfig-network-instance/network-instances/network-instance/afts/aft-summaries/ipv4-unicast/protocols/protocol YANG schema element.
type NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol struct {
	Counters       *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters `path:"state/counters" module:"openconfig-aft-summary/openconfig-aft-summary"`
	OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE                              `path:"state/origin-protocol|origin-protocol" module:"openconfig-aft-summary/openconfig-aft-summary|openconfig-aft-summary" shadow-path:"origin-protocol" shadow-module:"openconfig-aft-summary"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) GetOrCreateCounters() *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) GetCounters() *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// SetOriginProtocol sets the value of the leaf OriginProtocol in the NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol
// struct.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) SetOriginProtocol(v E_PolicyTypes_INSTALL_PROTOCOL_TYPE) {
	t.OriginProtocol = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"origin-protocol": t.OriginProtocol,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol.
func (*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol) ΛBelongingModule() string {
	return "openconfig-aft-summary"
}

// NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/aft-summaries/ipv4-unicast/protocols/protocol/state/counters YANG schema element.
type NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters struct {
	AftEntries *uint64 `path:"aft-entries" module:"openconfig-aft-summary"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters) IsYANGGoStruct() {}

// GetAftEntries retrieves the value of the leaf AftEntries from the NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AftEntries is set, it can
// safely use t.GetAftEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AftEntries == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters) GetAftEntries() uint64 {
	if t == nil || t.AftEntries == nil {
		return 0
	}
	return *t.AftEntries
}

// SetAftEntries sets the value of the leaf AftEntries in the NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters
// struct.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters) SetAftEntries(v uint64) {
	t.AftEntries = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters.
func (*NetworkInstance_Afts_AftSummaries_Ipv4Unicast_Protocol_Counters) ΛBelongingModule() string {
	return "openconfig-aft-summary"
}

// NetworkInstance_Afts_AftSummaries_Ipv6Unicast represents the /openconfig-network-instance/network-instances/network-instance/afts/aft-summaries/ipv6-unicast YANG schema element.
type NetworkInstance_Afts_AftSummaries_Ipv6Unicast struct {
	Protocol map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol `path:"protocols/protocol" module:"openconfig-aft-summary/openconfig-aft-summary"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_AftSummaries_Ipv6Unicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_AftSummaries_Ipv6Unicast) IsYANGGoStruct() {}

// NewProtocol creates a new entry in the Protocol list of the
// NetworkInstance_Afts_AftSummaries_Ipv6Unicast struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) NewProtocol(OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE) (*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol)
	}

	key := OriginProtocol

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol{
		OriginProtocol: OriginProtocol,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NetworkInstance_Afts_AftSummaries_Ipv6Unicast struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) RenameProtocol(oldK, newK E_PolicyTypes_INSTALL_PROTOCOL_TYPE) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.OriginProtocol = newK

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocolMap returns the list (map) from NetworkInstance_Afts_AftSummaries_Ipv6Unicast.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) GetOrCreateProtocolMap() map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol {
	if t.Protocol == nil {
		t.Protocol = make(map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol)
	}
	return t.Protocol
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_AftSummaries_Ipv6Unicast. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) GetOrCreateProtocol(OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE) *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol {

	key := OriginProtocol

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(OriginProtocol)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NetworkInstance_Afts_AftSummaries_Ipv6Unicast. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) GetProtocol(OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE) *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol {

	if t == nil {
		return nil
	}

	key := OriginProtocol

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocol deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_AftSummaries_Ipv6Unicast. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) DeleteProtocol(OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE) {
	key := OriginProtocol

	delete(t.Protocol, key)
}

// AppendProtocol appends the supplied NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol struct to the
// list Protocol of NetworkInstance_Afts_AftSummaries_Ipv6Unicast. If the key value(s) specified in
// the supplied NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) AppendProtocol(v *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) error {
	key := v.OriginProtocol

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[E_PolicyTypes_INSTALL_PROTOCOL_TYPE]*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_AftSummaries_Ipv6Unicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Protocol {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_AftSummaries_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_AftSummaries_Ipv6Unicast.
func (*NetworkInstance_Afts_AftSummaries_Ipv6Unicast) ΛBelongingModule() string {
	return "openconfig-aft-summary"
}

// NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol represents the /openconfig-network-instance/network-instances/network-instance/afts/aft-summaries/ipv6-unicast/protocols/protocol YANG schema element.
type NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol struct {
	Counters       *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters `path:"state/counters" module:"openconfig-aft-summary/openconfig-aft-summary"`
	OriginProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE                              `path:"state/origin-protocol|origin-protocol" module:"openconfig-aft-summary/openconfig-aft-summary|openconfig-aft-summary" shadow-path:"origin-protocol" shadow-module:"openconfig-aft-summary"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) GetOrCreateCounters() *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) GetCounters() *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// SetOriginProtocol sets the value of the leaf OriginProtocol in the NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol
// struct.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) SetOriginProtocol(v E_PolicyTypes_INSTALL_PROTOCOL_TYPE) {
	t.OriginProtocol = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"origin-protocol": t.OriginProtocol,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol.
func (*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol) ΛBelongingModule() string {
	return "openconfig-aft-summary"
}

// NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/aft-summaries/ipv6-unicast/protocols/protocol/state/counters YANG schema element.
type NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters struct {
	AftEntries *uint64 `path:"aft-entries" module:"openconfig-aft-summary"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters) IsYANGGoStruct() {}

// GetAftEntries retrieves the value of the leaf AftEntries from the NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AftEntries is set, it can
// safely use t.GetAftEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AftEntries == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters) GetAftEntries() uint64 {
	if t == nil || t.AftEntries == nil {
		return 0
	}
	return *t.AftEntries
}

// SetAftEntries sets the value of the leaf AftEntries in the NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters
// struct.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters) SetAftEntries(v uint64) {
	t.AftEntries = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters.
func (*NetworkInstance_Afts_AftSummaries_Ipv6Unicast_Protocol_Counters) ΛBelongingModule() string {
	return "openconfig-aft-summary"
}

// NetworkInstance_Afts_Ipv4Entry represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry YANG schema element.
type NetworkInstance_Afts_Ipv4Entry struct {
	Counters                    *NetworkInstance_Afts_Ipv4Entry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader           E_AftTypes_EncapsulationHeaderType       `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                   `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup                *uint64                                  `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                  `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginNetworkInstance       *string                                  `path:"state/origin-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginProtocol              E_PolicyTypes_INSTALL_PROTOCOL_TYPE      `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix                      *string                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"prefix" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv4Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv4Entry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOrCreateCounters() *NetworkInstance_Afts_Ipv4Entry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_Ipv4Entry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_Ipv4Entry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_Ipv4Entry) GetCounters() *NetworkInstance_Afts_Ipv4Entry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetOriginNetworkInstance retrieves the value of the leaf OriginNetworkInstance from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginNetworkInstance is set, it can
// safely use t.GetOriginNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOriginNetworkInstance() string {
	if t == nil || t.OriginNetworkInstance == nil {
		return ""
	}
	return *t.OriginNetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// SetDecapsulateHeader sets the value of the leaf DecapsulateHeader in the NetworkInstance_Afts_Ipv4Entry
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry) SetDecapsulateHeader(v E_AftTypes_EncapsulationHeaderType) {
	t.DecapsulateHeader = v
}

// SetEntryMetadata sets the value of the leaf EntryMetadata in the NetworkInstance_Afts_Ipv4Entry
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry) SetEntryMetadata(v Binary) {
	t.EntryMetadata = v
}

// SetNextHopGroup sets the value of the leaf NextHopGroup in the NetworkInstance_Afts_Ipv4Entry
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry) SetNextHopGroup(v uint64) {
	t.NextHopGroup = &v
}

// SetNextHopGroupNetworkInstance sets the value of the leaf NextHopGroupNetworkInstance in the NetworkInstance_Afts_Ipv4Entry
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry) SetNextHopGroupNetworkInstance(v string) {
	t.NextHopGroupNetworkInstance = &v
}

// SetOriginNetworkInstance sets the value of the leaf OriginNetworkInstance in the NetworkInstance_Afts_Ipv4Entry
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry) SetOriginNetworkInstance(v string) {
	t.OriginNetworkInstance = &v
}

// SetOriginProtocol sets the value of the leaf OriginProtocol in the NetworkInstance_Afts_Ipv4Entry
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry) SetOriginProtocol(v E_PolicyTypes_INSTALL_PROTOCOL_TYPE) {
	t.OriginProtocol = v
}

// SetPrefix sets the value of the leaf Prefix in the NetworkInstance_Afts_Ipv4Entry
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry) SetPrefix(v string) {
	t.Prefix = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv4Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv4Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv4Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv4Entry.
func (*NetworkInstance_Afts_Ipv4Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv4Entry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/counters YANG schema element.
type NetworkInstance_Afts_Ipv4Entry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv4Entry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv4Entry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_Ipv4Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_Ipv4Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// SetOctetsForwarded sets the value of the leaf OctetsForwarded in the NetworkInstance_Afts_Ipv4Entry_Counters
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) SetOctetsForwarded(v uint64) {
	t.OctetsForwarded = &v
}

// SetPacketsForwarded sets the value of the leaf PacketsForwarded in the NetworkInstance_Afts_Ipv4Entry_Counters
// struct.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) SetPacketsForwarded(v uint64) {
	t.PacketsForwarded = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv4Entry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv4Entry_Counters.
func (*NetworkInstance_Afts_Ipv4Entry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv6Entry represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry YANG schema element.
type NetworkInstance_Afts_Ipv6Entry struct {
	Counters                    *NetworkInstance_Afts_Ipv6Entry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader           E_AftTypes_EncapsulationHeaderType       `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                   `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup                *uint64                                  `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                  `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginNetworkInstance       *string                                  `path:"state/origin-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginProtocol              E_PolicyTypes_INSTALL_PROTOCOL_TYPE      `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix                      *string                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"prefix" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv6Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv6Entry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOrCreateCounters() *NetworkInstance_Afts_Ipv6Entry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_Ipv6Entry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_Ipv6Entry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_Ipv6Entry) GetCounters() *NetworkInstance_Afts_Ipv6Entry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetOriginNetworkInstance retrieves the value of the leaf OriginNetworkInstance from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginNetworkInstance is set, it can
// safely use t.GetOriginNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOriginNetworkInstance() string {
	if t == nil || t.OriginNetworkInstance == nil {
		return ""
	}
	return *t.OriginNetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// SetDecapsulateHeader sets the value of the leaf DecapsulateHeader in the NetworkInstance_Afts_Ipv6Entry
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry) SetDecapsulateHeader(v E_AftTypes_EncapsulationHeaderType) {
	t.DecapsulateHeader = v
}

// SetEntryMetadata sets the value of the leaf EntryMetadata in the NetworkInstance_Afts_Ipv6Entry
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry) SetEntryMetadata(v Binary) {
	t.EntryMetadata = v
}

// SetNextHopGroup sets the value of the leaf NextHopGroup in the NetworkInstance_Afts_Ipv6Entry
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry) SetNextHopGroup(v uint64) {
	t.NextHopGroup = &v
}

// SetNextHopGroupNetworkInstance sets the value of the leaf NextHopGroupNetworkInstance in the NetworkInstance_Afts_Ipv6Entry
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry) SetNextHopGroupNetworkInstance(v string) {
	t.NextHopGroupNetworkInstance = &v
}

// SetOriginNetworkInstance sets the value of the leaf OriginNetworkInstance in the NetworkInstance_Afts_Ipv6Entry
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry) SetOriginNetworkInstance(v string) {
	t.OriginNetworkInstance = &v
}

// SetOriginProtocol sets the value of the leaf OriginProtocol in the NetworkInstance_Afts_Ipv6Entry
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry) SetOriginProtocol(v E_PolicyTypes_INSTALL_PROTOCOL_TYPE) {
	t.OriginProtocol = v
}

// SetPrefix sets the value of the leaf Prefix in the NetworkInstance_Afts_Ipv6Entry
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry) SetPrefix(v string) {
	t.Prefix = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv6Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv6Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv6Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv6Entry.
func (*NetworkInstance_Afts_Ipv6Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv6Entry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/counters YANG schema element.
type NetworkInstance_Afts_Ipv6Entry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv6Entry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv6Entry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_Ipv6Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_Ipv6Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// SetOctetsForwarded sets the value of the leaf OctetsForwarded in the NetworkInstance_Afts_Ipv6Entry_Counters
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) SetOctetsForwarded(v uint64) {
	t.OctetsForwarded = &v
}

// SetPacketsForwarded sets the value of the leaf PacketsForwarded in the NetworkInstance_Afts_Ipv6Entry_Counters
// struct.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) SetPacketsForwarded(v uint64) {
	t.PacketsForwarded = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv6Entry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv6Entry_Counters.
func (*NetworkInstance_Afts_Ipv6Entry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_LabelEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry YANG schema element.
type NetworkInstance_Afts_LabelEntry struct {
	Counters                    *NetworkInstance_Afts_LabelEntry_Counters                    `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                                       `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	Label                       NetworkInstance_Afts_LabelEntry_Label_Union                  `path:"state/label|label" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"label" shadow-module:"openconfig-network-instance"`
	NextHopGroup                *uint64                                                      `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                                      `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	PoppedMplsLabelStack        []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union `path:"state/popped-mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_LabelEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_LabelEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_LabelEntry) GetOrCreateCounters() *NetworkInstance_Afts_LabelEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_LabelEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_LabelEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_LabelEntry) GetCounters() *NetworkInstance_Afts_LabelEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetLabel() NetworkInstance_Afts_LabelEntry_Label_Union {
	if t == nil || t.Label == nil {
		return nil
	}
	return t.Label
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetPoppedMplsLabelStack retrieves the value of the leaf PoppedMplsLabelStack from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PoppedMplsLabelStack is set, it can
// safely use t.GetPoppedMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PoppedMplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetPoppedMplsLabelStack() []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union {
	if t == nil || t.PoppedMplsLabelStack == nil {
		return nil
	}
	return t.PoppedMplsLabelStack
}

// SetEntryMetadata sets the value of the leaf EntryMetadata in the NetworkInstance_Afts_LabelEntry
// struct.
func (t *NetworkInstance_Afts_LabelEntry) SetEntryMetadata(v Binary) {
	t.EntryMetadata = v
}

// SetLabel sets the value of the leaf Label in the NetworkInstance_Afts_LabelEntry
// struct.
func (t *NetworkInstance_Afts_LabelEntry) SetLabel(v NetworkInstance_Afts_LabelEntry_Label_Union) {
	t.Label = v
}

// SetNextHopGroup sets the value of the leaf NextHopGroup in the NetworkInstance_Afts_LabelEntry
// struct.
func (t *NetworkInstance_Afts_LabelEntry) SetNextHopGroup(v uint64) {
	t.NextHopGroup = &v
}

// SetNextHopGroupNetworkInstance sets the value of the leaf NextHopGroupNetworkInstance in the NetworkInstance_Afts_LabelEntry
// struct.
func (t *NetworkInstance_Afts_LabelEntry) SetNextHopGroupNetworkInstance(v string) {
	t.NextHopGroupNetworkInstance = &v
}

// SetPoppedMplsLabelStack sets the value of the leaf PoppedMplsLabelStack in the NetworkInstance_Afts_LabelEntry
// struct.
func (t *NetworkInstance_Afts_LabelEntry) SetPoppedMplsLabelStack(v []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union) {
	t.PoppedMplsLabelStack = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_LabelEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_LabelEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_LabelEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_LabelEntry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"label": t.Label,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_LabelEntry.
func (*NetworkInstance_Afts_LabelEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_LabelEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/counters YANG schema element.
type NetworkInstance_Afts_LabelEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_LabelEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_LabelEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_LabelEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_LabelEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// SetOctetsForwarded sets the value of the leaf OctetsForwarded in the NetworkInstance_Afts_LabelEntry_Counters
// struct.
func (t *NetworkInstance_Afts_LabelEntry_Counters) SetOctetsForwarded(v uint64) {
	t.OctetsForwarded = &v
}

// SetPacketsForwarded sets the value of the leaf PacketsForwarded in the NetworkInstance_Afts_LabelEntry_Counters
// struct.
func (t *NetworkInstance_Afts_LabelEntry_Counters) SetPacketsForwarded(v uint64) {
	t.PacketsForwarded = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_LabelEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_LabelEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_LabelEntry_Counters.
func (*NetworkInstance_Afts_LabelEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_MacEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry YANG schema element.
type NetworkInstance_Afts_MacEntry struct {
	Counters                    *NetworkInstance_Afts_MacEntry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                  `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress                  *string                                 `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
	NextHopGroup                *uint64                                 `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                 `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_MacEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_MacEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_MacEntry) GetOrCreateCounters() *NetworkInstance_Afts_MacEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_MacEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_MacEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_MacEntry) GetCounters() *NetworkInstance_Afts_MacEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// SetEntryMetadata sets the value of the leaf EntryMetadata in the NetworkInstance_Afts_MacEntry
// struct.
func (t *NetworkInstance_Afts_MacEntry) SetEntryMetadata(v Binary) {
	t.EntryMetadata = v
}

// SetMacAddress sets the value of the leaf MacAddress in the NetworkInstance_Afts_MacEntry
// struct.
func (t *NetworkInstance_Afts_MacEntry) SetMacAddress(v string) {
	t.MacAddress = &v
}

// SetNextHopGroup sets the value of the leaf NextHopGroup in the NetworkInstance_Afts_MacEntry
// struct.
func (t *NetworkInstance_Afts_MacEntry) SetNextHopGroup(v uint64) {
	t.NextHopGroup = &v
}

// SetNextHopGroupNetworkInstance sets the value of the leaf NextHopGroupNetworkInstance in the NetworkInstance_Afts_MacEntry
// struct.
func (t *NetworkInstance_Afts_MacEntry) SetNextHopGroupNetworkInstance(v string) {
	t.NextHopGroupNetworkInstance = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_MacEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_MacEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_MacEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_MacEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_MacEntry.
func (*NetworkInstance_Afts_MacEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_MacEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/counters YANG schema element.
type NetworkInstance_Afts_MacEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_MacEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_MacEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_MacEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_MacEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// SetOctetsForwarded sets the value of the leaf OctetsForwarded in the NetworkInstance_Afts_MacEntry_Counters
// struct.
func (t *NetworkInstance_Afts_MacEntry_Counters) SetOctetsForwarded(v uint64) {
	t.OctetsForwarded = &v
}

// SetPacketsForwarded sets the value of the leaf PacketsForwarded in the NetworkInstance_Afts_MacEntry_Counters
// struct.
func (t *NetworkInstance_Afts_MacEntry_Counters) SetPacketsForwarded(v uint64) {
	t.PacketsForwarded = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_MacEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_MacEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_MacEntry_Counters.
func (*NetworkInstance_Afts_MacEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop YANG schema element.
type NetworkInstance_Afts_NextHop struct {
	Counters             *NetworkInstance_Afts_NextHop_Counters                    `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader    E_AftTypes_EncapsulationHeaderType                        `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EncapHeader          map[uint8]*NetworkInstance_Afts_NextHop_EncapHeader       `path:"encap-headers/encap-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulateHeader    E_AftTypes_EncapsulationHeaderType                        `path:"state/encapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	Gre                  *NetworkInstance_Afts_NextHop_Gre                         `path:"gre" module:"openconfig-network-instance"`
	Index                *uint64                                                   `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	InterfaceRef         *NetworkInstance_Afts_NextHop_InterfaceRef                `path:"interface-ref" module:"openconfig-network-instance"`
	IpAddress            *string                                                   `path:"state/ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	IpInIp               *NetworkInstance_Afts_NextHop_IpInIp                      `path:"ip-in-ip" module:"openconfig-network-instance"`
	LspName              *string                                                   `path:"state/lsp-name" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress           *string                                                   `path:"state/mac-address" module:"openconfig-network-instance/openconfig-network-instance"`
	NetworkInstance      *string                                                   `path:"state/network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginProtocol       E_PolicyTypes_INSTALL_PROTOCOL_TYPE                       `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	PopTopLabel          *bool                                                     `path:"state/pop-top-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ProgrammedIndex      *uint64                                                   `path:"state/programmed-index" module:"openconfig-network-instance/openconfig-network-instance"`
	PushedMplsLabelStack []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union `path:"state/pushed-mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
	TunnelSrcIpAddress   *string                                                   `path:"state/tunnel-src-ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	VniLabel             *uint32                                                   `path:"state/vni-label" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop) IsYANGGoStruct() {}

// NewEncapHeader creates a new entry in the EncapHeader list of the
// NetworkInstance_Afts_NextHop struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHop) NewEncapHeader(Index uint8) (*NetworkInstance_Afts_NextHop_EncapHeader, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EncapHeader == nil {
		t.EncapHeader = make(map[uint8]*NetworkInstance_Afts_NextHop_EncapHeader)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EncapHeader[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EncapHeader", key)
	}

	t.EncapHeader[key] = &NetworkInstance_Afts_NextHop_EncapHeader{
		Index: &Index,
	}

	return t.EncapHeader[key], nil
}

// RenameEncapHeader renames an entry in the list EncapHeader within
// the NetworkInstance_Afts_NextHop struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHop) RenameEncapHeader(oldK, newK uint8) error {
	if _, ok := t.EncapHeader[newK]; ok {
		return fmt.Errorf("key %v already exists in EncapHeader", newK)
	}

	e, ok := t.EncapHeader[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EncapHeader", oldK)
	}
	e.Index = &newK

	t.EncapHeader[newK] = e
	delete(t.EncapHeader, oldK)
	return nil
}

// GetOrCreateEncapHeaderMap returns the list (map) from NetworkInstance_Afts_NextHop.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateEncapHeaderMap() map[uint8]*NetworkInstance_Afts_NextHop_EncapHeader {
	if t.EncapHeader == nil {
		t.EncapHeader = make(map[uint8]*NetworkInstance_Afts_NextHop_EncapHeader)
	}
	return t.EncapHeader
}

// GetOrCreateEncapHeader retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHop. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateEncapHeader(Index uint8) *NetworkInstance_Afts_NextHop_EncapHeader {

	key := Index

	if v, ok := t.EncapHeader[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEncapHeader(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEncapHeader got unexpected error: %v", err))
	}
	return v
}

// GetEncapHeader retrieves the value with the specified key from
// the EncapHeader map field of NetworkInstance_Afts_NextHop. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetEncapHeader(Index uint8) *NetworkInstance_Afts_NextHop_EncapHeader {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.EncapHeader[key]; ok {
		return lm
	}
	return nil
}

// DeleteEncapHeader deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHop. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHop) DeleteEncapHeader(Index uint8) {
	key := Index

	delete(t.EncapHeader, key)
}

// AppendEncapHeader appends the supplied NetworkInstance_Afts_NextHop_EncapHeader struct to the
// list EncapHeader of NetworkInstance_Afts_NextHop. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHop_EncapHeader already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHop) AppendEncapHeader(v *NetworkInstance_Afts_NextHop_EncapHeader) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EncapHeader == nil {
		t.EncapHeader = make(map[uint8]*NetworkInstance_Afts_NextHop_EncapHeader)
	}

	if _, ok := t.EncapHeader[key]; ok {
		return fmt.Errorf("duplicate key for list EncapHeader %v", key)
	}

	t.EncapHeader[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateCounters() *NetworkInstance_Afts_NextHop_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_NextHop_Counters{}
	return t.Counters
}

// GetOrCreateGre retrieves the value of the Gre field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateGre() *NetworkInstance_Afts_NextHop_Gre {
	if t.Gre != nil {
		return t.Gre
	}
	t.Gre = &NetworkInstance_Afts_NextHop_Gre{}
	return t.Gre
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Afts_NextHop_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateIpInIp retrieves the value of the IpInIp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateIpInIp() *NetworkInstance_Afts_NextHop_IpInIp {
	if t.IpInIp != nil {
		return t.IpInIp
	}
	t.IpInIp = &NetworkInstance_Afts_NextHop_IpInIp{}
	return t.IpInIp
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetCounters() *NetworkInstance_Afts_NextHop_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetGre returns the value of the Gre struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field Gre is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetGre() *NetworkInstance_Afts_NextHop_Gre {
	if t != nil && t.Gre != nil {
		return t.Gre
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetIpInIp returns the value of the IpInIp struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field IpInIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetIpInIp() *NetworkInstance_Afts_NextHop_IpInIp {
	if t != nil && t.IpInIp != nil {
		return t.IpInIp
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEncapsulateHeader retrieves the value of the leaf EncapsulateHeader from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulateHeader is set, it can
// safely use t.GetEncapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetEncapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.EncapsulateHeader == 0 {
		return 0
	}
	return t.EncapsulateHeader
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpAddress retrieves the value of the leaf IpAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetLspName retrieves the value of the leaf LspName from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspName is set, it can
// safely use t.GetLspName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetLspName() string {
	if t == nil || t.LspName == nil {
		return ""
	}
	return *t.LspName
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPopTopLabel retrieves the value of the leaf PopTopLabel from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PopTopLabel is set, it can
// safely use t.GetPopTopLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PopTopLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetPopTopLabel() bool {
	if t == nil || t.PopTopLabel == nil {
		return false
	}
	return *t.PopTopLabel
}

// GetProgrammedIndex retrieves the value of the leaf ProgrammedIndex from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProgrammedIndex is set, it can
// safely use t.GetProgrammedIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProgrammedIndex == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetProgrammedIndex() uint64 {
	if t == nil || t.ProgrammedIndex == nil {
		return 0
	}
	return *t.ProgrammedIndex
}

// GetPushedMplsLabelStack retrieves the value of the leaf PushedMplsLabelStack from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushedMplsLabelStack is set, it can
// safely use t.GetPushedMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushedMplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetPushedMplsLabelStack() []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union {
	if t == nil || t.PushedMplsLabelStack == nil {
		return nil
	}
	return t.PushedMplsLabelStack
}

// GetTunnelSrcIpAddress retrieves the value of the leaf TunnelSrcIpAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelSrcIpAddress is set, it can
// safely use t.GetTunnelSrcIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelSrcIpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetTunnelSrcIpAddress() string {
	if t == nil || t.TunnelSrcIpAddress == nil {
		return ""
	}
	return *t.TunnelSrcIpAddress
}

// GetVniLabel retrieves the value of the leaf VniLabel from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniLabel is set, it can
// safely use t.GetVniLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetVniLabel() uint32 {
	if t == nil || t.VniLabel == nil {
		return 0
	}
	return *t.VniLabel
}

// SetDecapsulateHeader sets the value of the leaf DecapsulateHeader in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetDecapsulateHeader(v E_AftTypes_EncapsulationHeaderType) {
	t.DecapsulateHeader = v
}

// SetEncapsulateHeader sets the value of the leaf EncapsulateHeader in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetEncapsulateHeader(v E_AftTypes_EncapsulationHeaderType) {
	t.EncapsulateHeader = v
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetIndex(v uint64) {
	t.Index = &v
}

// SetIpAddress sets the value of the leaf IpAddress in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetIpAddress(v string) {
	t.IpAddress = &v
}

// SetLspName sets the value of the leaf LspName in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetLspName(v string) {
	t.LspName = &v
}

// SetMacAddress sets the value of the leaf MacAddress in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetMacAddress(v string) {
	t.MacAddress = &v
}

// SetNetworkInstance sets the value of the leaf NetworkInstance in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetNetworkInstance(v string) {
	t.NetworkInstance = &v
}

// SetOriginProtocol sets the value of the leaf OriginProtocol in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetOriginProtocol(v E_PolicyTypes_INSTALL_PROTOCOL_TYPE) {
	t.OriginProtocol = v
}

// SetPopTopLabel sets the value of the leaf PopTopLabel in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetPopTopLabel(v bool) {
	t.PopTopLabel = &v
}

// SetProgrammedIndex sets the value of the leaf ProgrammedIndex in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetProgrammedIndex(v uint64) {
	t.ProgrammedIndex = &v
}

// SetPushedMplsLabelStack sets the value of the leaf PushedMplsLabelStack in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetPushedMplsLabelStack(v []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union) {
	t.PushedMplsLabelStack = v
}

// SetTunnelSrcIpAddress sets the value of the leaf TunnelSrcIpAddress in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetTunnelSrcIpAddress(v string) {
	t.TunnelSrcIpAddress = &v
}

// SetVniLabel sets the value of the leaf VniLabel in the NetworkInstance_Afts_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHop) SetVniLabel(v uint32) {
	t.VniLabel = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PopTopLabel == nil {
		var v bool = false
		t.PopTopLabel = &v
	}
	t.Counters.PopulateDefaults()
	t.Gre.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
	t.IpInIp.PopulateDefaults()
	for _, e := range t.EncapHeader {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop.
func (*NetworkInstance_Afts_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group YANG schema element.
type NetworkInstance_Afts_NextHopGroup struct {
	BackupActive       *bool                                                   `path:"state/backup-active" module:"openconfig-network-instance/openconfig-network-instance"`
	BackupNextHopGroup *uint64                                                 `path:"state/backup-next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	Color              *uint64                                                 `path:"state/color" module:"openconfig-network-instance/openconfig-network-instance"`
	Condition          map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition `path:"conditional/condition" module:"openconfig-network-instance/openconfig-network-instance"`
	Id                 *uint64                                                 `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	NextHop            map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop   `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroupName   *string                                                 `path:"state/next-hop-group-name" module:"openconfig-network-instance/openconfig-network-instance"`
	ProgrammedId       *uint64                                                 `path:"state/programmed-id" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup) IsYANGGoStruct() {}

// NewCondition creates a new entry in the Condition list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewCondition(Id uint64) (*NetworkInstance_Afts_NextHopGroup_Condition, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Condition[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Condition", key)
	}

	t.Condition[key] = &NetworkInstance_Afts_NextHopGroup_Condition{
		Id: &Id,
	}

	return t.Condition[key], nil
}

// RenameCondition renames an entry in the list Condition within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameCondition(oldK, newK uint64) error {
	if _, ok := t.Condition[newK]; ok {
		return fmt.Errorf("key %v already exists in Condition", newK)
	}

	e, ok := t.Condition[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Condition", oldK)
	}
	e.Id = &newK

	t.Condition[newK] = e
	delete(t.Condition, oldK)
	return nil
}

// GetOrCreateConditionMap returns the list (map) from NetworkInstance_Afts_NextHopGroup.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateConditionMap() map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition {
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}
	return t.Condition
}

// GetOrCreateCondition retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateCondition(Id uint64) *NetworkInstance_Afts_NextHopGroup_Condition {

	key := Id

	if v, ok := t.Condition[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCondition(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCondition got unexpected error: %v", err))
	}
	return v
}

// GetCondition retrieves the value with the specified key from
// the Condition map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetCondition(Id uint64) *NetworkInstance_Afts_NextHopGroup_Condition {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Condition[key]; ok {
		return lm
	}
	return nil
}

// DeleteCondition deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteCondition(Id uint64) {
	key := Id

	delete(t.Condition, key)
}

// AppendCondition appends the supplied NetworkInstance_Afts_NextHopGroup_Condition struct to the
// list Condition of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_Condition already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendCondition(v *NetworkInstance_Afts_NextHopGroup_Condition) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}

	if _, ok := t.Condition[key]; ok {
		return fmt.Errorf("duplicate key for list Condition %v", key)
	}

	t.Condition[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHopMap returns the list (map) from NetworkInstance_Afts_NextHopGroup.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateNextHopMap() map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop {
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}
	return t.NextHop
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendNextHop(v *NetworkInstance_Afts_NextHopGroup_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetBackupActive retrieves the value of the leaf BackupActive from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackupActive is set, it can
// safely use t.GetBackupActive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackupActive == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetBackupActive() bool {
	if t == nil || t.BackupActive == nil {
		return false
	}
	return *t.BackupActive
}

// GetBackupNextHopGroup retrieves the value of the leaf BackupNextHopGroup from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackupNextHopGroup is set, it can
// safely use t.GetBackupNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackupNextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetBackupNextHopGroup() uint64 {
	if t == nil || t.BackupNextHopGroup == nil {
		return 0
	}
	return *t.BackupNextHopGroup
}

// GetColor retrieves the value of the leaf Color from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Color is set, it can
// safely use t.GetColor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Color == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetColor() uint64 {
	if t == nil || t.Color == nil {
		return 0
	}
	return *t.Color
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetNextHopGroupName retrieves the value of the leaf NextHopGroupName from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupName is set, it can
// safely use t.GetNextHopGroupName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetNextHopGroupName() string {
	if t == nil || t.NextHopGroupName == nil {
		return ""
	}
	return *t.NextHopGroupName
}

// GetProgrammedId retrieves the value of the leaf ProgrammedId from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProgrammedId is set, it can
// safely use t.GetProgrammedId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProgrammedId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetProgrammedId() uint64 {
	if t == nil || t.ProgrammedId == nil {
		return 0
	}
	return *t.ProgrammedId
}

// SetBackupActive sets the value of the leaf BackupActive in the NetworkInstance_Afts_NextHopGroup
// struct.
func (t *NetworkInstance_Afts_NextHopGroup) SetBackupActive(v bool) {
	t.BackupActive = &v
}

// SetBackupNextHopGroup sets the value of the leaf BackupNextHopGroup in the NetworkInstance_Afts_NextHopGroup
// struct.
func (t *NetworkInstance_Afts_NextHopGroup) SetBackupNextHopGroup(v uint64) {
	t.BackupNextHopGroup = &v
}

// SetColor sets the value of the leaf Color in the NetworkInstance_Afts_NextHopGroup
// struct.
func (t *NetworkInstance_Afts_NextHopGroup) SetColor(v uint64) {
	t.Color = &v
}

// SetId sets the value of the leaf Id in the NetworkInstance_Afts_NextHopGroup
// struct.
func (t *NetworkInstance_Afts_NextHopGroup) SetId(v uint64) {
	t.Id = &v
}

// SetNextHopGroupName sets the value of the leaf NextHopGroupName in the NetworkInstance_Afts_NextHopGroup
// struct.
func (t *NetworkInstance_Afts_NextHopGroup) SetNextHopGroupName(v string) {
	t.NextHopGroupName = &v
}

// SetProgrammedId sets the value of the leaf ProgrammedId in the NetworkInstance_Afts_NextHopGroup
// struct.
func (t *NetworkInstance_Afts_NextHopGroup) SetProgrammedId(v uint64) {
	t.ProgrammedId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BackupActive == nil {
		var v bool = false
		t.BackupActive = &v
	}
	for _, e := range t.Condition {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup.
func (*NetworkInstance_Afts_NextHopGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_Condition represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition YANG schema element.
type NetworkInstance_Afts_NextHopGroup_Condition struct {
	Dscp           []uint8                                                                `path:"state/dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	Id             *uint64                                                                `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	InputInterface map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface `path:"input-interfaces/input-interface" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup   *uint64                                                                `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_Condition implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_Condition) IsYANGGoStruct() {}

// NewInputInterface creates a new entry in the InputInterface list of the
// NetworkInstance_Afts_NextHopGroup_Condition struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) NewInputInterface(Id string) (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InputInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InputInterface", key)
	}

	t.InputInterface[key] = &NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{
		Id: &Id,
	}

	return t.InputInterface[key], nil
}

// RenameInputInterface renames an entry in the list InputInterface within
// the NetworkInstance_Afts_NextHopGroup_Condition struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) RenameInputInterface(oldK, newK string) error {
	if _, ok := t.InputInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in InputInterface", newK)
	}

	e, ok := t.InputInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InputInterface", oldK)
	}
	e.Id = &newK

	t.InputInterface[newK] = e
	delete(t.InputInterface, oldK)
	return nil
}

// GetOrCreateInputInterfaceMap returns the list (map) from NetworkInstance_Afts_NextHopGroup_Condition.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetOrCreateInputInterfaceMap() map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}
	return t.InputInterface
}

// GetOrCreateInputInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup_Condition. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetOrCreateInputInterface(Id string) *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {

	key := Id

	if v, ok := t.InputInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInputInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInputInterface got unexpected error: %v", err))
	}
	return v
}

// GetInputInterface retrieves the value with the specified key from
// the InputInterface map field of NetworkInstance_Afts_NextHopGroup_Condition. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetInputInterface(Id string) *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.InputInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInputInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup_Condition. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) DeleteInputInterface(Id string) {
	key := Id

	delete(t.InputInterface, key)
}

// AppendInputInterface appends the supplied NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct to the
// list InputInterface of NetworkInstance_Afts_NextHopGroup_Condition. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_Condition_InputInterface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) AppendInputInterface(v *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}

	if _, ok := t.InputInterface[key]; ok {
		return fmt.Errorf("duplicate key for list InputInterface %v", key)
	}

	t.InputInterface[key] = v
	return nil
}

// GetDscp retrieves the value of the leaf Dscp from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetDscp() []uint8 {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// SetDscp sets the value of the leaf Dscp in the NetworkInstance_Afts_NextHopGroup_Condition
// struct.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) SetDscp(v []uint8) {
	t.Dscp = v
}

// SetId sets the value of the leaf Id in the NetworkInstance_Afts_NextHopGroup_Condition
// struct.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) SetId(v uint64) {
	t.Id = &v
}

// SetNextHopGroup sets the value of the leaf NextHopGroup in the NetworkInstance_Afts_NextHopGroup_Condition
// struct.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) SetNextHopGroup(v uint64) {
	t.NextHopGroup = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_Condition
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.InputInterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_Condition struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_Condition"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_Condition.
func (*NetworkInstance_Afts_NextHopGroup_Condition) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_Condition_InputInterface represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface YANG schema element.
type NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct {
	Id           *string `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_Condition_InputInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetId sets the value of the leaf Id in the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) SetId(v string) {
	t.Id = &v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_Condition_InputInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_Condition_InputInterface.
func (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_NextHop represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop YANG schema element.
type NetworkInstance_Afts_NextHopGroup_NextHop struct {
	Index  *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Weight *uint64 `path:"state/weight" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetWeight retrieves the value of the leaf Weight from the NetworkInstance_Afts_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) GetWeight() uint64 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Afts_NextHopGroup_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) SetIndex(v uint64) {
	t.Index = &v
}

// SetWeight sets the value of the leaf Weight in the NetworkInstance_Afts_NextHopGroup_NextHop
// struct.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) SetWeight(v uint64) {
	t.Weight = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_NextHop.
func (*NetworkInstance_Afts_NextHopGroup_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/counters YANG schema element.
type NetworkInstance_Afts_NextHop_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_NextHop_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_NextHop_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// SetOctetsForwarded sets the value of the leaf OctetsForwarded in the NetworkInstance_Afts_NextHop_Counters
// struct.
func (t *NetworkInstance_Afts_NextHop_Counters) SetOctetsForwarded(v uint64) {
	t.OctetsForwarded = &v
}

// SetPacketsForwarded sets the value of the leaf PacketsForwarded in the NetworkInstance_Afts_NextHop_Counters
// struct.
func (t *NetworkInstance_Afts_NextHop_Counters) SetPacketsForwarded(v uint64) {
	t.PacketsForwarded = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_Counters.
func (*NetworkInstance_Afts_NextHop_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_EncapHeader represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/encap-headers/encap-header YANG schema element.
type NetworkInstance_Afts_NextHop_EncapHeader struct {
	Gre   *NetworkInstance_Afts_NextHop_EncapHeader_Gre   `path:"gre" module:"openconfig-network-instance"`
	Index *uint8                                          `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Ipv4  *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4  `path:"ipv4" module:"openconfig-network-instance"`
	Ipv6  *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6  `path:"ipv6" module:"openconfig-network-instance"`
	Mpls  *NetworkInstance_Afts_NextHop_EncapHeader_Mpls  `path:"mpls" module:"openconfig-network-instance"`
	Type  E_AftTypes_EncapsulationHeaderType              `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
	UdpV4 *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4 `path:"udp-v4" module:"openconfig-network-instance"`
	UdpV6 *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6 `path:"udp-v6" module:"openconfig-network-instance"`
	Vxlan *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan `path:"vxlan" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_EncapHeader implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_EncapHeader) IsYANGGoStruct() {}

// GetOrCreateGre retrieves the value of the Gre field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetOrCreateGre() *NetworkInstance_Afts_NextHop_EncapHeader_Gre {
	if t.Gre != nil {
		return t.Gre
	}
	t.Gre = &NetworkInstance_Afts_NextHop_EncapHeader_Gre{}
	return t.Gre
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetOrCreateIpv4() *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &NetworkInstance_Afts_NextHop_EncapHeader_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetOrCreateIpv6() *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &NetworkInstance_Afts_NextHop_EncapHeader_Ipv6{}
	return t.Ipv6
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetOrCreateMpls() *NetworkInstance_Afts_NextHop_EncapHeader_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Afts_NextHop_EncapHeader_Mpls{}
	return t.Mpls
}

// GetOrCreateUdpV4 retrieves the value of the UdpV4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetOrCreateUdpV4() *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4 {
	if t.UdpV4 != nil {
		return t.UdpV4
	}
	t.UdpV4 = &NetworkInstance_Afts_NextHop_EncapHeader_UdpV4{}
	return t.UdpV4
}

// GetOrCreateUdpV6 retrieves the value of the UdpV6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetOrCreateUdpV6() *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6 {
	if t.UdpV6 != nil {
		return t.UdpV6
	}
	t.UdpV6 = &NetworkInstance_Afts_NextHop_EncapHeader_UdpV6{}
	return t.UdpV6
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetOrCreateVxlan() *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_Afts_NextHop_EncapHeader_Vxlan{}
	return t.Vxlan
}

// GetGre returns the value of the Gre struct pointer
// from NetworkInstance_Afts_NextHop_EncapHeader. If the receiver or the field Gre is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetGre() *NetworkInstance_Afts_NextHop_EncapHeader_Gre {
	if t != nil && t.Gre != nil {
		return t.Gre
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from NetworkInstance_Afts_NextHop_EncapHeader. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetIpv4() *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from NetworkInstance_Afts_NextHop_EncapHeader. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetIpv6() *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Afts_NextHop_EncapHeader. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetMpls() *NetworkInstance_Afts_NextHop_EncapHeader_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetUdpV4 returns the value of the UdpV4 struct pointer
// from NetworkInstance_Afts_NextHop_EncapHeader. If the receiver or the field UdpV4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetUdpV4() *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4 {
	if t != nil && t.UdpV4 != nil {
		return t.UdpV4
	}
	return nil
}

// GetUdpV6 returns the value of the UdpV6 struct pointer
// from NetworkInstance_Afts_NextHop_EncapHeader. If the receiver or the field UdpV6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetUdpV6() *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6 {
	if t != nil && t.UdpV6 != nil {
		return t.UdpV6
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_Afts_NextHop_EncapHeader. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetVxlan() *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHop_EncapHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Afts_NextHop_EncapHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) GetType() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Afts_NextHop_EncapHeader
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) SetIndex(v uint8) {
	t.Index = &v
}

// SetType sets the value of the leaf Type in the NetworkInstance_Afts_NextHop_EncapHeader
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) SetType(v E_AftTypes_EncapsulationHeaderType) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_EncapHeader
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Gre.PopulateDefaults()
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
	t.Mpls.PopulateDefaults()
	t.UdpV4.PopulateDefaults()
	t.UdpV6.PopulateDefaults()
	t.Vxlan.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHop_EncapHeader struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_EncapHeader"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_EncapHeader) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_EncapHeader.
func (*NetworkInstance_Afts_NextHop_EncapHeader) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_EncapHeader_Gre represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/encap-headers/encap-header/gre YANG schema element.
type NetworkInstance_Afts_NextHop_EncapHeader_Gre struct {
	DstIp *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	Ttl   *uint8  `path:"state/ttl" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_EncapHeader_Gre implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Gre) IsYANGGoStruct() {}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_EncapHeader_Gre
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_EncapHeader_Gre
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// GetTtl retrieves the value of the leaf Ttl from the NetworkInstance_Afts_NextHop_EncapHeader_Gre
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ttl is set, it can
// safely use t.GetTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ttl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) GetTtl() uint8 {
	if t == nil || t.Ttl == nil {
		return 0
	}
	return *t.Ttl
}

// SetDstIp sets the value of the leaf DstIp in the NetworkInstance_Afts_NextHop_EncapHeader_Gre
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) SetDstIp(v string) {
	t.DstIp = &v
}

// SetSrcIp sets the value of the leaf SrcIp in the NetworkInstance_Afts_NextHop_EncapHeader_Gre
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) SetSrcIp(v string) {
	t.SrcIp = &v
}

// SetTtl sets the value of the leaf Ttl in the NetworkInstance_Afts_NextHop_EncapHeader_Gre
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) SetTtl(v uint8) {
	t.Ttl = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_EncapHeader_Gre
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_EncapHeader_Gre"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Gre) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_EncapHeader_Gre.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Gre) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_EncapHeader_Ipv4 represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/encap-headers/encap-header/ipv4 YANG schema element.
type NetworkInstance_Afts_NextHop_EncapHeader_Ipv4 struct {
	DstIp *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_EncapHeader_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) IsYANGGoStruct() {}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_EncapHeader_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_EncapHeader_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// SetDstIp sets the value of the leaf DstIp in the NetworkInstance_Afts_NextHop_EncapHeader_Ipv4
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) SetDstIp(v string) {
	t.DstIp = &v
}

// SetSrcIp sets the value of the leaf SrcIp in the NetworkInstance_Afts_NextHop_EncapHeader_Ipv4
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) SetSrcIp(v string) {
	t.SrcIp = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_EncapHeader_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_EncapHeader_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_EncapHeader_Ipv4.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Ipv4) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_EncapHeader_Ipv6 represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/encap-headers/encap-header/ipv6 YANG schema element.
type NetworkInstance_Afts_NextHop_EncapHeader_Ipv6 struct {
	DstIp *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_EncapHeader_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) IsYANGGoStruct() {}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_EncapHeader_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_EncapHeader_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// SetDstIp sets the value of the leaf DstIp in the NetworkInstance_Afts_NextHop_EncapHeader_Ipv6
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) SetDstIp(v string) {
	t.DstIp = &v
}

// SetSrcIp sets the value of the leaf SrcIp in the NetworkInstance_Afts_NextHop_EncapHeader_Ipv6
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) SetSrcIp(v string) {
	t.SrcIp = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_EncapHeader_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_EncapHeader_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_EncapHeader_Ipv6.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Ipv6) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_EncapHeader_Mpls represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/encap-headers/encap-header/mpls YANG schema element.
type NetworkInstance_Afts_NextHop_EncapHeader_Mpls struct {
	MplsLabelStack []NetworkInstance_Afts_NextHop_EncapHeader_Mpls_MplsLabelStack_Union `path:"state/mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
	TrafficClass   *uint8                                                               `path:"state/traffic-class" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_EncapHeader_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Mpls) IsYANGGoStruct() {}

// GetMplsLabelStack retrieves the value of the leaf MplsLabelStack from the NetworkInstance_Afts_NextHop_EncapHeader_Mpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabelStack is set, it can
// safely use t.GetMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Mpls) GetMplsLabelStack() []NetworkInstance_Afts_NextHop_EncapHeader_Mpls_MplsLabelStack_Union {
	if t == nil || t.MplsLabelStack == nil {
		return nil
	}
	return t.MplsLabelStack
}

// GetTrafficClass retrieves the value of the leaf TrafficClass from the NetworkInstance_Afts_NextHop_EncapHeader_Mpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficClass is set, it can
// safely use t.GetTrafficClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficClass == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Mpls) GetTrafficClass() uint8 {
	if t == nil || t.TrafficClass == nil {
		return 0
	}
	return *t.TrafficClass
}

// SetMplsLabelStack sets the value of the leaf MplsLabelStack in the NetworkInstance_Afts_NextHop_EncapHeader_Mpls
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Mpls) SetMplsLabelStack(v []NetworkInstance_Afts_NextHop_EncapHeader_Mpls_MplsLabelStack_Union) {
	t.MplsLabelStack = v
}

// SetTrafficClass sets the value of the leaf TrafficClass in the NetworkInstance_Afts_NextHop_EncapHeader_Mpls
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Mpls) SetTrafficClass(v uint8) {
	t.TrafficClass = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_EncapHeader_Mpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Mpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Mpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_EncapHeader_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Mpls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_EncapHeader_Mpls.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Mpls) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_EncapHeader_UdpV4 represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/encap-headers/encap-header/udp-v4 YANG schema element.
type NetworkInstance_Afts_NextHop_EncapHeader_UdpV4 struct {
	Dscp       *uint8  `path:"state/dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	DstIp      *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	DstUdpPort *uint16 `path:"state/dst-udp-port" module:"openconfig-network-instance/openconfig-network-instance"`
	IpTtl      *uint8  `path:"state/ip-ttl" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp      *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcUdpPort *uint16 `path:"state/src-udp-port" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_EncapHeader_UdpV4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) GetDscp() uint8 {
	if t == nil || t.Dscp == nil {
		return 0
	}
	return *t.Dscp
}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetDstUdpPort retrieves the value of the leaf DstUdpPort from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstUdpPort is set, it can
// safely use t.GetDstUdpPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstUdpPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) GetDstUdpPort() uint16 {
	if t == nil || t.DstUdpPort == nil {
		return 0
	}
	return *t.DstUdpPort
}

// GetIpTtl retrieves the value of the leaf IpTtl from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpTtl is set, it can
// safely use t.GetIpTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpTtl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) GetIpTtl() uint8 {
	if t == nil || t.IpTtl == nil {
		return 0
	}
	return *t.IpTtl
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// GetSrcUdpPort retrieves the value of the leaf SrcUdpPort from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcUdpPort is set, it can
// safely use t.GetSrcUdpPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcUdpPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) GetSrcUdpPort() uint16 {
	if t == nil || t.SrcUdpPort == nil {
		return 0
	}
	return *t.SrcUdpPort
}

// SetDscp sets the value of the leaf Dscp in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) SetDscp(v uint8) {
	t.Dscp = &v
}

// SetDstIp sets the value of the leaf DstIp in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) SetDstIp(v string) {
	t.DstIp = &v
}

// SetDstUdpPort sets the value of the leaf DstUdpPort in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) SetDstUdpPort(v uint16) {
	t.DstUdpPort = &v
}

// SetIpTtl sets the value of the leaf IpTtl in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) SetIpTtl(v uint8) {
	t.IpTtl = &v
}

// SetSrcIp sets the value of the leaf SrcIp in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) SetSrcIp(v string) {
	t.SrcIp = &v
}

// SetSrcUdpPort sets the value of the leaf SrcUdpPort in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) SetSrcUdpPort(v uint16) {
	t.SrcUdpPort = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_EncapHeader_UdpV4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_EncapHeader_UdpV4.
func (*NetworkInstance_Afts_NextHop_EncapHeader_UdpV4) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_EncapHeader_UdpV6 represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/encap-headers/encap-header/udp-v6 YANG schema element.
type NetworkInstance_Afts_NextHop_EncapHeader_UdpV6 struct {
	Dscp       *uint8  `path:"state/dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	DstIp      *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	DstUdpPort *uint16 `path:"state/dst-udp-port" module:"openconfig-network-instance/openconfig-network-instance"`
	IpTtl      *uint8  `path:"state/ip-ttl" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp      *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcUdpPort *uint16 `path:"state/src-udp-port" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_EncapHeader_UdpV6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) GetDscp() uint8 {
	if t == nil || t.Dscp == nil {
		return 0
	}
	return *t.Dscp
}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetDstUdpPort retrieves the value of the leaf DstUdpPort from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstUdpPort is set, it can
// safely use t.GetDstUdpPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstUdpPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) GetDstUdpPort() uint16 {
	if t == nil || t.DstUdpPort == nil {
		return 0
	}
	return *t.DstUdpPort
}

// GetIpTtl retrieves the value of the leaf IpTtl from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpTtl is set, it can
// safely use t.GetIpTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpTtl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) GetIpTtl() uint8 {
	if t == nil || t.IpTtl == nil {
		return 0
	}
	return *t.IpTtl
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// GetSrcUdpPort retrieves the value of the leaf SrcUdpPort from the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcUdpPort is set, it can
// safely use t.GetSrcUdpPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcUdpPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) GetSrcUdpPort() uint16 {
	if t == nil || t.SrcUdpPort == nil {
		return 0
	}
	return *t.SrcUdpPort
}

// SetDscp sets the value of the leaf Dscp in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) SetDscp(v uint8) {
	t.Dscp = &v
}

// SetDstIp sets the value of the leaf DstIp in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) SetDstIp(v string) {
	t.DstIp = &v
}

// SetDstUdpPort sets the value of the leaf DstUdpPort in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) SetDstUdpPort(v uint16) {
	t.DstUdpPort = &v
}

// SetIpTtl sets the value of the leaf IpTtl in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) SetIpTtl(v uint8) {
	t.IpTtl = &v
}

// SetSrcIp sets the value of the leaf SrcIp in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) SetSrcIp(v string) {
	t.SrcIp = &v
}

// SetSrcUdpPort sets the value of the leaf SrcUdpPort in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) SetSrcUdpPort(v uint16) {
	t.SrcUdpPort = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_EncapHeader_UdpV6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_EncapHeader_UdpV6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_EncapHeader_UdpV6.
func (*NetworkInstance_Afts_NextHop_EncapHeader_UdpV6) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_EncapHeader_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/encap-headers/encap-header/vxlan YANG schema element.
type NetworkInstance_Afts_NextHop_EncapHeader_Vxlan struct {
	TunnelSrcIpAddress *string `path:"state/tunnel-src-ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	VniLabel           *uint32 `path:"state/vni-label" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_EncapHeader_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) IsYANGGoStruct() {}

// GetTunnelSrcIpAddress retrieves the value of the leaf TunnelSrcIpAddress from the NetworkInstance_Afts_NextHop_EncapHeader_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelSrcIpAddress is set, it can
// safely use t.GetTunnelSrcIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelSrcIpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) GetTunnelSrcIpAddress() string {
	if t == nil || t.TunnelSrcIpAddress == nil {
		return ""
	}
	return *t.TunnelSrcIpAddress
}

// GetVniLabel retrieves the value of the leaf VniLabel from the NetworkInstance_Afts_NextHop_EncapHeader_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniLabel is set, it can
// safely use t.GetVniLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) GetVniLabel() uint32 {
	if t == nil || t.VniLabel == nil {
		return 0
	}
	return *t.VniLabel
}

// SetTunnelSrcIpAddress sets the value of the leaf TunnelSrcIpAddress in the NetworkInstance_Afts_NextHop_EncapHeader_Vxlan
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) SetTunnelSrcIpAddress(v string) {
	t.TunnelSrcIpAddress = &v
}

// SetVniLabel sets the value of the leaf VniLabel in the NetworkInstance_Afts_NextHop_EncapHeader_Vxlan
// struct.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) SetVniLabel(v uint32) {
	t.VniLabel = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_EncapHeader_Vxlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_EncapHeader_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_EncapHeader_Vxlan.
func (*NetworkInstance_Afts_NextHop_EncapHeader_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_Gre represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/gre YANG schema element.
type NetworkInstance_Afts_NextHop_Gre struct {
	DstIp *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	Ttl   *uint8  `path:"state/ttl" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_Gre implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_Gre) IsYANGGoStruct() {}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_Gre
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Gre) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_Gre
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Gre) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// GetTtl retrieves the value of the leaf Ttl from the NetworkInstance_Afts_NextHop_Gre
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ttl is set, it can
// safely use t.GetTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ttl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Gre) GetTtl() uint8 {
	if t == nil || t.Ttl == nil {
		return 0
	}
	return *t.Ttl
}

// SetDstIp sets the value of the leaf DstIp in the NetworkInstance_Afts_NextHop_Gre
// struct.
func (t *NetworkInstance_Afts_NextHop_Gre) SetDstIp(v string) {
	t.DstIp = &v
}

// SetSrcIp sets the value of the leaf SrcIp in the NetworkInstance_Afts_NextHop_Gre
// struct.
func (t *NetworkInstance_Afts_NextHop_Gre) SetSrcIp(v string) {
	t.SrcIp = &v
}

// SetTtl sets the value of the leaf Ttl in the NetworkInstance_Afts_NextHop_Gre
// struct.
func (t *NetworkInstance_Afts_NextHop_Gre) SetTtl(v uint8) {
	t.Ttl = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_Gre
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_Gre) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Gre) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_Gre"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Gre) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_Gre) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_Gre.
func (*NetworkInstance_Afts_NextHop_Gre) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref YANG schema element.
type NetworkInstance_Afts_NextHop_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Afts_NextHop_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Afts_NextHop_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Afts_NextHop_InterfaceRef
// struct.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Afts_NextHop_InterfaceRef
// struct.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_InterfaceRef.
func (*NetworkInstance_Afts_NextHop_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_IpInIp represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip YANG schema element.
type NetworkInstance_Afts_NextHop_IpInIp struct {
	DstIp *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_IpInIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_IpInIp) IsYANGGoStruct() {}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_IpInIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_IpInIp) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_IpInIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_IpInIp) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// SetDstIp sets the value of the leaf DstIp in the NetworkInstance_Afts_NextHop_IpInIp
// struct.
func (t *NetworkInstance_Afts_NextHop_IpInIp) SetDstIp(v string) {
	t.DstIp = &v
}

// SetSrcIp sets the value of the leaf SrcIp in the NetworkInstance_Afts_NextHop_IpInIp
// struct.
func (t *NetworkInstance_Afts_NextHop_IpInIp) SetSrcIp(v string) {
	t.SrcIp = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_IpInIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_IpInIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_IpInIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_IpInIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_IpInIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_IpInIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_IpInIp.
func (*NetworkInstance_Afts_NextHop_IpInIp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_PolicyForwardingEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry YANG schema element.
type NetworkInstance_Afts_PolicyForwardingEntry struct {
	Counters                    *NetworkInstance_Afts_PolicyForwardingEntry_Counters        `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                                      `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	Index                       *uint64                                                     `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	IpDscp                      *uint8                                                      `path:"state/ip-dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	IpPrefix                    *string                                                     `path:"state/ip-prefix" module:"openconfig-network-instance/openconfig-network-instance"`
	IpProtocol                  NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union `path:"state/ip-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	L4DstPort                   *uint16                                                     `path:"state/l4-dst-port" module:"openconfig-network-instance/openconfig-network-instance"`
	L4SrcPort                   *uint16                                                     `path:"state/l4-src-port" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress                  *string                                                     `path:"state/mac-address" module:"openconfig-network-instance/openconfig-network-instance"`
	MplsLabel                   NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union  `path:"state/mpls-label" module:"openconfig-network-instance/openconfig-network-instance"`
	MplsTc                      *uint8                                                      `path:"state/mpls-tc" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup                *uint64                                                     `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                                     `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_PolicyForwardingEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_PolicyForwardingEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetOrCreateCounters() *NetworkInstance_Afts_PolicyForwardingEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_PolicyForwardingEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_PolicyForwardingEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetCounters() *NetworkInstance_Afts_PolicyForwardingEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpDscp retrieves the value of the leaf IpDscp from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpDscp is set, it can
// safely use t.GetIpDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpDscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpDscp() uint8 {
	if t == nil || t.IpDscp == nil {
		return 0
	}
	return *t.IpDscp
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetIpProtocol retrieves the value of the leaf IpProtocol from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpProtocol is set, it can
// safely use t.GetIpProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpProtocol() NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	if t == nil || t.IpProtocol == nil {
		return nil
	}
	return t.IpProtocol
}

// GetL4DstPort retrieves the value of the leaf L4DstPort from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L4DstPort is set, it can
// safely use t.GetL4DstPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L4DstPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetL4DstPort() uint16 {
	if t == nil || t.L4DstPort == nil {
		return 0
	}
	return *t.L4DstPort
}

// GetL4SrcPort retrieves the value of the leaf L4SrcPort from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L4SrcPort is set, it can
// safely use t.GetL4SrcPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L4SrcPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetL4SrcPort() uint16 {
	if t == nil || t.L4SrcPort == nil {
		return 0
	}
	return *t.L4SrcPort
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetMplsLabel retrieves the value of the leaf MplsLabel from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabel is set, it can
// safely use t.GetMplsLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMplsLabel() NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	if t == nil || t.MplsLabel == nil {
		return nil
	}
	return t.MplsLabel
}

// GetMplsTc retrieves the value of the leaf MplsTc from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsTc is set, it can
// safely use t.GetMplsTc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsTc == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMplsTc() uint8 {
	if t == nil || t.MplsTc == nil {
		return 0
	}
	return *t.MplsTc
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// SetEntryMetadata sets the value of the leaf EntryMetadata in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetEntryMetadata(v Binary) {
	t.EntryMetadata = v
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetIndex(v uint64) {
	t.Index = &v
}

// SetIpDscp sets the value of the leaf IpDscp in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetIpDscp(v uint8) {
	t.IpDscp = &v
}

// SetIpPrefix sets the value of the leaf IpPrefix in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetIpPrefix(v string) {
	t.IpPrefix = &v
}

// SetIpProtocol sets the value of the leaf IpProtocol in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetIpProtocol(v NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union) {
	t.IpProtocol = v
}

// SetL4DstPort sets the value of the leaf L4DstPort in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetL4DstPort(v uint16) {
	t.L4DstPort = &v
}

// SetL4SrcPort sets the value of the leaf L4SrcPort in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetL4SrcPort(v uint16) {
	t.L4SrcPort = &v
}

// SetMacAddress sets the value of the leaf MacAddress in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetMacAddress(v string) {
	t.MacAddress = &v
}

// SetMplsLabel sets the value of the leaf MplsLabel in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetMplsLabel(v NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union) {
	t.MplsLabel = v
}

// SetMplsTc sets the value of the leaf MplsTc in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetMplsTc(v uint8) {
	t.MplsTc = &v
}

// SetNextHopGroup sets the value of the leaf NextHopGroup in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetNextHopGroup(v uint64) {
	t.NextHopGroup = &v
}

// SetNextHopGroupNetworkInstance sets the value of the leaf NextHopGroupNetworkInstance in the NetworkInstance_Afts_PolicyForwardingEntry
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) SetNextHopGroupNetworkInstance(v string) {
	t.NextHopGroupNetworkInstance = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_PolicyForwardingEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_PolicyForwardingEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_PolicyForwardingEntry.
func (*NetworkInstance_Afts_PolicyForwardingEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_PolicyForwardingEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/counters YANG schema element.
type NetworkInstance_Afts_PolicyForwardingEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_PolicyForwardingEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_PolicyForwardingEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// SetOctetsForwarded sets the value of the leaf OctetsForwarded in the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) SetOctetsForwarded(v uint64) {
	t.OctetsForwarded = &v
}

// SetPacketsForwarded sets the value of the leaf PacketsForwarded in the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) SetPacketsForwarded(v uint64) {
	t.PacketsForwarded = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_PolicyForwardingEntry_Counters.
func (*NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_StateSynced represents the /openconfig-network-instance/network-instances/network-instance/afts/state-synced YANG schema element.
type NetworkInstance_Afts_StateSynced struct {
	Ipv4Unicast *bool `path:"state/ipv4-unicast" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv6Unicast *bool `path:"state/ipv6-unicast" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_StateSynced implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_StateSynced) IsYANGGoStruct() {}

// GetIpv4Unicast retrieves the value of the leaf Ipv4Unicast from the NetworkInstance_Afts_StateSynced
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Unicast is set, it can
// safely use t.GetIpv4Unicast() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Unicast == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_StateSynced) GetIpv4Unicast() bool {
	if t == nil || t.Ipv4Unicast == nil {
		return false
	}
	return *t.Ipv4Unicast
}

// GetIpv6Unicast retrieves the value of the leaf Ipv6Unicast from the NetworkInstance_Afts_StateSynced
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Unicast is set, it can
// safely use t.GetIpv6Unicast() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Unicast == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_StateSynced) GetIpv6Unicast() bool {
	if t == nil || t.Ipv6Unicast == nil {
		return false
	}
	return *t.Ipv6Unicast
}

// SetIpv4Unicast sets the value of the leaf Ipv4Unicast in the NetworkInstance_Afts_StateSynced
// struct.
func (t *NetworkInstance_Afts_StateSynced) SetIpv4Unicast(v bool) {
	t.Ipv4Unicast = &v
}

// SetIpv6Unicast sets the value of the leaf Ipv6Unicast in the NetworkInstance_Afts_StateSynced
// struct.
func (t *NetworkInstance_Afts_StateSynced) SetIpv6Unicast(v bool) {
	t.Ipv6Unicast = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_StateSynced
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_StateSynced) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Ipv4Unicast == nil {
		var v bool = false
		t.Ipv4Unicast = &v
	}
	if t.Ipv6Unicast == nil {
		var v bool = false
		t.Ipv6Unicast = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_StateSynced) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_StateSynced"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_StateSynced) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_StateSynced) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_StateSynced.
func (*NetworkInstance_Afts_StateSynced) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point YANG schema element.
type NetworkInstance_ConnectionPoint struct {
	ConnectionPointId *string                                              `path:"state/connection-point-id|connection-point-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/connection-point-id|connection-point-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Endpoint          map[string]*NetworkInstance_ConnectionPoint_Endpoint `path:"endpoints/endpoint" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint) IsYANGGoStruct() {}

// NewEndpoint creates a new entry in the Endpoint list of the
// NetworkInstance_ConnectionPoint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint) NewEndpoint(EndpointId string) (*NetworkInstance_ConnectionPoint_Endpoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	key := EndpointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Endpoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Endpoint", key)
	}

	t.Endpoint[key] = &NetworkInstance_ConnectionPoint_Endpoint{
		EndpointId: &EndpointId,
	}

	return t.Endpoint[key], nil
}

// RenameEndpoint renames an entry in the list Endpoint within
// the NetworkInstance_ConnectionPoint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint) RenameEndpoint(oldK, newK string) error {
	if _, ok := t.Endpoint[newK]; ok {
		return fmt.Errorf("key %v already exists in Endpoint", newK)
	}

	e, ok := t.Endpoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Endpoint", oldK)
	}
	e.EndpointId = &newK

	t.Endpoint[newK] = e
	delete(t.Endpoint, oldK)
	return nil
}

// GetOrCreateEndpointMap returns the list (map) from NetworkInstance_ConnectionPoint.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_ConnectionPoint) GetOrCreateEndpointMap() map[string]*NetworkInstance_ConnectionPoint_Endpoint {
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}
	return t.Endpoint
}

// GetOrCreateEndpoint retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint) GetOrCreateEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	key := EndpointId

	if v, ok := t.Endpoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpoint(EndpointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpoint got unexpected error: %v", err))
	}
	return v
}

// GetEndpoint retrieves the value with the specified key from
// the Endpoint map field of NetworkInstance_ConnectionPoint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint) GetEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	if t == nil {
		return nil
	}

	key := EndpointId

	if lm, ok := t.Endpoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpoint deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint) DeleteEndpoint(EndpointId string) {
	key := EndpointId

	delete(t.Endpoint, key)
}

// AppendEndpoint appends the supplied NetworkInstance_ConnectionPoint_Endpoint struct to the
// list Endpoint of NetworkInstance_ConnectionPoint. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint) AppendEndpoint(v *NetworkInstance_ConnectionPoint_Endpoint) error {
	if v.EndpointId == nil {
		return fmt.Errorf("invalid nil key received for EndpointId")
	}

	key := *v.EndpointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	if _, ok := t.Endpoint[key]; ok {
		return fmt.Errorf("duplicate key for list Endpoint %v", key)
	}

	t.Endpoint[key] = v
	return nil
}

// GetConnectionPointId retrieves the value of the leaf ConnectionPointId from the NetworkInstance_ConnectionPoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConnectionPointId is set, it can
// safely use t.GetConnectionPointId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConnectionPointId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint) GetConnectionPointId() string {
	if t == nil || t.ConnectionPointId == nil {
		return ""
	}
	return *t.ConnectionPointId
}

// SetConnectionPointId sets the value of the leaf ConnectionPointId in the NetworkInstance_ConnectionPoint
// struct.
func (t *NetworkInstance_ConnectionPoint) SetConnectionPointId(v string) {
	t.ConnectionPointId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Endpoint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConnectionPointId == nil {
		return nil, fmt.Errorf("nil value for key ConnectionPointId")
	}

	return map[string]interface{}{
		"connection-point-id": *t.ConnectionPointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint.
func (*NetworkInstance_ConnectionPoint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint struct {
	Active     *bool                                            `path:"state/active" module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointId *string                                          `path:"state/endpoint-id|endpoint-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/endpoint-id|endpoint-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Local      *NetworkInstance_ConnectionPoint_Endpoint_Local  `path:"local" module:"openconfig-network-instance"`
	Precedence *uint16                                          `path:"state/precedence" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/precedence" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Remote     *NetworkInstance_ConnectionPoint_Endpoint_Remote `path:"remote" module:"openconfig-network-instance"`
	Type       E_NetworkInstanceTypes_ENDPOINT_TYPE             `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vxlan      *NetworkInstance_ConnectionPoint_Endpoint_Vxlan  `path:"vxlan" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint) IsYANGGoStruct() {}

// GetOrCreateLocal retrieves the value of the Local field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t.Local != nil {
		return t.Local
	}
	t.Local = &NetworkInstance_ConnectionPoint_Endpoint_Local{}
	return t.Local
}

// GetOrCreateRemote retrieves the value of the Remote field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t.Remote != nil {
		return t.Remote
	}
	t.Remote = &NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	return t.Remote
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateVxlan() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	return t.Vxlan
}

// GetLocal returns the value of the Local struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Local is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t != nil && t.Local != nil {
		return t.Local
	}
	return nil
}

// GetRemote returns the value of the Remote struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Remote is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t != nil && t.Remote != nil {
		return t.Remote
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetVxlan() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetActive retrieves the value of the leaf Active from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Active is set, it can
// safely use t.GetActive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Active == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetActive() bool {
	if t == nil || t.Active == nil {
		return false
	}
	return *t.Active
}

// GetEndpointId retrieves the value of the leaf EndpointId from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndpointId is set, it can
// safely use t.GetEndpointId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndpointId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetEndpointId() string {
	if t == nil || t.EndpointId == nil {
		return ""
	}
	return *t.EndpointId
}

// GetPrecedence retrieves the value of the leaf Precedence from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetPrecedence() uint16 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetType() E_NetworkInstanceTypes_ENDPOINT_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetActive sets the value of the leaf Active in the NetworkInstance_ConnectionPoint_Endpoint
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint) SetActive(v bool) {
	t.Active = &v
}

// SetEndpointId sets the value of the leaf EndpointId in the NetworkInstance_ConnectionPoint_Endpoint
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint) SetEndpointId(v string) {
	t.EndpointId = &v
}

// SetPrecedence sets the value of the leaf Precedence in the NetworkInstance_ConnectionPoint_Endpoint
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint) SetPrecedence(v uint16) {
	t.Precedence = &v
}

// SetType sets the value of the leaf Type in the NetworkInstance_ConnectionPoint_Endpoint
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint) SetType(v E_NetworkInstanceTypes_ENDPOINT_TYPE) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Local.PopulateDefaults()
	t.Remote.PopulateDefaults()
	t.Vxlan.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.EndpointId == nil {
		return nil, fmt.Errorf("nil value for key EndpointId")
	}

	return map[string]interface{}{
		"endpoint-id": *t.EndpointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint.
func (*NetworkInstance_ConnectionPoint_Endpoint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Local represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Local struct {
	Interface            *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteId               *uint16 `path:"state/site-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/site-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteLabelBlockOffset *uint16 `path:"state/site-label-block-offset" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/site-label-block-offset" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteLabelBlockSize   *uint16 `path:"state/site-label-block-size" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/site-label-block-size" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface         *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Local implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Local) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSiteId retrieves the value of the leaf SiteId from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteId is set, it can
// safely use t.GetSiteId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteId() uint16 {
	if t == nil || t.SiteId == nil {
		return 0
	}
	return *t.SiteId
}

// GetSiteLabelBlockOffset retrieves the value of the leaf SiteLabelBlockOffset from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteLabelBlockOffset is set, it can
// safely use t.GetSiteLabelBlockOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteLabelBlockOffset == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteLabelBlockOffset() uint16 {
	if t == nil || t.SiteLabelBlockOffset == nil {
		return 0
	}
	return *t.SiteLabelBlockOffset
}

// GetSiteLabelBlockSize retrieves the value of the leaf SiteLabelBlockSize from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteLabelBlockSize is set, it can
// safely use t.GetSiteLabelBlockSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteLabelBlockSize == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteLabelBlockSize() uint16 {
	if t == nil || t.SiteLabelBlockSize == nil {
		return 0
	}
	return *t.SiteLabelBlockSize
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) SetInterface(v string) {
	t.Interface = &v
}

// SetSiteId sets the value of the leaf SiteId in the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) SetSiteId(v uint16) {
	t.SiteId = &v
}

// SetSiteLabelBlockOffset sets the value of the leaf SiteLabelBlockOffset in the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) SetSiteLabelBlockOffset(v uint16) {
	t.SiteLabelBlockOffset = &v
}

// SetSiteLabelBlockSize sets the value of the leaf SiteLabelBlockSize in the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) SetSiteLabelBlockSize(v uint16) {
	t.SiteLabelBlockSize = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Local
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Local"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Local.
func (*NetworkInstance_ConnectionPoint_Endpoint_Local) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Remote represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Remote struct {
	RemoteSystem             *string `path:"state/remote-system" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/remote-system" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteId                   *uint16 `path:"state/site-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/site-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	VirtualCircuitIdentifier *uint32 `path:"state/virtual-circuit-identifier" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/virtual-circuit-identifier" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Remote implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Remote) IsYANGGoStruct() {}

// GetRemoteSystem retrieves the value of the leaf RemoteSystem from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteSystem is set, it can
// safely use t.GetRemoteSystem() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteSystem == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetRemoteSystem() string {
	if t == nil || t.RemoteSystem == nil {
		return ""
	}
	return *t.RemoteSystem
}

// GetSiteId retrieves the value of the leaf SiteId from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteId is set, it can
// safely use t.GetSiteId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetSiteId() uint16 {
	if t == nil || t.SiteId == nil {
		return 0
	}
	return *t.SiteId
}

// GetVirtualCircuitIdentifier retrieves the value of the leaf VirtualCircuitIdentifier from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualCircuitIdentifier is set, it can
// safely use t.GetVirtualCircuitIdentifier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualCircuitIdentifier == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetVirtualCircuitIdentifier() uint32 {
	if t == nil || t.VirtualCircuitIdentifier == nil {
		return 0
	}
	return *t.VirtualCircuitIdentifier
}

// SetRemoteSystem sets the value of the leaf RemoteSystem in the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) SetRemoteSystem(v string) {
	t.RemoteSystem = &v
}

// SetSiteId sets the value of the leaf SiteId in the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) SetSiteId(v uint16) {
	t.SiteId = &v
}

// SetVirtualCircuitIdentifier sets the value of the leaf VirtualCircuitIdentifier in the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) SetVirtualCircuitIdentifier(v uint32) {
	t.VirtualCircuitIdentifier = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Remote
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Remote"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Remote.
func (*NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct {
	Description      *string                                                                     `path:"state/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled          *bool                                                                       `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointPeer     map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer     `path:"endpoint-peers/endpoint-peer" module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointVni      map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni      `path:"endpoint-vnis/endpoint-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	LocalEndpointVni map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni `path:"local-endpoint-vnis/local-endpoint-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	SourceInterface  *string                                                                     `path:"state/source-interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source-interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan) IsYANGGoStruct() {}

// NewEndpointPeer creates a new entry in the EndpointPeer list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewEndpointPeer(PeerAddress string) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}

	key := PeerAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EndpointPeer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EndpointPeer", key)
	}

	t.EndpointPeer[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer{
		PeerAddress: &PeerAddress,
	}

	return t.EndpointPeer[key], nil
}

// RenameEndpointPeer renames an entry in the list EndpointPeer within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameEndpointPeer(oldK, newK string) error {
	if _, ok := t.EndpointPeer[newK]; ok {
		return fmt.Errorf("key %v already exists in EndpointPeer", newK)
	}

	e, ok := t.EndpointPeer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EndpointPeer", oldK)
	}
	e.PeerAddress = &newK

	t.EndpointPeer[newK] = e
	delete(t.EndpointPeer, oldK)
	return nil
}

// GetOrCreateEndpointPeerMap returns the list (map) from NetworkInstance_ConnectionPoint_Endpoint_Vxlan.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointPeerMap() map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}
	return t.EndpointPeer
}

// GetOrCreateEndpointPeer retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointPeer(PeerAddress string) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {

	key := PeerAddress

	if v, ok := t.EndpointPeer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpointPeer(PeerAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpointPeer got unexpected error: %v", err))
	}
	return v
}

// GetEndpointPeer retrieves the value with the specified key from
// the EndpointPeer map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEndpointPeer(PeerAddress string) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {

	if t == nil {
		return nil
	}

	key := PeerAddress

	if lm, ok := t.EndpointPeer[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpointPeer deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteEndpointPeer(PeerAddress string) {
	key := PeerAddress

	delete(t.EndpointPeer, key)
}

// AppendEndpointPeer appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct to the
// list EndpointPeer of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendEndpointPeer(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) error {
	if v.PeerAddress == nil {
		return fmt.Errorf("invalid nil key received for PeerAddress")
	}

	key := *v.PeerAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}

	if _, ok := t.EndpointPeer[key]; ok {
		return fmt.Errorf("duplicate key for list EndpointPeer %v", key)
	}

	t.EndpointPeer[key] = v
	return nil
}

// NewEndpointVni creates a new entry in the EndpointVni list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewEndpointVni(Vni uint32) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}

	key := Vni

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EndpointVni[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EndpointVni", key)
	}

	t.EndpointVni[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni{
		Vni: &Vni,
	}

	return t.EndpointVni[key], nil
}

// RenameEndpointVni renames an entry in the list EndpointVni within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameEndpointVni(oldK, newK uint32) error {
	if _, ok := t.EndpointVni[newK]; ok {
		return fmt.Errorf("key %v already exists in EndpointVni", newK)
	}

	e, ok := t.EndpointVni[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EndpointVni", oldK)
	}
	e.Vni = &newK

	t.EndpointVni[newK] = e
	delete(t.EndpointVni, oldK)
	return nil
}

// GetOrCreateEndpointVniMap returns the list (map) from NetworkInstance_ConnectionPoint_Endpoint_Vxlan.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointVniMap() map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}
	return t.EndpointVni
}

// GetOrCreateEndpointVni retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {

	key := Vni

	if v, ok := t.EndpointVni[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpointVni(Vni)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpointVni got unexpected error: %v", err))
	}
	return v
}

// GetEndpointVni retrieves the value with the specified key from
// the EndpointVni map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {

	if t == nil {
		return nil
	}

	key := Vni

	if lm, ok := t.EndpointVni[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpointVni deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteEndpointVni(Vni uint32) {
	key := Vni

	delete(t.EndpointVni, key)
}

// AppendEndpointVni appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct to the
// list EndpointVni of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendEndpointVni(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) error {
	if v.Vni == nil {
		return fmt.Errorf("invalid nil key received for Vni")
	}

	key := *v.Vni

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}

	if _, ok := t.EndpointVni[key]; ok {
		return fmt.Errorf("duplicate key for list EndpointVni %v", key)
	}

	t.EndpointVni[key] = v
	return nil
}

// NewLocalEndpointVni creates a new entry in the LocalEndpointVni list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewLocalEndpointVni(Vni uint32) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LocalEndpointVni == nil {
		t.LocalEndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni)
	}

	key := Vni

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LocalEndpointVni[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LocalEndpointVni", key)
	}

	t.LocalEndpointVni[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni{
		Vni: &Vni,
	}

	return t.LocalEndpointVni[key], nil
}

// RenameLocalEndpointVni renames an entry in the list LocalEndpointVni within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameLocalEndpointVni(oldK, newK uint32) error {
	if _, ok := t.LocalEndpointVni[newK]; ok {
		return fmt.Errorf("key %v already exists in LocalEndpointVni", newK)
	}

	e, ok := t.LocalEndpointVni[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LocalEndpointVni", oldK)
	}
	e.Vni = &newK

	t.LocalEndpointVni[newK] = e
	delete(t.LocalEndpointVni, oldK)
	return nil
}

// GetOrCreateLocalEndpointVniMap returns the list (map) from NetworkInstance_ConnectionPoint_Endpoint_Vxlan.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateLocalEndpointVniMap() map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni {
	if t.LocalEndpointVni == nil {
		t.LocalEndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni)
	}
	return t.LocalEndpointVni
}

// GetOrCreateLocalEndpointVni retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateLocalEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni {

	key := Vni

	if v, ok := t.LocalEndpointVni[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLocalEndpointVni(Vni)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLocalEndpointVni got unexpected error: %v", err))
	}
	return v
}

// GetLocalEndpointVni retrieves the value with the specified key from
// the LocalEndpointVni map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetLocalEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni {

	if t == nil {
		return nil
	}

	key := Vni

	if lm, ok := t.LocalEndpointVni[key]; ok {
		return lm
	}
	return nil
}

// DeleteLocalEndpointVni deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteLocalEndpointVni(Vni uint32) {
	key := Vni

	delete(t.LocalEndpointVni, key)
}

// AppendLocalEndpointVni appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni struct to the
// list LocalEndpointVni of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendLocalEndpointVni(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) error {
	if v.Vni == nil {
		return fmt.Errorf("invalid nil key received for Vni")
	}

	key := *v.Vni

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LocalEndpointVni == nil {
		t.LocalEndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni)
	}

	if _, ok := t.LocalEndpointVni[key]; ok {
		return fmt.Errorf("duplicate key for list LocalEndpointVni %v", key)
	}

	t.LocalEndpointVni[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetSourceInterface retrieves the value of the leaf SourceInterface from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceInterface is set, it can
// safely use t.GetSourceInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceInterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetSourceInterface() string {
	if t == nil || t.SourceInterface == nil {
		return ""
	}
	return *t.SourceInterface
}

// SetDescription sets the value of the leaf Description in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) SetDescription(v string) {
	t.Description = &v
}

// SetEnabled sets the value of the leaf Enabled in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetSourceInterface sets the value of the leaf SourceInterface in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) SetSourceInterface(v string) {
	t.SourceInterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.EndpointPeer {
		e.PopulateDefaults()
	}
	for _, e := range t.EndpointVni {
		e.PopulateDefaults()
	}
	for _, e := range t.LocalEndpointVni {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-peers/endpoint-peer YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct {
	ControlPlaneVnis []uint32                                                                                                                                                   `path:"state/control-plane-vnis" module:"openconfig-network-instance/openconfig-network-instance"`
	Counters         *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters                                                                                      `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerAddress      *string                                                                                                                                                    `path:"state/peer-address|peer-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"peer-address" shadow-module:"openconfig-network-instance"`
	PeerState        E_EndpointPeer_PeerState                                                                                                                                   `path:"state/peer-state" module:"openconfig-network-instance/openconfig-network-instance"`
	RouterMac        *string                                                                                                                                                    `path:"state/router-mac" module:"openconfig-network-instance/openconfig-network-instance"`
	Uptime           *uint64                                                                                                                                                    `path:"state/uptime" module:"openconfig-network-instance/openconfig-network-instance"`
	VniPeerGroup     map[NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup `path:"vni-peer-groups/vni-peer-group" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) IsYANGGoStruct() {}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key represents the key for list VniPeerGroup of element /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-peers/endpoint-peer.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key struct {
	CpVni     uint32 `path:"cp-vni"`
	EgressVni uint32 `path:"egress-vni"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key) IsYANGGoKeyStruct() {
}

// ΛListKeyMap returns the values of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key key struct.
func (t NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"cp-vni":     t.CpVni,
		"egress-vni": t.EgressVni,
	}, nil
}

// NewVniPeerGroup creates a new entry in the VniPeerGroup list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) NewVniPeerGroup(CpVni uint32, EgressVni uint32) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VniPeerGroup == nil {
		t.VniPeerGroup = make(map[NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup)
	}

	key := NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key{
		CpVni:     CpVni,
		EgressVni: EgressVni,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VniPeerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VniPeerGroup", key)
	}

	t.VniPeerGroup[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup{
		CpVni:     &CpVni,
		EgressVni: &EgressVni,
	}

	return t.VniPeerGroup[key], nil
}

// RenameVniPeerGroup renames an entry in the list VniPeerGroup within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) RenameVniPeerGroup(oldK, newK NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key) error {
	if _, ok := t.VniPeerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VniPeerGroup", newK)
	}

	e, ok := t.VniPeerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VniPeerGroup", oldK)
	}
	e.CpVni = &newK.CpVni
	e.EgressVni = &newK.EgressVni

	t.VniPeerGroup[newK] = e
	delete(t.VniPeerGroup, oldK)
	return nil
}

// GetOrCreateVniPeerGroupMap returns the list (map) from NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetOrCreateVniPeerGroupMap() map[NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup {
	if t.VniPeerGroup == nil {
		t.VniPeerGroup = make(map[NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup)
	}
	return t.VniPeerGroup
}

// GetOrCreateVniPeerGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetOrCreateVniPeerGroup(CpVni uint32, EgressVni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup {

	key := NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key{
		CpVni:     CpVni,
		EgressVni: EgressVni,
	}

	if v, ok := t.VniPeerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVniPeerGroup(CpVni, EgressVni)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVniPeerGroup got unexpected error: %v", err))
	}
	return v
}

// GetVniPeerGroup retrieves the value with the specified key from
// the VniPeerGroup map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetVniPeerGroup(CpVni uint32, EgressVni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup {

	if t == nil {
		return nil
	}

	key := NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key{
		CpVni:     CpVni,
		EgressVni: EgressVni,
	}

	if lm, ok := t.VniPeerGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVniPeerGroup deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) DeleteVniPeerGroup(CpVni uint32, EgressVni uint32) {
	key := NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key{
		CpVni:     CpVni,
		EgressVni: EgressVni,
	}

	delete(t.VniPeerGroup, key)
}

// AppendVniPeerGroup appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup struct to the
// list VniPeerGroup of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) AppendVniPeerGroup(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) error {
	if v.CpVni == nil {
		return fmt.Errorf("invalid nil key for CpVni")
	}

	if v.EgressVni == nil {
		return fmt.Errorf("invalid nil key for EgressVni")
	}

	key := NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key{
		CpVni:     *v.CpVni,
		EgressVni: *v.EgressVni,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VniPeerGroup == nil {
		t.VniPeerGroup = make(map[NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup_Key]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup)
	}

	if _, ok := t.VniPeerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VniPeerGroup %v", key)
	}

	t.VniPeerGroup[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetOrCreateCounters() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetCounters() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetControlPlaneVnis retrieves the value of the leaf ControlPlaneVnis from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlPlaneVnis is set, it can
// safely use t.GetControlPlaneVnis() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlPlaneVnis == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetControlPlaneVnis() []uint32 {
	if t == nil || t.ControlPlaneVnis == nil {
		return nil
	}
	return t.ControlPlaneVnis
}

// GetPeerAddress retrieves the value of the leaf PeerAddress from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerAddress is set, it can
// safely use t.GetPeerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetPeerAddress() string {
	if t == nil || t.PeerAddress == nil {
		return ""
	}
	return *t.PeerAddress
}

// GetPeerState retrieves the value of the leaf PeerState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerState is set, it can
// safely use t.GetPeerState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetPeerState() E_EndpointPeer_PeerState {
	if t == nil || t.PeerState == 0 {
		return 0
	}
	return t.PeerState
}

// GetRouterMac retrieves the value of the leaf RouterMac from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterMac is set, it can
// safely use t.GetRouterMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetRouterMac() string {
	if t == nil || t.RouterMac == nil {
		return ""
	}
	return *t.RouterMac
}

// GetUptime retrieves the value of the leaf Uptime from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uptime is set, it can
// safely use t.GetUptime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uptime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetUptime() uint64 {
	if t == nil || t.Uptime == nil {
		return 0
	}
	return *t.Uptime
}

// SetControlPlaneVnis sets the value of the leaf ControlPlaneVnis in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) SetControlPlaneVnis(v []uint32) {
	t.ControlPlaneVnis = v
}

// SetPeerAddress sets the value of the leaf PeerAddress in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) SetPeerAddress(v string) {
	t.PeerAddress = &v
}

// SetPeerState sets the value of the leaf PeerState in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) SetPeerState(v E_EndpointPeer_PeerState) {
	t.PeerState = v
}

// SetRouterMac sets the value of the leaf RouterMac in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) SetRouterMac(v string) {
	t.RouterMac = &v
}

// SetUptime sets the value of the leaf Uptime in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) SetUptime(v uint64) {
	t.Uptime = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	for _, e := range t.VniPeerGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerAddress == nil {
		return nil, fmt.Errorf("nil value for key PeerAddress")
	}

	return map[string]interface{}{
		"peer-address": *t.PeerAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-peers/endpoint-peer/state/counters YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters struct {
	BumDecapIrPkts        *uint64 `path:"bum-decap-ir-pkts" module:"openconfig-network-instance"`
	BumDecapMulticastPkts *uint64 `path:"bum-decap-multicast-pkts" module:"openconfig-network-instance"`
	BumDecapPkts          *uint64 `path:"bum-decap-pkts" module:"openconfig-network-instance"`
	BumEncapPkts          *uint64 `path:"bum-encap-pkts" module:"openconfig-network-instance"`
	DropDecapPkts         *uint64 `path:"drop-decap-pkts" module:"openconfig-network-instance"`
	ExceptDecapPkts       *uint64 `path:"except-decap-pkts" module:"openconfig-network-instance"`
	TotalDecapBytes       *uint64 `path:"total-decap-bytes" module:"openconfig-network-instance"`
	TotalDecapPkts        *uint64 `path:"total-decap-pkts" module:"openconfig-network-instance"`
	TotalEncapBytes       *uint64 `path:"total-encap-bytes" module:"openconfig-network-instance"`
	TotalEncapPkts        *uint64 `path:"total-encap-pkts" module:"openconfig-network-instance"`
	UnicastDecapPkts      *uint64 `path:"unicast-decap-pkts" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) IsYANGGoStruct() {}

// GetBumDecapIrPkts retrieves the value of the leaf BumDecapIrPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapIrPkts is set, it can
// safely use t.GetBumDecapIrPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapIrPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetBumDecapIrPkts() uint64 {
	if t == nil || t.BumDecapIrPkts == nil {
		return 0
	}
	return *t.BumDecapIrPkts
}

// GetBumDecapMulticastPkts retrieves the value of the leaf BumDecapMulticastPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapMulticastPkts is set, it can
// safely use t.GetBumDecapMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapMulticastPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetBumDecapMulticastPkts() uint64 {
	if t == nil || t.BumDecapMulticastPkts == nil {
		return 0
	}
	return *t.BumDecapMulticastPkts
}

// GetBumDecapPkts retrieves the value of the leaf BumDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapPkts is set, it can
// safely use t.GetBumDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetBumDecapPkts() uint64 {
	if t == nil || t.BumDecapPkts == nil {
		return 0
	}
	return *t.BumDecapPkts
}

// GetBumEncapPkts retrieves the value of the leaf BumEncapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumEncapPkts is set, it can
// safely use t.GetBumEncapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumEncapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetBumEncapPkts() uint64 {
	if t == nil || t.BumEncapPkts == nil {
		return 0
	}
	return *t.BumEncapPkts
}

// GetDropDecapPkts retrieves the value of the leaf DropDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropDecapPkts is set, it can
// safely use t.GetDropDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetDropDecapPkts() uint64 {
	if t == nil || t.DropDecapPkts == nil {
		return 0
	}
	return *t.DropDecapPkts
}

// GetExceptDecapPkts retrieves the value of the leaf ExceptDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceptDecapPkts is set, it can
// safely use t.GetExceptDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceptDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetExceptDecapPkts() uint64 {
	if t == nil || t.ExceptDecapPkts == nil {
		return 0
	}
	return *t.ExceptDecapPkts
}

// GetTotalDecapBytes retrieves the value of the leaf TotalDecapBytes from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalDecapBytes is set, it can
// safely use t.GetTotalDecapBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalDecapBytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetTotalDecapBytes() uint64 {
	if t == nil || t.TotalDecapBytes == nil {
		return 0
	}
	return *t.TotalDecapBytes
}

// GetTotalDecapPkts retrieves the value of the leaf TotalDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalDecapPkts is set, it can
// safely use t.GetTotalDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetTotalDecapPkts() uint64 {
	if t == nil || t.TotalDecapPkts == nil {
		return 0
	}
	return *t.TotalDecapPkts
}

// GetTotalEncapBytes retrieves the value of the leaf TotalEncapBytes from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalEncapBytes is set, it can
// safely use t.GetTotalEncapBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalEncapBytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetTotalEncapBytes() uint64 {
	if t == nil || t.TotalEncapBytes == nil {
		return 0
	}
	return *t.TotalEncapBytes
}

// GetTotalEncapPkts retrieves the value of the leaf TotalEncapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalEncapPkts is set, it can
// safely use t.GetTotalEncapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalEncapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetTotalEncapPkts() uint64 {
	if t == nil || t.TotalEncapPkts == nil {
		return 0
	}
	return *t.TotalEncapPkts
}

// GetUnicastDecapPkts retrieves the value of the leaf UnicastDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnicastDecapPkts is set, it can
// safely use t.GetUnicastDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnicastDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) GetUnicastDecapPkts() uint64 {
	if t == nil || t.UnicastDecapPkts == nil {
		return 0
	}
	return *t.UnicastDecapPkts
}

// SetBumDecapIrPkts sets the value of the leaf BumDecapIrPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetBumDecapIrPkts(v uint64) {
	t.BumDecapIrPkts = &v
}

// SetBumDecapMulticastPkts sets the value of the leaf BumDecapMulticastPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetBumDecapMulticastPkts(v uint64) {
	t.BumDecapMulticastPkts = &v
}

// SetBumDecapPkts sets the value of the leaf BumDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetBumDecapPkts(v uint64) {
	t.BumDecapPkts = &v
}

// SetBumEncapPkts sets the value of the leaf BumEncapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetBumEncapPkts(v uint64) {
	t.BumEncapPkts = &v
}

// SetDropDecapPkts sets the value of the leaf DropDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetDropDecapPkts(v uint64) {
	t.DropDecapPkts = &v
}

// SetExceptDecapPkts sets the value of the leaf ExceptDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetExceptDecapPkts(v uint64) {
	t.ExceptDecapPkts = &v
}

// SetTotalDecapBytes sets the value of the leaf TotalDecapBytes in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetTotalDecapBytes(v uint64) {
	t.TotalDecapBytes = &v
}

// SetTotalDecapPkts sets the value of the leaf TotalDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetTotalDecapPkts(v uint64) {
	t.TotalDecapPkts = &v
}

// SetTotalEncapBytes sets the value of the leaf TotalEncapBytes in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetTotalEncapBytes(v uint64) {
	t.TotalEncapBytes = &v
}

// SetTotalEncapPkts sets the value of the leaf TotalEncapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetTotalEncapPkts(v uint64) {
	t.TotalEncapPkts = &v
}

// SetUnicastDecapPkts sets the value of the leaf UnicastDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) SetUnicastDecapPkts(v uint64) {
	t.UnicastDecapPkts = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-peers/endpoint-peer/vni-peer-groups/vni-peer-group YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup struct {
	CpVni     *uint32 `path:"state/cp-vni|cp-vni" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"cp-vni" shadow-module:"openconfig-network-instance"`
	EgressVni *uint32 `path:"state/egress-vni|egress-vni" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"egress-vni" shadow-module:"openconfig-network-instance"`
	RouterMac *string `path:"state/router-mac" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) IsYANGGoStruct() {}

// GetCpVni retrieves the value of the leaf CpVni from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CpVni is set, it can
// safely use t.GetCpVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CpVni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) GetCpVni() uint32 {
	if t == nil || t.CpVni == nil {
		return 0
	}
	return *t.CpVni
}

// GetEgressVni retrieves the value of the leaf EgressVni from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EgressVni is set, it can
// safely use t.GetEgressVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EgressVni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) GetEgressVni() uint32 {
	if t == nil || t.EgressVni == nil {
		return 0
	}
	return *t.EgressVni
}

// GetRouterMac retrieves the value of the leaf RouterMac from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterMac is set, it can
// safely use t.GetRouterMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) GetRouterMac() string {
	if t == nil || t.RouterMac == nil {
		return ""
	}
	return *t.RouterMac
}

// SetCpVni sets the value of the leaf CpVni in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) SetCpVni(v uint32) {
	t.CpVni = &v
}

// SetEgressVni sets the value of the leaf EgressVni in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) SetEgressVni(v uint32) {
	t.EgressVni = &v
}

// SetRouterMac sets the value of the leaf RouterMac in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) SetRouterMac(v string) {
	t.RouterMac = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.CpVni == nil {
		return nil, fmt.Errorf("nil value for key CpVni")
	}

	if t.EgressVni == nil {
		return nil, fmt.Errorf("nil value for key EgressVni")
	}

	return map[string]interface{}{
		"cp-vni":     *t.CpVni,
		"egress-vni": *t.EgressVni,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer_VniPeerGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct {
	BridgeDomain            *uint32                                                                                  `path:"state/bridge-domain" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv4                    *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4                         `path:"ipv4" module:"openconfig-network-instance"`
	Ipv6                    *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6                         `path:"ipv6" module:"openconfig-network-instance"`
	L3VrfName               *string                                                                                  `path:"state/l3-vrf-name" module:"openconfig-network-instance/openconfig-network-instance"`
	LearningMode            E_EvpnTypes_LearningMode                                                                 `path:"state/learning-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	MultidestinationTraffic NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union `path:"state/multidestination-traffic" module:"openconfig-network-instance/openconfig-network-instance"`
	SviState                E_EndpointVni_SviState                                                                   `path:"state/svi-state" module:"openconfig-network-instance/openconfig-network-instance"`
	Vni                     *uint32                                                                                  `path:"state/vni|vni" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"vni" shadow-module:"openconfig-network-instance"`
	VniState                E_EndpointVni_VniState                                                                   `path:"state/vni-state" module:"openconfig-network-instance/openconfig-network-instance"`
	VniType                 E_EndpointVni_VniType                                                                    `path:"state/vni-type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) IsYANGGoStruct() {}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetOrCreateIpv4() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetOrCreateIpv6() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6{}
	return t.Ipv6
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetIpv4() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetIpv6() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetBridgeDomain retrieves the value of the leaf BridgeDomain from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BridgeDomain is set, it can
// safely use t.GetBridgeDomain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BridgeDomain == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetBridgeDomain() uint32 {
	if t == nil || t.BridgeDomain == nil {
		return 0
	}
	return *t.BridgeDomain
}

// GetL3VrfName retrieves the value of the leaf L3VrfName from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3VrfName is set, it can
// safely use t.GetL3VrfName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3VrfName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetL3VrfName() string {
	if t == nil || t.L3VrfName == nil {
		return ""
	}
	return *t.L3VrfName
}

// GetLearningMode retrieves the value of the leaf LearningMode from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearningMode is set, it can
// safely use t.GetLearningMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearningMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetLearningMode() E_EvpnTypes_LearningMode {
	if t == nil || t.LearningMode == 0 {
		return 0
	}
	return t.LearningMode
}

// GetMultidestinationTraffic retrieves the value of the leaf MultidestinationTraffic from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MultidestinationTraffic is set, it can
// safely use t.GetMultidestinationTraffic() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MultidestinationTraffic == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetMultidestinationTraffic() NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union {
	if t == nil || t.MultidestinationTraffic == nil {
		return nil
	}
	return t.MultidestinationTraffic
}

// GetSviState retrieves the value of the leaf SviState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SviState is set, it can
// safely use t.GetSviState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SviState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetSviState() E_EndpointVni_SviState {
	if t == nil || t.SviState == 0 {
		return 0
	}
	return t.SviState
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// GetVniState retrieves the value of the leaf VniState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniState is set, it can
// safely use t.GetVniState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVniState() E_EndpointVni_VniState {
	if t == nil || t.VniState == 0 {
		return 0
	}
	return t.VniState
}

// GetVniType retrieves the value of the leaf VniType from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniType is set, it can
// safely use t.GetVniType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVniType() E_EndpointVni_VniType {
	if t == nil || t.VniType == 0 {
		return 0
	}
	return t.VniType
}

// SetBridgeDomain sets the value of the leaf BridgeDomain in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) SetBridgeDomain(v uint32) {
	t.BridgeDomain = &v
}

// SetL3VrfName sets the value of the leaf L3VrfName in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) SetL3VrfName(v string) {
	t.L3VrfName = &v
}

// SetLearningMode sets the value of the leaf LearningMode in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) SetLearningMode(v E_EvpnTypes_LearningMode) {
	t.LearningMode = v
}

// SetMultidestinationTraffic sets the value of the leaf MultidestinationTraffic in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) SetMultidestinationTraffic(v NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union) {
	t.MultidestinationTraffic = v
}

// SetSviState sets the value of the leaf SviState in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) SetSviState(v E_EndpointVni_SviState) {
	t.SviState = v
}

// SetVni sets the value of the leaf Vni in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) SetVni(v uint32) {
	t.Vni = &v
}

// SetVniState sets the value of the leaf VniState in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) SetVniState(v E_EndpointVni_VniState) {
	t.VniState = v
}

// SetVniType sets the value of the leaf VniType in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) SetVniType(v E_EndpointVni_VniType) {
	t.VniType = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Vni == nil {
		return nil, fmt.Errorf("nil value for key Vni")
	}

	return map[string]interface{}{
		"vni": *t.Vni,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4 represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni/ipv4 YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4 struct {
	Counters *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4) GetOrCreateCounters() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4) GetCounters() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni/ipv4/state/counters YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters struct {
	BumDecapIrPkts        *uint64 `path:"bum-decap-ir-pkts" module:"openconfig-network-instance"`
	BumDecapMulticastPkts *uint64 `path:"bum-decap-multicast-pkts" module:"openconfig-network-instance"`
	BumDecapPkts          *uint64 `path:"bum-decap-pkts" module:"openconfig-network-instance"`
	BumEncapPkts          *uint64 `path:"bum-encap-pkts" module:"openconfig-network-instance"`
	DropDecapPkts         *uint64 `path:"drop-decap-pkts" module:"openconfig-network-instance"`
	ExceptDecapPkts       *uint64 `path:"except-decap-pkts" module:"openconfig-network-instance"`
	TotalDecapBytes       *uint64 `path:"total-decap-bytes" module:"openconfig-network-instance"`
	TotalDecapPkts        *uint64 `path:"total-decap-pkts" module:"openconfig-network-instance"`
	TotalEncapBytes       *uint64 `path:"total-encap-bytes" module:"openconfig-network-instance"`
	TotalEncapPkts        *uint64 `path:"total-encap-pkts" module:"openconfig-network-instance"`
	UnicastDecapPkts      *uint64 `path:"unicast-decap-pkts" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) IsYANGGoStruct() {}

// GetBumDecapIrPkts retrieves the value of the leaf BumDecapIrPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapIrPkts is set, it can
// safely use t.GetBumDecapIrPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapIrPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetBumDecapIrPkts() uint64 {
	if t == nil || t.BumDecapIrPkts == nil {
		return 0
	}
	return *t.BumDecapIrPkts
}

// GetBumDecapMulticastPkts retrieves the value of the leaf BumDecapMulticastPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapMulticastPkts is set, it can
// safely use t.GetBumDecapMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapMulticastPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetBumDecapMulticastPkts() uint64 {
	if t == nil || t.BumDecapMulticastPkts == nil {
		return 0
	}
	return *t.BumDecapMulticastPkts
}

// GetBumDecapPkts retrieves the value of the leaf BumDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapPkts is set, it can
// safely use t.GetBumDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetBumDecapPkts() uint64 {
	if t == nil || t.BumDecapPkts == nil {
		return 0
	}
	return *t.BumDecapPkts
}

// GetBumEncapPkts retrieves the value of the leaf BumEncapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumEncapPkts is set, it can
// safely use t.GetBumEncapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumEncapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetBumEncapPkts() uint64 {
	if t == nil || t.BumEncapPkts == nil {
		return 0
	}
	return *t.BumEncapPkts
}

// GetDropDecapPkts retrieves the value of the leaf DropDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropDecapPkts is set, it can
// safely use t.GetDropDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetDropDecapPkts() uint64 {
	if t == nil || t.DropDecapPkts == nil {
		return 0
	}
	return *t.DropDecapPkts
}

// GetExceptDecapPkts retrieves the value of the leaf ExceptDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceptDecapPkts is set, it can
// safely use t.GetExceptDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceptDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetExceptDecapPkts() uint64 {
	if t == nil || t.ExceptDecapPkts == nil {
		return 0
	}
	return *t.ExceptDecapPkts
}

// GetTotalDecapBytes retrieves the value of the leaf TotalDecapBytes from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalDecapBytes is set, it can
// safely use t.GetTotalDecapBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalDecapBytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetTotalDecapBytes() uint64 {
	if t == nil || t.TotalDecapBytes == nil {
		return 0
	}
	return *t.TotalDecapBytes
}

// GetTotalDecapPkts retrieves the value of the leaf TotalDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalDecapPkts is set, it can
// safely use t.GetTotalDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetTotalDecapPkts() uint64 {
	if t == nil || t.TotalDecapPkts == nil {
		return 0
	}
	return *t.TotalDecapPkts
}

// GetTotalEncapBytes retrieves the value of the leaf TotalEncapBytes from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalEncapBytes is set, it can
// safely use t.GetTotalEncapBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalEncapBytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetTotalEncapBytes() uint64 {
	if t == nil || t.TotalEncapBytes == nil {
		return 0
	}
	return *t.TotalEncapBytes
}

// GetTotalEncapPkts retrieves the value of the leaf TotalEncapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalEncapPkts is set, it can
// safely use t.GetTotalEncapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalEncapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetTotalEncapPkts() uint64 {
	if t == nil || t.TotalEncapPkts == nil {
		return 0
	}
	return *t.TotalEncapPkts
}

// GetUnicastDecapPkts retrieves the value of the leaf UnicastDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnicastDecapPkts is set, it can
// safely use t.GetUnicastDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnicastDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) GetUnicastDecapPkts() uint64 {
	if t == nil || t.UnicastDecapPkts == nil {
		return 0
	}
	return *t.UnicastDecapPkts
}

// SetBumDecapIrPkts sets the value of the leaf BumDecapIrPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetBumDecapIrPkts(v uint64) {
	t.BumDecapIrPkts = &v
}

// SetBumDecapMulticastPkts sets the value of the leaf BumDecapMulticastPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetBumDecapMulticastPkts(v uint64) {
	t.BumDecapMulticastPkts = &v
}

// SetBumDecapPkts sets the value of the leaf BumDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetBumDecapPkts(v uint64) {
	t.BumDecapPkts = &v
}

// SetBumEncapPkts sets the value of the leaf BumEncapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetBumEncapPkts(v uint64) {
	t.BumEncapPkts = &v
}

// SetDropDecapPkts sets the value of the leaf DropDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetDropDecapPkts(v uint64) {
	t.DropDecapPkts = &v
}

// SetExceptDecapPkts sets the value of the leaf ExceptDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetExceptDecapPkts(v uint64) {
	t.ExceptDecapPkts = &v
}

// SetTotalDecapBytes sets the value of the leaf TotalDecapBytes in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetTotalDecapBytes(v uint64) {
	t.TotalDecapBytes = &v
}

// SetTotalDecapPkts sets the value of the leaf TotalDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetTotalDecapPkts(v uint64) {
	t.TotalDecapPkts = &v
}

// SetTotalEncapBytes sets the value of the leaf TotalEncapBytes in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetTotalEncapBytes(v uint64) {
	t.TotalEncapBytes = &v
}

// SetTotalEncapPkts sets the value of the leaf TotalEncapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetTotalEncapPkts(v uint64) {
	t.TotalEncapPkts = &v
}

// SetUnicastDecapPkts sets the value of the leaf UnicastDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) SetUnicastDecapPkts(v uint64) {
	t.UnicastDecapPkts = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv4_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6 represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni/ipv6 YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6 struct {
	Counters *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6) GetOrCreateCounters() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6) GetCounters() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni/ipv6/state/counters YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters struct {
	BumDecapIrPkts        *uint64 `path:"bum-decap-ir-pkts" module:"openconfig-network-instance"`
	BumDecapMulticastPkts *uint64 `path:"bum-decap-multicast-pkts" module:"openconfig-network-instance"`
	BumDecapPkts          *uint64 `path:"bum-decap-pkts" module:"openconfig-network-instance"`
	BumEncapPkts          *uint64 `path:"bum-encap-pkts" module:"openconfig-network-instance"`
	DropDecapPkts         *uint64 `path:"drop-decap-pkts" module:"openconfig-network-instance"`
	ExceptDecapPkts       *uint64 `path:"except-decap-pkts" module:"openconfig-network-instance"`
	TotalDecapBytes       *uint64 `path:"total-decap-bytes" module:"openconfig-network-instance"`
	TotalDecapPkts        *uint64 `path:"total-decap-pkts" module:"openconfig-network-instance"`
	TotalEncapBytes       *uint64 `path:"total-encap-bytes" module:"openconfig-network-instance"`
	TotalEncapPkts        *uint64 `path:"total-encap-pkts" module:"openconfig-network-instance"`
	UnicastDecapPkts      *uint64 `path:"unicast-decap-pkts" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) IsYANGGoStruct() {}

// GetBumDecapIrPkts retrieves the value of the leaf BumDecapIrPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapIrPkts is set, it can
// safely use t.GetBumDecapIrPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapIrPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetBumDecapIrPkts() uint64 {
	if t == nil || t.BumDecapIrPkts == nil {
		return 0
	}
	return *t.BumDecapIrPkts
}

// GetBumDecapMulticastPkts retrieves the value of the leaf BumDecapMulticastPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapMulticastPkts is set, it can
// safely use t.GetBumDecapMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapMulticastPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetBumDecapMulticastPkts() uint64 {
	if t == nil || t.BumDecapMulticastPkts == nil {
		return 0
	}
	return *t.BumDecapMulticastPkts
}

// GetBumDecapPkts retrieves the value of the leaf BumDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumDecapPkts is set, it can
// safely use t.GetBumDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetBumDecapPkts() uint64 {
	if t == nil || t.BumDecapPkts == nil {
		return 0
	}
	return *t.BumDecapPkts
}

// GetBumEncapPkts retrieves the value of the leaf BumEncapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BumEncapPkts is set, it can
// safely use t.GetBumEncapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BumEncapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetBumEncapPkts() uint64 {
	if t == nil || t.BumEncapPkts == nil {
		return 0
	}
	return *t.BumEncapPkts
}

// GetDropDecapPkts retrieves the value of the leaf DropDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropDecapPkts is set, it can
// safely use t.GetDropDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetDropDecapPkts() uint64 {
	if t == nil || t.DropDecapPkts == nil {
		return 0
	}
	return *t.DropDecapPkts
}

// GetExceptDecapPkts retrieves the value of the leaf ExceptDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceptDecapPkts is set, it can
// safely use t.GetExceptDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceptDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetExceptDecapPkts() uint64 {
	if t == nil || t.ExceptDecapPkts == nil {
		return 0
	}
	return *t.ExceptDecapPkts
}

// GetTotalDecapBytes retrieves the value of the leaf TotalDecapBytes from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalDecapBytes is set, it can
// safely use t.GetTotalDecapBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalDecapBytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetTotalDecapBytes() uint64 {
	if t == nil || t.TotalDecapBytes == nil {
		return 0
	}
	return *t.TotalDecapBytes
}

// GetTotalDecapPkts retrieves the value of the leaf TotalDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalDecapPkts is set, it can
// safely use t.GetTotalDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetTotalDecapPkts() uint64 {
	if t == nil || t.TotalDecapPkts == nil {
		return 0
	}
	return *t.TotalDecapPkts
}

// GetTotalEncapBytes retrieves the value of the leaf TotalEncapBytes from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalEncapBytes is set, it can
// safely use t.GetTotalEncapBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalEncapBytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetTotalEncapBytes() uint64 {
	if t == nil || t.TotalEncapBytes == nil {
		return 0
	}
	return *t.TotalEncapBytes
}

// GetTotalEncapPkts retrieves the value of the leaf TotalEncapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalEncapPkts is set, it can
// safely use t.GetTotalEncapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalEncapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetTotalEncapPkts() uint64 {
	if t == nil || t.TotalEncapPkts == nil {
		return 0
	}
	return *t.TotalEncapPkts
}

// GetUnicastDecapPkts retrieves the value of the leaf UnicastDecapPkts from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnicastDecapPkts is set, it can
// safely use t.GetUnicastDecapPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnicastDecapPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) GetUnicastDecapPkts() uint64 {
	if t == nil || t.UnicastDecapPkts == nil {
		return 0
	}
	return *t.UnicastDecapPkts
}

// SetBumDecapIrPkts sets the value of the leaf BumDecapIrPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetBumDecapIrPkts(v uint64) {
	t.BumDecapIrPkts = &v
}

// SetBumDecapMulticastPkts sets the value of the leaf BumDecapMulticastPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetBumDecapMulticastPkts(v uint64) {
	t.BumDecapMulticastPkts = &v
}

// SetBumDecapPkts sets the value of the leaf BumDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetBumDecapPkts(v uint64) {
	t.BumDecapPkts = &v
}

// SetBumEncapPkts sets the value of the leaf BumEncapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetBumEncapPkts(v uint64) {
	t.BumEncapPkts = &v
}

// SetDropDecapPkts sets the value of the leaf DropDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetDropDecapPkts(v uint64) {
	t.DropDecapPkts = &v
}

// SetExceptDecapPkts sets the value of the leaf ExceptDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetExceptDecapPkts(v uint64) {
	t.ExceptDecapPkts = &v
}

// SetTotalDecapBytes sets the value of the leaf TotalDecapBytes in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetTotalDecapBytes(v uint64) {
	t.TotalDecapBytes = &v
}

// SetTotalDecapPkts sets the value of the leaf TotalDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetTotalDecapPkts(v uint64) {
	t.TotalDecapPkts = &v
}

// SetTotalEncapBytes sets the value of the leaf TotalEncapBytes in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetTotalEncapBytes(v uint64) {
	t.TotalEncapBytes = &v
}

// SetTotalEncapPkts sets the value of the leaf TotalEncapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetTotalEncapPkts(v uint64) {
	t.TotalEncapPkts = &v
}

// SetUnicastDecapPkts sets the value of the leaf UnicastDecapPkts in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) SetUnicastDecapPkts(v uint64) {
	t.UnicastDecapPkts = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/local-endpoint-vnis/local-endpoint-vni YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni struct {
	BridgeDomain *uint32               `path:"state/bridge-domain" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/bridge-domain" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	L3VrfName    *string               `path:"state/l3-vrf-name" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/l3-vrf-name" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vni          *uint32               `path:"state/vni|vni" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/vni|vni" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	VniType      E_EndpointVni_VniType `path:"state/vni-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/vni-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) IsYANGGoStruct() {}

// GetBridgeDomain retrieves the value of the leaf BridgeDomain from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BridgeDomain is set, it can
// safely use t.GetBridgeDomain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BridgeDomain == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) GetBridgeDomain() uint32 {
	if t == nil || t.BridgeDomain == nil {
		return 0
	}
	return *t.BridgeDomain
}

// GetL3VrfName retrieves the value of the leaf L3VrfName from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3VrfName is set, it can
// safely use t.GetL3VrfName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3VrfName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) GetL3VrfName() string {
	if t == nil || t.L3VrfName == nil {
		return ""
	}
	return *t.L3VrfName
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// GetVniType retrieves the value of the leaf VniType from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniType is set, it can
// safely use t.GetVniType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) GetVniType() E_EndpointVni_VniType {
	if t == nil || t.VniType == 0 {
		return 0
	}
	return t.VniType
}

// SetBridgeDomain sets the value of the leaf BridgeDomain in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) SetBridgeDomain(v uint32) {
	t.BridgeDomain = &v
}

// SetL3VrfName sets the value of the leaf L3VrfName in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) SetL3VrfName(v string) {
	t.L3VrfName = &v
}

// SetVni sets the value of the leaf Vni in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) SetVni(v uint32) {
	t.Vni = &v
}

// SetVniType sets the value of the leaf VniType in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// struct.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) SetVniType(v E_EndpointVni_VniType) {
	t.VniType = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Vni == nil {
		return nil, fmt.Errorf("nil value for key Vni")
	}

	return map[string]interface{}{
		"vni": *t.Vni,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_LocalEndpointVni) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Encapsulation represents the /openconfig-network-instance/network-instances/network-instance/encapsulation YANG schema element.
type NetworkInstance_Encapsulation struct {
	ControlWord         *bool                                        `path:"state/control-word" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/control-word" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulationType   E_NetworkInstanceTypes_ENCAPSULATION         `path:"state/encapsulation-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/encapsulation-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LabelAllocationMode E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE `path:"state/label-allocation-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/label-allocation-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Encapsulation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Encapsulation) IsYANGGoStruct() {}

// GetControlWord retrieves the value of the leaf ControlWord from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlWord is set, it can
// safely use t.GetControlWord() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlWord == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetControlWord() bool {
	if t == nil || t.ControlWord == nil {
		return false
	}
	return *t.ControlWord
}

// GetEncapsulationType retrieves the value of the leaf EncapsulationType from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulationType is set, it can
// safely use t.GetEncapsulationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetEncapsulationType() E_NetworkInstanceTypes_ENCAPSULATION {
	if t == nil || t.EncapsulationType == 0 {
		return 0
	}
	return t.EncapsulationType
}

// GetLabelAllocationMode retrieves the value of the leaf LabelAllocationMode from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelAllocationMode is set, it can
// safely use t.GetLabelAllocationMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelAllocationMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetLabelAllocationMode() E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	if t == nil || t.LabelAllocationMode == 0 {
		return 0
	}
	return t.LabelAllocationMode
}

// SetControlWord sets the value of the leaf ControlWord in the NetworkInstance_Encapsulation
// struct.
func (t *NetworkInstance_Encapsulation) SetControlWord(v bool) {
	t.ControlWord = &v
}

// SetEncapsulationType sets the value of the leaf EncapsulationType in the NetworkInstance_Encapsulation
// struct.
func (t *NetworkInstance_Encapsulation) SetEncapsulationType(v E_NetworkInstanceTypes_ENCAPSULATION) {
	t.EncapsulationType = v
}

// SetLabelAllocationMode sets the value of the leaf LabelAllocationMode in the NetworkInstance_Encapsulation
// struct.
func (t *NetworkInstance_Encapsulation) SetLabelAllocationMode(v E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) {
	t.LabelAllocationMode = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Encapsulation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Encapsulation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Encapsulation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Encapsulation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Encapsulation.
func (*NetworkInstance_Encapsulation) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn represents the /openconfig-network-instance/network-instances/network-instance/evpn YANG schema element.
type NetworkInstance_Evpn struct {
	EvpnInstance map[string]*NetworkInstance_Evpn_EvpnInstance `path:"evpn-instances/evpn-instance" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn) IsYANGGoStruct() {}

// NewEvpnInstance creates a new entry in the EvpnInstance list of the
// NetworkInstance_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn) NewEvpnInstance(Evi string) (*NetworkInstance_Evpn_EvpnInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}

	key := Evi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EvpnInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EvpnInstance", key)
	}

	t.EvpnInstance[key] = &NetworkInstance_Evpn_EvpnInstance{
		Evi: &Evi,
	}

	return t.EvpnInstance[key], nil
}

// RenameEvpnInstance renames an entry in the list EvpnInstance within
// the NetworkInstance_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn) RenameEvpnInstance(oldK, newK string) error {
	if _, ok := t.EvpnInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in EvpnInstance", newK)
	}

	e, ok := t.EvpnInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EvpnInstance", oldK)
	}
	e.Evi = &newK

	t.EvpnInstance[newK] = e
	delete(t.EvpnInstance, oldK)
	return nil
}

// GetOrCreateEvpnInstanceMap returns the list (map) from NetworkInstance_Evpn.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Evpn) GetOrCreateEvpnInstanceMap() map[string]*NetworkInstance_Evpn_EvpnInstance {
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}
	return t.EvpnInstance
}

// GetOrCreateEvpnInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn) GetOrCreateEvpnInstance(Evi string) *NetworkInstance_Evpn_EvpnInstance {

	key := Evi

	if v, ok := t.EvpnInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvpnInstance(Evi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvpnInstance got unexpected error: %v", err))
	}
	return v
}

// GetEvpnInstance retrieves the value with the specified key from
// the EvpnInstance map field of NetworkInstance_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn) GetEvpnInstance(Evi string) *NetworkInstance_Evpn_EvpnInstance {

	if t == nil {
		return nil
	}

	key := Evi

	if lm, ok := t.EvpnInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteEvpnInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn) DeleteEvpnInstance(Evi string) {
	key := Evi

	delete(t.EvpnInstance, key)
}

// AppendEvpnInstance appends the supplied NetworkInstance_Evpn_EvpnInstance struct to the
// list EvpnInstance of NetworkInstance_Evpn. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn) AppendEvpnInstance(v *NetworkInstance_Evpn_EvpnInstance) error {
	if v.Evi == nil {
		return fmt.Errorf("invalid nil key received for Evi")
	}

	key := *v.Evi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}

	if _, ok := t.EvpnInstance[key]; ok {
		return fmt.Errorf("duplicate key for list EvpnInstance %v", key)
	}

	t.EvpnInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.EvpnInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn.
func (*NetworkInstance_Evpn) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance YANG schema element.
type NetworkInstance_Evpn_EvpnInstance struct {
	BComponent          map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent   `path:"pbb/b-component" module:"openconfig-network-instance/openconfig-network-instance"`
	ControlWordEnabled  *bool                                                      `path:"state/control-word-enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/control-word-enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulationType   E_NetworkInstanceTypes_ENCAPSULATION                       `path:"state/encapsulation-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/encapsulation-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Evi                 *string                                                    `path:"state/evi|evi" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/evi|evi" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ImportExportPolicy  *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy      `path:"import-export-policy" module:"openconfig-network-instance"`
	LocalVpwsServiceId  *uint32                                                    `path:"state/local-vpws-service-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/local-vpws-service-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastGroup      *string                                                    `path:"state/multicast-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/multicast-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastMask       *string                                                    `path:"state/multicast-mask" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/multicast-mask" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RemoteVpwsServiceId *uint32                                                    `path:"state/remote-vpws-service-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/remote-vpws-service-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReplicationMode     E_EvpnInstance_ReplicationMode                             `path:"state/replication-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/replication-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RouteDistinguisher  NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union `path:"state/route-distinguisher" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/route-distinguisher" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ServiceType         E_EvpnTypes_EVPN_TYPE                                      `path:"state/service-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/service-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vxlan               *NetworkInstance_Evpn_EvpnInstance_Vxlan                   `path:"vxlan" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance) IsYANGGoStruct() {}

// NewBComponent creates a new entry in the BComponent list of the
// NetworkInstance_Evpn_EvpnInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn_EvpnInstance) NewBComponent(BComponentName string) (*NetworkInstance_Evpn_EvpnInstance_BComponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}

	key := BComponentName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BComponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BComponent", key)
	}

	t.BComponent[key] = &NetworkInstance_Evpn_EvpnInstance_BComponent{
		BComponentName: &BComponentName,
	}

	return t.BComponent[key], nil
}

// RenameBComponent renames an entry in the list BComponent within
// the NetworkInstance_Evpn_EvpnInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn_EvpnInstance) RenameBComponent(oldK, newK string) error {
	if _, ok := t.BComponent[newK]; ok {
		return fmt.Errorf("key %v already exists in BComponent", newK)
	}

	e, ok := t.BComponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BComponent", oldK)
	}
	e.BComponentName = &newK

	t.BComponent[newK] = e
	delete(t.BComponent, oldK)
	return nil
}

// GetOrCreateBComponentMap returns the list (map) from NetworkInstance_Evpn_EvpnInstance.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateBComponentMap() map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent {
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}
	return t.BComponent
}

// GetOrCreateBComponent retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateBComponent(BComponentName string) *NetworkInstance_Evpn_EvpnInstance_BComponent {

	key := BComponentName

	if v, ok := t.BComponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBComponent(BComponentName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBComponent got unexpected error: %v", err))
	}
	return v
}

// GetBComponent retrieves the value with the specified key from
// the BComponent map field of NetworkInstance_Evpn_EvpnInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetBComponent(BComponentName string) *NetworkInstance_Evpn_EvpnInstance_BComponent {

	if t == nil {
		return nil
	}

	key := BComponentName

	if lm, ok := t.BComponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteBComponent deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn_EvpnInstance) DeleteBComponent(BComponentName string) {
	key := BComponentName

	delete(t.BComponent, key)
}

// AppendBComponent appends the supplied NetworkInstance_Evpn_EvpnInstance_BComponent struct to the
// list BComponent of NetworkInstance_Evpn_EvpnInstance. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance_BComponent already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn_EvpnInstance) AppendBComponent(v *NetworkInstance_Evpn_EvpnInstance_BComponent) error {
	if v.BComponentName == nil {
		return fmt.Errorf("invalid nil key received for BComponentName")
	}

	key := *v.BComponentName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}

	if _, ok := t.BComponent[key]; ok {
		return fmt.Errorf("duplicate key for list BComponent %v", key)
	}

	t.BComponent[key] = v
	return nil
}

// GetOrCreateImportExportPolicy retrieves the value of the ImportExportPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateImportExportPolicy() *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	if t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	t.ImportExportPolicy = &NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	return t.ImportExportPolicy
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateVxlan() *NetworkInstance_Evpn_EvpnInstance_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	return t.Vxlan
}

// GetImportExportPolicy returns the value of the ImportExportPolicy struct pointer
// from NetworkInstance_Evpn_EvpnInstance. If the receiver or the field ImportExportPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetImportExportPolicy() *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	if t != nil && t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_Evpn_EvpnInstance. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetVxlan() *NetworkInstance_Evpn_EvpnInstance_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetControlWordEnabled retrieves the value of the leaf ControlWordEnabled from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlWordEnabled is set, it can
// safely use t.GetControlWordEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlWordEnabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetControlWordEnabled() bool {
	if t == nil || t.ControlWordEnabled == nil {
		return false
	}
	return *t.ControlWordEnabled
}

// GetEncapsulationType retrieves the value of the leaf EncapsulationType from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulationType is set, it can
// safely use t.GetEncapsulationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetEncapsulationType() E_NetworkInstanceTypes_ENCAPSULATION {
	if t == nil || t.EncapsulationType == 0 {
		return 0
	}
	return t.EncapsulationType
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetEvi() string {
	if t == nil || t.Evi == nil {
		return ""
	}
	return *t.Evi
}

// GetLocalVpwsServiceId retrieves the value of the leaf LocalVpwsServiceId from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalVpwsServiceId is set, it can
// safely use t.GetLocalVpwsServiceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalVpwsServiceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetLocalVpwsServiceId() uint32 {
	if t == nil || t.LocalVpwsServiceId == nil {
		return 0
	}
	return *t.LocalVpwsServiceId
}

// GetMulticastGroup retrieves the value of the leaf MulticastGroup from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastGroup is set, it can
// safely use t.GetMulticastGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetMulticastGroup() string {
	if t == nil || t.MulticastGroup == nil {
		return ""
	}
	return *t.MulticastGroup
}

// GetMulticastMask retrieves the value of the leaf MulticastMask from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastMask is set, it can
// safely use t.GetMulticastMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetMulticastMask() string {
	if t == nil || t.MulticastMask == nil {
		return ""
	}
	return *t.MulticastMask
}

// GetRemoteVpwsServiceId retrieves the value of the leaf RemoteVpwsServiceId from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteVpwsServiceId is set, it can
// safely use t.GetRemoteVpwsServiceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteVpwsServiceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetRemoteVpwsServiceId() uint32 {
	if t == nil || t.RemoteVpwsServiceId == nil {
		return 0
	}
	return *t.RemoteVpwsServiceId
}

// GetReplicationMode retrieves the value of the leaf ReplicationMode from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplicationMode is set, it can
// safely use t.GetReplicationMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplicationMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetReplicationMode() E_EvpnInstance_ReplicationMode {
	if t == nil || t.ReplicationMode == 0 {
		return 0
	}
	return t.ReplicationMode
}

// GetRouteDistinguisher retrieves the value of the leaf RouteDistinguisher from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteDistinguisher is set, it can
// safely use t.GetRouteDistinguisher() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteDistinguisher == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetRouteDistinguisher() NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	if t == nil || t.RouteDistinguisher == nil {
		return nil
	}
	return t.RouteDistinguisher
}

// GetServiceType retrieves the value of the leaf ServiceType from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServiceType is set, it can
// safely use t.GetServiceType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServiceType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetServiceType() E_EvpnTypes_EVPN_TYPE {
	if t == nil || t.ServiceType == 0 {
		return 0
	}
	return t.ServiceType
}

// SetControlWordEnabled sets the value of the leaf ControlWordEnabled in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetControlWordEnabled(v bool) {
	t.ControlWordEnabled = &v
}

// SetEncapsulationType sets the value of the leaf EncapsulationType in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetEncapsulationType(v E_NetworkInstanceTypes_ENCAPSULATION) {
	t.EncapsulationType = v
}

// SetEvi sets the value of the leaf Evi in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetEvi(v string) {
	t.Evi = &v
}

// SetLocalVpwsServiceId sets the value of the leaf LocalVpwsServiceId in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetLocalVpwsServiceId(v uint32) {
	t.LocalVpwsServiceId = &v
}

// SetMulticastGroup sets the value of the leaf MulticastGroup in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetMulticastGroup(v string) {
	t.MulticastGroup = &v
}

// SetMulticastMask sets the value of the leaf MulticastMask in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetMulticastMask(v string) {
	t.MulticastMask = &v
}

// SetRemoteVpwsServiceId sets the value of the leaf RemoteVpwsServiceId in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetRemoteVpwsServiceId(v uint32) {
	t.RemoteVpwsServiceId = &v
}

// SetReplicationMode sets the value of the leaf ReplicationMode in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetReplicationMode(v E_EvpnInstance_ReplicationMode) {
	t.ReplicationMode = v
}

// SetRouteDistinguisher sets the value of the leaf RouteDistinguisher in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetRouteDistinguisher(v NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) {
	t.RouteDistinguisher = v
}

// SetServiceType sets the value of the leaf ServiceType in the NetworkInstance_Evpn_EvpnInstance
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance) SetServiceType(v E_EvpnTypes_EVPN_TYPE) {
	t.ServiceType = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ImportExportPolicy.PopulateDefaults()
	t.Vxlan.PopulateDefaults()
	for _, e := range t.BComponent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Evi == nil {
		return nil, fmt.Errorf("nil value for key Evi")
	}

	return map[string]interface{}{
		"evi": *t.Evi,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance.
func (*NetworkInstance_Evpn_EvpnInstance) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_BComponent represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_BComponent struct {
	BComponentName *string                                                             `path:"state/b-component-name|b-component-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/b-component-name|b-component-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	BackboneSrcMac *string                                                             `path:"state/backbone-src-mac" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/backbone-src-mac" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IComponent     map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent `path:"i-components/i-component" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_BComponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent) IsYANGGoStruct() {}

// NewIComponent creates a new entry in the IComponent list of the
// NetworkInstance_Evpn_EvpnInstance_BComponent struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) NewIComponent(ISid uint32) (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}

	key := ISid

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IComponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IComponent", key)
	}

	t.IComponent[key] = &NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
		ISid: &ISid,
	}

	return t.IComponent[key], nil
}

// RenameIComponent renames an entry in the list IComponent within
// the NetworkInstance_Evpn_EvpnInstance_BComponent struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) RenameIComponent(oldK, newK uint32) error {
	if _, ok := t.IComponent[newK]; ok {
		return fmt.Errorf("key %v already exists in IComponent", newK)
	}

	e, ok := t.IComponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IComponent", oldK)
	}
	e.ISid = &newK

	t.IComponent[newK] = e
	delete(t.IComponent, oldK)
	return nil
}

// GetOrCreateIComponentMap returns the list (map) from NetworkInstance_Evpn_EvpnInstance_BComponent.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetOrCreateIComponentMap() map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}
	return t.IComponent
}

// GetOrCreateIComponent retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance_BComponent. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetOrCreateIComponent(ISid uint32) *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {

	key := ISid

	if v, ok := t.IComponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIComponent(ISid)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIComponent got unexpected error: %v", err))
	}
	return v
}

// GetIComponent retrieves the value with the specified key from
// the IComponent map field of NetworkInstance_Evpn_EvpnInstance_BComponent. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetIComponent(ISid uint32) *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {

	if t == nil {
		return nil
	}

	key := ISid

	if lm, ok := t.IComponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteIComponent deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance_BComponent. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) DeleteIComponent(ISid uint32) {
	key := ISid

	delete(t.IComponent, key)
}

// AppendIComponent appends the supplied NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct to the
// list IComponent of NetworkInstance_Evpn_EvpnInstance_BComponent. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) AppendIComponent(v *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) error {
	if v.ISid == nil {
		return fmt.Errorf("invalid nil key received for ISid")
	}

	key := *v.ISid

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}

	if _, ok := t.IComponent[key]; ok {
		return fmt.Errorf("duplicate key for list IComponent %v", key)
	}

	t.IComponent[key] = v
	return nil
}

// GetBComponentName retrieves the value of the leaf BComponentName from the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BComponentName is set, it can
// safely use t.GetBComponentName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BComponentName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetBComponentName() string {
	if t == nil || t.BComponentName == nil {
		return ""
	}
	return *t.BComponentName
}

// GetBackboneSrcMac retrieves the value of the leaf BackboneSrcMac from the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackboneSrcMac is set, it can
// safely use t.GetBackboneSrcMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackboneSrcMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetBackboneSrcMac() string {
	if t == nil || t.BackboneSrcMac == nil {
		return ""
	}
	return *t.BackboneSrcMac
}

// SetBComponentName sets the value of the leaf BComponentName in the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) SetBComponentName(v string) {
	t.BComponentName = &v
}

// SetBackboneSrcMac sets the value of the leaf BackboneSrcMac in the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) SetBackboneSrcMac(v string) {
	t.BackboneSrcMac = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_BComponent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.IComponent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance_BComponent struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BComponentName == nil {
		return nil, fmt.Errorf("nil value for key BComponentName")
	}

	return map[string]interface{}{
		"b-component-name": *t.BComponentName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_BComponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_BComponent.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct {
	ISid *uint32 `path:"state/i-sid|i-sid" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/i-sid|i-sid" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) IsYANGGoStruct() {}

// GetISid retrieves the value of the leaf ISid from the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ISid is set, it can
// safely use t.GetISid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ISid == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) GetISid() uint32 {
	if t == nil || t.ISid == nil {
		return 0
	}
	return *t.ISid
}

// SetISid sets the value of the leaf ISid in the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) SetISid(v uint32) {
	t.ISid = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ISid == nil {
		return nil, fmt.Errorf("nil value for key ISid")
	}

	return map[string]interface{}{
		"i-sid": *t.ISid,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy struct {
	ExportRouteTarget []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union `path:"state/export-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/export-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportRouteTarget []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union `path:"state/import-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/import-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) IsYANGGoStruct() {}

// GetExportRouteTarget retrieves the value of the leaf ExportRouteTarget from the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportRouteTarget is set, it can
// safely use t.GetExportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) GetExportRouteTarget() []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union {
	if t == nil || t.ExportRouteTarget == nil {
		return nil
	}
	return t.ExportRouteTarget
}

// GetImportRouteTarget retrieves the value of the leaf ImportRouteTarget from the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportRouteTarget is set, it can
// safely use t.GetImportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) GetImportRouteTarget() []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union {
	if t == nil || t.ImportRouteTarget == nil {
		return nil
	}
	return t.ImportRouteTarget
}

// SetExportRouteTarget sets the value of the leaf ExportRouteTarget in the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) SetExportRouteTarget(v []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union) {
	t.ExportRouteTarget = v
}

// SetImportRouteTarget sets the value of the leaf ImportRouteTarget in the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) SetImportRouteTarget(v []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union) {
	t.ImportRouteTarget = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy.
func (*NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_Vxlan struct {
	AnycastSourceInterface         *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface `path:"anycast-source-interface" module:"openconfig-network-instance"`
	HostReachabilityBgp            *bool                                                           `path:"state/host-reachability-bgp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/host-reachability-bgp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastGroup                 *string                                                         `path:"state/multicast-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/multicast-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastMask                  *string                                                         `path:"state/multicast-mask" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/multicast-mask" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	OverlayEndpoint                *string                                                         `path:"state/overlay-endpoint" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/overlay-endpoint" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	OverlayEndpointNetworkInstance *string                                                         `path:"state/overlay-endpoint-network-instance" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/overlay-endpoint-network-instance" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vni                            *uint32                                                         `path:"state/vni" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/vni" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	VniList                        []uint32                                                        `path:"state/vni-list" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/vni-list" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan) IsYANGGoStruct() {}

// GetOrCreateAnycastSourceInterface retrieves the value of the AnycastSourceInterface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOrCreateAnycastSourceInterface() *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	if t.AnycastSourceInterface != nil {
		return t.AnycastSourceInterface
	}
	t.AnycastSourceInterface = &NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	return t.AnycastSourceInterface
}

// GetAnycastSourceInterface returns the value of the AnycastSourceInterface struct pointer
// from NetworkInstance_Evpn_EvpnInstance_Vxlan. If the receiver or the field AnycastSourceInterface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetAnycastSourceInterface() *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	if t != nil && t.AnycastSourceInterface != nil {
		return t.AnycastSourceInterface
	}
	return nil
}

// GetHostReachabilityBgp retrieves the value of the leaf HostReachabilityBgp from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostReachabilityBgp is set, it can
// safely use t.GetHostReachabilityBgp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostReachabilityBgp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetHostReachabilityBgp() bool {
	if t == nil || t.HostReachabilityBgp == nil {
		return false
	}
	return *t.HostReachabilityBgp
}

// GetMulticastGroup retrieves the value of the leaf MulticastGroup from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastGroup is set, it can
// safely use t.GetMulticastGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetMulticastGroup() string {
	if t == nil || t.MulticastGroup == nil {
		return ""
	}
	return *t.MulticastGroup
}

// GetMulticastMask retrieves the value of the leaf MulticastMask from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastMask is set, it can
// safely use t.GetMulticastMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetMulticastMask() string {
	if t == nil || t.MulticastMask == nil {
		return ""
	}
	return *t.MulticastMask
}

// GetOverlayEndpoint retrieves the value of the leaf OverlayEndpoint from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverlayEndpoint is set, it can
// safely use t.GetOverlayEndpoint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverlayEndpoint == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOverlayEndpoint() string {
	if t == nil || t.OverlayEndpoint == nil {
		return ""
	}
	return *t.OverlayEndpoint
}

// GetOverlayEndpointNetworkInstance retrieves the value of the leaf OverlayEndpointNetworkInstance from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverlayEndpointNetworkInstance is set, it can
// safely use t.GetOverlayEndpointNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverlayEndpointNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOverlayEndpointNetworkInstance() string {
	if t == nil || t.OverlayEndpointNetworkInstance == nil {
		return ""
	}
	return *t.OverlayEndpointNetworkInstance
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// GetVniList retrieves the value of the leaf VniList from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniList is set, it can
// safely use t.GetVniList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniList == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetVniList() []uint32 {
	if t == nil || t.VniList == nil {
		return nil
	}
	return t.VniList
}

// SetHostReachabilityBgp sets the value of the leaf HostReachabilityBgp in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) SetHostReachabilityBgp(v bool) {
	t.HostReachabilityBgp = &v
}

// SetMulticastGroup sets the value of the leaf MulticastGroup in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) SetMulticastGroup(v string) {
	t.MulticastGroup = &v
}

// SetMulticastMask sets the value of the leaf MulticastMask in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) SetMulticastMask(v string) {
	t.MulticastMask = &v
}

// SetOverlayEndpoint sets the value of the leaf OverlayEndpoint in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) SetOverlayEndpoint(v string) {
	t.OverlayEndpoint = &v
}

// SetOverlayEndpointNetworkInstance sets the value of the leaf OverlayEndpointNetworkInstance in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) SetOverlayEndpointNetworkInstance(v string) {
	t.OverlayEndpointNetworkInstance = &v
}

// SetVni sets the value of the leaf Vni in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) SetVni(v uint32) {
	t.Vni = &v
}

// SetVniList sets the value of the leaf VniList in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) SetVniList(v []uint32) {
	t.VniList = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AnycastSourceInterface.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_Vxlan.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb represents the /openconfig-network-instance/network-instances/network-instance/fdb YANG schema element.
type NetworkInstance_Fdb struct {
	AnycastGatewayMac             *string                          `path:"state/anycast-gateway-mac" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/anycast-gateway-mac" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ArpProxy                      *NetworkInstance_Fdb_ArpProxy    `path:"arp-proxy" module:"openconfig-network-instance"`
	FloodUnknownUnicastSupression *bool                            `path:"state/flood-unknown-unicast-supression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/flood-unknown-unicast-supression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	L2Rib                         *NetworkInstance_Fdb_L2Rib       `path:"l2rib" module:"openconfig-network-instance"`
	MacAgingTime                  *uint16                          `path:"state/mac-aging-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-aging-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacLearning                   *bool                            `path:"state/mac-learning" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-learning" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobility                   *NetworkInstance_Fdb_MacMobility `path:"mac-mobility" module:"openconfig-network-instance"`
	MacTable                      *NetworkInstance_Fdb_MacTable    `path:"mac-table" module:"openconfig-network-instance"`
	MaximumEntries                *uint16                          `path:"state/maximum-entries" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/maximum-entries" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NdProxy                       *NetworkInstance_Fdb_NdProxy     `path:"nd-proxy" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb) IsYANGGoStruct() {}

// GetOrCreateArpProxy retrieves the value of the ArpProxy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateArpProxy() *NetworkInstance_Fdb_ArpProxy {
	if t.ArpProxy != nil {
		return t.ArpProxy
	}
	t.ArpProxy = &NetworkInstance_Fdb_ArpProxy{}
	return t.ArpProxy
}

// GetOrCreateL2Rib retrieves the value of the L2Rib field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateL2Rib() *NetworkInstance_Fdb_L2Rib {
	if t.L2Rib != nil {
		return t.L2Rib
	}
	t.L2Rib = &NetworkInstance_Fdb_L2Rib{}
	return t.L2Rib
}

// GetOrCreateMacMobility retrieves the value of the MacMobility field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacMobility() *NetworkInstance_Fdb_MacMobility {
	if t.MacMobility != nil {
		return t.MacMobility
	}
	t.MacMobility = &NetworkInstance_Fdb_MacMobility{}
	return t.MacMobility
}

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacTable() *NetworkInstance_Fdb_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_MacTable{}
	return t.MacTable
}

// GetOrCreateNdProxy retrieves the value of the NdProxy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateNdProxy() *NetworkInstance_Fdb_NdProxy {
	if t.NdProxy != nil {
		return t.NdProxy
	}
	t.NdProxy = &NetworkInstance_Fdb_NdProxy{}
	return t.NdProxy
}

// GetArpProxy returns the value of the ArpProxy struct pointer
// from NetworkInstance_Fdb. If the receiver or the field ArpProxy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetArpProxy() *NetworkInstance_Fdb_ArpProxy {
	if t != nil && t.ArpProxy != nil {
		return t.ArpProxy
	}
	return nil
}

// GetL2Rib returns the value of the L2Rib struct pointer
// from NetworkInstance_Fdb. If the receiver or the field L2Rib is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetL2Rib() *NetworkInstance_Fdb_L2Rib {
	if t != nil && t.L2Rib != nil {
		return t.L2Rib
	}
	return nil
}

// GetMacMobility returns the value of the MacMobility struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacMobility is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacMobility() *NetworkInstance_Fdb_MacMobility {
	if t != nil && t.MacMobility != nil {
		return t.MacMobility
	}
	return nil
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacTable() *NetworkInstance_Fdb_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// GetNdProxy returns the value of the NdProxy struct pointer
// from NetworkInstance_Fdb. If the receiver or the field NdProxy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetNdProxy() *NetworkInstance_Fdb_NdProxy {
	if t != nil && t.NdProxy != nil {
		return t.NdProxy
	}
	return nil
}

// GetAnycastGatewayMac retrieves the value of the leaf AnycastGatewayMac from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGatewayMac is set, it can
// safely use t.GetAnycastGatewayMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGatewayMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetAnycastGatewayMac() string {
	if t == nil || t.AnycastGatewayMac == nil {
		return ""
	}
	return *t.AnycastGatewayMac
}

// GetFloodUnknownUnicastSupression retrieves the value of the leaf FloodUnknownUnicastSupression from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FloodUnknownUnicastSupression is set, it can
// safely use t.GetFloodUnknownUnicastSupression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FloodUnknownUnicastSupression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetFloodUnknownUnicastSupression() bool {
	if t == nil || t.FloodUnknownUnicastSupression == nil {
		return false
	}
	return *t.FloodUnknownUnicastSupression
}

// GetMacAgingTime retrieves the value of the leaf MacAgingTime from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAgingTime is set, it can
// safely use t.GetMacAgingTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAgingTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMacAgingTime() uint16 {
	if t == nil || t.MacAgingTime == nil {
		return 0
	}
	return *t.MacAgingTime
}

// GetMacLearning retrieves the value of the leaf MacLearning from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacLearning is set, it can
// safely use t.GetMacLearning() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacLearning == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMacLearning() bool {
	if t == nil || t.MacLearning == nil {
		return false
	}
	return *t.MacLearning
}

// GetMaximumEntries retrieves the value of the leaf MaximumEntries from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumEntries is set, it can
// safely use t.GetMaximumEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumEntries == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMaximumEntries() uint16 {
	if t == nil || t.MaximumEntries == nil {
		return 0
	}
	return *t.MaximumEntries
}

// SetAnycastGatewayMac sets the value of the leaf AnycastGatewayMac in the NetworkInstance_Fdb
// struct.
func (t *NetworkInstance_Fdb) SetAnycastGatewayMac(v string) {
	t.AnycastGatewayMac = &v
}

// SetFloodUnknownUnicastSupression sets the value of the leaf FloodUnknownUnicastSupression in the NetworkInstance_Fdb
// struct.
func (t *NetworkInstance_Fdb) SetFloodUnknownUnicastSupression(v bool) {
	t.FloodUnknownUnicastSupression = &v
}

// SetMacAgingTime sets the value of the leaf MacAgingTime in the NetworkInstance_Fdb
// struct.
func (t *NetworkInstance_Fdb) SetMacAgingTime(v uint16) {
	t.MacAgingTime = &v
}

// SetMacLearning sets the value of the leaf MacLearning in the NetworkInstance_Fdb
// struct.
func (t *NetworkInstance_Fdb) SetMacLearning(v bool) {
	t.MacLearning = &v
}

// SetMaximumEntries sets the value of the leaf MaximumEntries in the NetworkInstance_Fdb
// struct.
func (t *NetworkInstance_Fdb) SetMaximumEntries(v uint16) {
	t.MaximumEntries = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FloodUnknownUnicastSupression == nil {
		var v bool = false
		t.FloodUnknownUnicastSupression = &v
	}
	t.ArpProxy.PopulateDefaults()
	t.L2Rib.PopulateDefaults()
	t.MacMobility.PopulateDefaults()
	t.MacTable.PopulateDefaults()
	t.NdProxy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb.
func (*NetworkInstance_Fdb) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_ArpProxy represents the /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy YANG schema element.
type NetworkInstance_Fdb_ArpProxy struct {
	ArpSuppression               *bool   `path:"state/arp-suppression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/arp-suppression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DuplicateIpDetectionInterval *uint16 `path:"state/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable                       *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"state/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_ArpProxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_ArpProxy) IsYANGGoStruct() {}

// GetArpSuppression retrieves the value of the leaf ArpSuppression from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ArpSuppression is set, it can
// safely use t.GetArpSuppression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ArpSuppression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetArpSuppression() bool {
	if t == nil || t.ArpSuppression == nil {
		return false
	}
	return *t.ArpSuppression
}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// SetArpSuppression sets the value of the leaf ArpSuppression in the NetworkInstance_Fdb_ArpProxy
// struct.
func (t *NetworkInstance_Fdb_ArpProxy) SetArpSuppression(v bool) {
	t.ArpSuppression = &v
}

// SetDuplicateIpDetectionInterval sets the value of the leaf DuplicateIpDetectionInterval in the NetworkInstance_Fdb_ArpProxy
// struct.
func (t *NetworkInstance_Fdb_ArpProxy) SetDuplicateIpDetectionInterval(v uint16) {
	t.DuplicateIpDetectionInterval = &v
}

// SetEnable sets the value of the leaf Enable in the NetworkInstance_Fdb_ArpProxy
// struct.
func (t *NetworkInstance_Fdb_ArpProxy) SetEnable(v bool) {
	t.Enable = &v
}

// SetIpMobilityThreshold sets the value of the leaf IpMobilityThreshold in the NetworkInstance_Fdb_ArpProxy
// struct.
func (t *NetworkInstance_Fdb_ArpProxy) SetIpMobilityThreshold(v uint16) {
	t.IpMobilityThreshold = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_ArpProxy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_ArpProxy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ArpSuppression == nil {
		var v bool = false
		t.ArpSuppression = &v
	}
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_ArpProxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_ArpProxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_ArpProxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_ArpProxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_ArpProxy.
func (*NetworkInstance_Fdb_ArpProxy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib YANG schema element.
type NetworkInstance_Fdb_L2Rib struct {
	MacIpTable *NetworkInstance_Fdb_L2Rib_MacIpTable `path:"mac-ip-table" module:"openconfig-network-instance"`
	MacTable   *NetworkInstance_Fdb_L2Rib_MacTable   `path:"mac-table" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib) IsYANGGoStruct() {}

// GetOrCreateMacIpTable retrieves the value of the MacIpTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_L2Rib) GetOrCreateMacIpTable() *NetworkInstance_Fdb_L2Rib_MacIpTable {
	if t.MacIpTable != nil {
		return t.MacIpTable
	}
	t.MacIpTable = &NetworkInstance_Fdb_L2Rib_MacIpTable{}
	return t.MacIpTable
}

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_L2Rib) GetOrCreateMacTable() *NetworkInstance_Fdb_L2Rib_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_L2Rib_MacTable{}
	return t.MacTable
}

// GetMacIpTable returns the value of the MacIpTable struct pointer
// from NetworkInstance_Fdb_L2Rib. If the receiver or the field MacIpTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_L2Rib) GetMacIpTable() *NetworkInstance_Fdb_L2Rib_MacIpTable {
	if t != nil && t.MacIpTable != nil {
		return t.MacIpTable
	}
	return nil
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb_L2Rib. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_L2Rib) GetMacTable() *NetworkInstance_Fdb_L2Rib_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.MacIpTable.PopulateDefaults()
	t.MacTable.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib.
func (*NetworkInstance_Fdb_L2Rib) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable struct {
	Entry        map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop      map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop                                       `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup                                  `path:"next-hop-groups/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable) IsYANGGoStruct() {}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key represents the key for list Entry of element /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key struct {
	MacAddress string `path:"mac-address"`
	HostIp     string `path:"host-ip"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key key struct.
func (t NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"mac-address": t.MacAddress,
		"host-ip":     t.HostIp,
	}, nil
}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewEntry(MacAddress string, HostIp string) (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_Entry{
		MacAddress: &MacAddress,
		HostIp:     &HostIp,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameEntry(oldK, newK NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.HostIp = &newK.HostIp

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntryMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacIpTable.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateEntryMap() map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}
	return t.Entry
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateEntry(MacAddress string, HostIp string) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, HostIp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetEntry(MacAddress string, HostIp string) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteEntry(MacAddress string, HostIp string) {
	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendEntry(v *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key for MacAddress")
	}

	if v.HostIp == nil {
		return fmt.Errorf("invalid nil key for HostIp")
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: *v.MacAddress,
		HostIp:     *v.HostIp,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHopMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacIpTable.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateNextHopMap() map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}
	return t.NextHop
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewNextHopGroup(Id uint64) (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroupMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacIpTable.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateNextHopGroupMap() map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup {
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup)
	}
	return t.NextHopGroup
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetNextHopGroup(Id uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendNextHopGroup(v *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHopGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct {
	Evi        *uint32                                                                      `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	HostIp     *string                                                                      `path:"state/host-ip|host-ip" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"host-ip" shadow-module:"openconfig-network-instance"`
	L2Vni      *uint32                                                                      `path:"state/l2-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	L3Vni      *uint32                                                                      `path:"state/l3-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress *string                                                                      `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
	Producer   map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer `path:"producers/producer" module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan       *uint16                                                                      `path:"state/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) IsYANGGoStruct() {}

// NewProducer creates a new entry in the Producer list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) NewProducer(Producer E_Producer_Producer) (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}

	key := Producer

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Producer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Producer", key)
	}

	t.Producer[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer{
		Producer: Producer,
	}

	return t.Producer[key], nil
}

// RenameProducer renames an entry in the list Producer within
// the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) RenameProducer(oldK, newK E_Producer_Producer) error {
	if _, ok := t.Producer[newK]; ok {
		return fmt.Errorf("key %v already exists in Producer", newK)
	}

	e, ok := t.Producer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Producer", oldK)
	}
	e.Producer = newK

	t.Producer[newK] = e
	delete(t.Producer, oldK)
	return nil
}

// GetOrCreateProducerMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacIpTable_Entry.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetOrCreateProducerMap() map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}
	return t.Producer
}

// GetOrCreateProducer retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetOrCreateProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {

	key := Producer

	if v, ok := t.Producer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProducer(Producer)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProducer got unexpected error: %v", err))
	}
	return v
}

// GetProducer retrieves the value with the specified key from
// the Producer map field of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {

	if t == nil {
		return nil
	}

	key := Producer

	if lm, ok := t.Producer[key]; ok {
		return lm
	}
	return nil
}

// DeleteProducer deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) DeleteProducer(Producer E_Producer_Producer) {
	key := Producer

	delete(t.Producer, key)
}

// AppendProducer appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct to the
// list Producer of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) AppendProducer(v *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) error {
	key := v.Producer

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}

	if _, ok := t.Producer[key]; ok {
		return fmt.Errorf("duplicate key for list Producer %v", key)
	}

	t.Producer[key] = v
	return nil
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetHostIp retrieves the value of the leaf HostIp from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostIp is set, it can
// safely use t.GetHostIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetHostIp() string {
	if t == nil || t.HostIp == nil {
		return ""
	}
	return *t.HostIp
}

// GetL2Vni retrieves the value of the leaf L2Vni from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Vni is set, it can
// safely use t.GetL2Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetL2Vni() uint32 {
	if t == nil || t.L2Vni == nil {
		return 0
	}
	return *t.L2Vni
}

// GetL3Vni retrieves the value of the leaf L3Vni from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3Vni is set, it can
// safely use t.GetL3Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetL3Vni() uint32 {
	if t == nil || t.L3Vni == nil {
		return 0
	}
	return *t.L3Vni
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// SetEvi sets the value of the leaf Evi in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) SetEvi(v uint32) {
	t.Evi = &v
}

// SetHostIp sets the value of the leaf HostIp in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) SetHostIp(v string) {
	t.HostIp = &v
}

// SetL2Vni sets the value of the leaf L2Vni in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) SetL2Vni(v uint32) {
	t.L2Vni = &v
}

// SetL3Vni sets the value of the leaf L3Vni in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) SetL3Vni(v uint32) {
	t.L3Vni = &v
}

// SetMacAddress sets the value of the leaf MacAddress in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) SetMacAddress(v string) {
	t.MacAddress = &v
}

// SetVlan sets the value of the leaf Vlan in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) SetVlan(v uint16) {
	t.Vlan = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Producer {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.HostIp == nil {
		return nil, fmt.Errorf("nil value for key HostIp")
	}

	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"host-ip":     *t.HostIp,
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/entries/entry/producers/producer YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct {
	Esi           *string                  `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	MobilityState E_Producer_MobilityState `path:"state/mobility-state" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *uint64                  `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup  []uint64                 `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	Producer      E_Producer_Producer      `path:"state/producer|producer" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"producer" shadow-module:"openconfig-network-instance"`
	SeqNumber     *uint32                  `path:"state/seq-number" module:"openconfig-network-instance/openconfig-network-instance"`
	Sticky        *bool                    `path:"state/sticky" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) IsYANGGoStruct() {}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMobilityState retrieves the value of the leaf MobilityState from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MobilityState is set, it can
// safely use t.GetMobilityState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MobilityState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetMobilityState() E_Producer_MobilityState {
	if t == nil || t.MobilityState == 0 {
		return 0
	}
	return t.MobilityState
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetNextHop() uint64 {
	if t == nil || t.NextHop == nil {
		return 0
	}
	return *t.NextHop
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetNextHopGroup() []uint64 {
	if t == nil || t.NextHopGroup == nil {
		return nil
	}
	return t.NextHopGroup
}

// GetProducer retrieves the value of the leaf Producer from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Producer is set, it can
// safely use t.GetProducer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Producer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetProducer() E_Producer_Producer {
	if t == nil || t.Producer == 0 {
		return 0
	}
	return t.Producer
}

// GetSeqNumber retrieves the value of the leaf SeqNumber from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SeqNumber is set, it can
// safely use t.GetSeqNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SeqNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetSeqNumber() uint32 {
	if t == nil || t.SeqNumber == nil {
		return 0
	}
	return *t.SeqNumber
}

// GetSticky retrieves the value of the leaf Sticky from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sticky is set, it can
// safely use t.GetSticky() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sticky == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetSticky() bool {
	if t == nil || t.Sticky == nil {
		return false
	}
	return *t.Sticky
}

// SetEsi sets the value of the leaf Esi in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) SetEsi(v string) {
	t.Esi = &v
}

// SetMobilityState sets the value of the leaf MobilityState in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) SetMobilityState(v E_Producer_MobilityState) {
	t.MobilityState = v
}

// SetNextHop sets the value of the leaf NextHop in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) SetNextHop(v uint64) {
	t.NextHop = &v
}

// SetNextHopGroup sets the value of the leaf NextHopGroup in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) SetNextHopGroup(v []uint64) {
	t.NextHopGroup = v
}

// SetProducer sets the value of the leaf Producer in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) SetProducer(v E_Producer_Producer) {
	t.Producer = v
}

// SetSeqNumber sets the value of the leaf SeqNumber in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) SetSeqNumber(v uint32) {
	t.SeqNumber = &v
}

// SetSticky sets the value of the leaf Sticky in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) SetSticky(v bool) {
	t.Sticky = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"producer": t.Producer,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct {
	Esi          *string `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	Index        *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Label        *uint32 `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerIp       *string `path:"state/peer-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	Resolved     *bool   `path:"state/resolved" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) IsYANGGoStruct() {}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetLabel() uint32 {
	if t == nil || t.Label == nil {
		return 0
	}
	return *t.Label
}

// GetPeerIp retrieves the value of the leaf PeerIp from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIp is set, it can
// safely use t.GetPeerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetPeerIp() string {
	if t == nil || t.PeerIp == nil {
		return ""
	}
	return *t.PeerIp
}

// GetResolved retrieves the value of the leaf Resolved from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Resolved is set, it can
// safely use t.GetResolved() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Resolved == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetResolved() bool {
	if t == nil || t.Resolved == nil {
		return false
	}
	return *t.Resolved
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetEsi sets the value of the leaf Esi in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) SetEsi(v string) {
	t.Esi = &v
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) SetIndex(v uint64) {
	t.Index = &v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) SetInterface(v string) {
	t.Interface = &v
}

// SetLabel sets the value of the leaf Label in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) SetLabel(v uint32) {
	t.Label = &v
}

// SetPeerIp sets the value of the leaf PeerIp in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) SetPeerIp(v string) {
	t.PeerIp = &v
}

// SetResolved sets the value of the leaf Resolved in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) SetResolved(v bool) {
	t.Resolved = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/next-hop-groups/next-hop-group YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct {
	Esi     *string                                                               `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	Id      *uint64                                                               `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	NextHop map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Type    E_NextHopGroup_Type                                                   `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) IsYANGGoStruct() {}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHopMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetOrCreateNextHopMap() map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop {
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop)
	}
	return t.NextHop
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetType() E_NextHopGroup_Type {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetEsi sets the value of the leaf Esi in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) SetEsi(v string) {
	t.Esi = &v
}

// SetId sets the value of the leaf Id in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) SetId(v uint64) {
	t.Id = &v
}

// SetType sets the value of the leaf Type in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) SetType(v E_NextHopGroup_Type) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/next-hop-groups/next-hop-group/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop struct {
	Index *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) SetIndex(v uint64) {
	t.Index = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable struct {
	Entry        map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry        `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop      map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop      `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup `path:"next-hop-groups/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewEntry(MacAddress string) (*NetworkInstance_Fdb_L2Rib_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_L2Rib_MacTable_Entry{
		MacAddress: &MacAddress,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameEntry(oldK, newK string) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntryMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacTable.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateEntryMap() map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry {
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}
	return t.Entry
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateEntry(MacAddress string) *NetworkInstance_Fdb_L2Rib_MacTable_Entry {

	key := MacAddress

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetEntry(MacAddress string) *NetworkInstance_Fdb_L2Rib_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteEntry(MacAddress string) {
	key := MacAddress

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendEntry(v *NetworkInstance_Fdb_L2Rib_MacTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key received for MacAddress")
	}

	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHopMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacTable.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateNextHopMap() map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop {
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}
	return t.NextHop
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewNextHopGroup(Id uint64) (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroupMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacTable.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateNextHopGroupMap() map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup {
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup)
	}
	return t.NextHopGroup
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetNextHopGroup(Id uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendNextHopGroup(v *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHopGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable.
func (*NetworkInstance_Fdb_L2Rib_MacTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_Entry struct {
	Evi        *uint32                                                                    `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	L2Vni      *uint32                                                                    `path:"state/l2-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress *string                                                                    `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
	Producer   map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer `path:"producers/producer" module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan       *uint16                                                                    `path:"state/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry) IsYANGGoStruct() {}

// NewProducer creates a new entry in the Producer list of the
// NetworkInstance_Fdb_L2Rib_MacTable_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) NewProducer(Producer E_Producer_Producer) (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}

	key := Producer

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Producer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Producer", key)
	}

	t.Producer[key] = &NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer{
		Producer: Producer,
	}

	return t.Producer[key], nil
}

// RenameProducer renames an entry in the list Producer within
// the NetworkInstance_Fdb_L2Rib_MacTable_Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) RenameProducer(oldK, newK E_Producer_Producer) error {
	if _, ok := t.Producer[newK]; ok {
		return fmt.Errorf("key %v already exists in Producer", newK)
	}

	e, ok := t.Producer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Producer", oldK)
	}
	e.Producer = newK

	t.Producer[newK] = e
	delete(t.Producer, oldK)
	return nil
}

// GetOrCreateProducerMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacTable_Entry.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetOrCreateProducerMap() map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}
	return t.Producer
}

// GetOrCreateProducer retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetOrCreateProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {

	key := Producer

	if v, ok := t.Producer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProducer(Producer)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProducer got unexpected error: %v", err))
	}
	return v
}

// GetProducer retrieves the value with the specified key from
// the Producer map field of NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {

	if t == nil {
		return nil
	}

	key := Producer

	if lm, ok := t.Producer[key]; ok {
		return lm
	}
	return nil
}

// DeleteProducer deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_Entry. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) DeleteProducer(Producer E_Producer_Producer) {
	key := Producer

	delete(t.Producer, key)
}

// AppendProducer appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct to the
// list Producer of NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) AppendProducer(v *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) error {
	key := v.Producer

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}

	if _, ok := t.Producer[key]; ok {
		return fmt.Errorf("duplicate key for list Producer %v", key)
	}

	t.Producer[key] = v
	return nil
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetL2Vni retrieves the value of the leaf L2Vni from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Vni is set, it can
// safely use t.GetL2Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetL2Vni() uint32 {
	if t == nil || t.L2Vni == nil {
		return 0
	}
	return *t.L2Vni
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// SetEvi sets the value of the leaf Evi in the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) SetEvi(v uint32) {
	t.Evi = &v
}

// SetL2Vni sets the value of the leaf L2Vni in the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) SetL2Vni(v uint32) {
	t.L2Vni = &v
}

// SetMacAddress sets the value of the leaf MacAddress in the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) SetMacAddress(v string) {
	t.MacAddress = &v
}

// SetVlan sets the value of the leaf Vlan in the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) SetVlan(v uint16) {
	t.Vlan = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Producer {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_Entry.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/entries/entry/producers/producer YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct {
	DerivedFromMacIp *bool                    `path:"state/derived-from-mac-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	DirectlyReceived *bool                    `path:"state/directly-received" module:"openconfig-network-instance/openconfig-network-instance"`
	Esi              *string                  `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	MobilityState    E_Producer_MobilityState `path:"state/mobility-state" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop          *uint64                  `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup     []uint64                 `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	Producer         E_Producer_Producer      `path:"state/producer|producer" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"producer" shadow-module:"openconfig-network-instance"`
	SeqNumber        *uint32                  `path:"state/seq-number" module:"openconfig-network-instance/openconfig-network-instance"`
	Sticky           *bool                    `path:"state/sticky" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) IsYANGGoStruct() {}

// GetDerivedFromMacIp retrieves the value of the leaf DerivedFromMacIp from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DerivedFromMacIp is set, it can
// safely use t.GetDerivedFromMacIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DerivedFromMacIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetDerivedFromMacIp() bool {
	if t == nil || t.DerivedFromMacIp == nil {
		return false
	}
	return *t.DerivedFromMacIp
}

// GetDirectlyReceived retrieves the value of the leaf DirectlyReceived from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DirectlyReceived is set, it can
// safely use t.GetDirectlyReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DirectlyReceived == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetDirectlyReceived() bool {
	if t == nil || t.DirectlyReceived == nil {
		return false
	}
	return *t.DirectlyReceived
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMobilityState retrieves the value of the leaf MobilityState from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MobilityState is set, it can
// safely use t.GetMobilityState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MobilityState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetMobilityState() E_Producer_MobilityState {
	if t == nil || t.MobilityState == 0 {
		return 0
	}
	return t.MobilityState
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetNextHop() uint64 {
	if t == nil || t.NextHop == nil {
		return 0
	}
	return *t.NextHop
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetNextHopGroup() []uint64 {
	if t == nil || t.NextHopGroup == nil {
		return nil
	}
	return t.NextHopGroup
}

// GetProducer retrieves the value of the leaf Producer from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Producer is set, it can
// safely use t.GetProducer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Producer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetProducer() E_Producer_Producer {
	if t == nil || t.Producer == 0 {
		return 0
	}
	return t.Producer
}

// GetSeqNumber retrieves the value of the leaf SeqNumber from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SeqNumber is set, it can
// safely use t.GetSeqNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SeqNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetSeqNumber() uint32 {
	if t == nil || t.SeqNumber == nil {
		return 0
	}
	return *t.SeqNumber
}

// GetSticky retrieves the value of the leaf Sticky from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sticky is set, it can
// safely use t.GetSticky() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sticky == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetSticky() bool {
	if t == nil || t.Sticky == nil {
		return false
	}
	return *t.Sticky
}

// SetDerivedFromMacIp sets the value of the leaf DerivedFromMacIp in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetDerivedFromMacIp(v bool) {
	t.DerivedFromMacIp = &v
}

// SetDirectlyReceived sets the value of the leaf DirectlyReceived in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetDirectlyReceived(v bool) {
	t.DirectlyReceived = &v
}

// SetEsi sets the value of the leaf Esi in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetEsi(v string) {
	t.Esi = &v
}

// SetMobilityState sets the value of the leaf MobilityState in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetMobilityState(v E_Producer_MobilityState) {
	t.MobilityState = v
}

// SetNextHop sets the value of the leaf NextHop in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetNextHop(v uint64) {
	t.NextHop = &v
}

// SetNextHopGroup sets the value of the leaf NextHopGroup in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetNextHopGroup(v []uint64) {
	t.NextHopGroup = v
}

// SetProducer sets the value of the leaf Producer in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetProducer(v E_Producer_Producer) {
	t.Producer = v
}

// SetSeqNumber sets the value of the leaf SeqNumber in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetSeqNumber(v uint32) {
	t.SeqNumber = &v
}

// SetSticky sets the value of the leaf Sticky in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) SetSticky(v bool) {
	t.Sticky = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"producer": t.Producer,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct {
	Esi          *string `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	Index        *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Label        *uint32 `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerIp       *string `path:"state/peer-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	Resolved     *bool   `path:"state/resolved" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop) IsYANGGoStruct() {}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetLabel() uint32 {
	if t == nil || t.Label == nil {
		return 0
	}
	return *t.Label
}

// GetPeerIp retrieves the value of the leaf PeerIp from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIp is set, it can
// safely use t.GetPeerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetPeerIp() string {
	if t == nil || t.PeerIp == nil {
		return ""
	}
	return *t.PeerIp
}

// GetResolved retrieves the value of the leaf Resolved from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Resolved is set, it can
// safely use t.GetResolved() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Resolved == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetResolved() bool {
	if t == nil || t.Resolved == nil {
		return false
	}
	return *t.Resolved
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetEsi sets the value of the leaf Esi in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) SetEsi(v string) {
	t.Esi = &v
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) SetIndex(v uint64) {
	t.Index = &v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) SetInterface(v string) {
	t.Interface = &v
}

// SetLabel sets the value of the leaf Label in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) SetLabel(v uint32) {
	t.Label = &v
}

// SetPeerIp sets the value of the leaf PeerIp in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) SetPeerIp(v string) {
	t.PeerIp = &v
}

// SetResolved sets the value of the leaf Resolved in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) SetResolved(v bool) {
	t.Resolved = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/next-hop-groups/next-hop-group YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct {
	Esi     *string                                                             `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	Id      *uint64                                                             `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	NextHop map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Type    E_NextHopGroup_Type                                                 `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) IsYANGGoStruct() {}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHopMap returns the list (map) from NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetOrCreateNextHopMap() map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop {
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop)
	}
	return t.NextHop
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetType() E_NextHopGroup_Type {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetEsi sets the value of the leaf Esi in the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) SetEsi(v string) {
	t.Esi = &v
}

// SetId sets the value of the leaf Id in the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) SetId(v uint64) {
	t.Id = &v
}

// SetType sets the value of the leaf Type in the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) SetType(v E_NextHopGroup_Type) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/next-hop-groups/next-hop-group/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop struct {
	Index *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop
// struct.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) SetIndex(v uint64) {
	t.Index = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacMobility represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility YANG schema element.
type NetworkInstance_Fdb_MacMobility struct {
	DuplicateIpDetectionInterval *uint16 `path:"state/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"state/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobility                  *bool   `path:"state/mac-mobility" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-mobility" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobilityThreshold         *uint8  `path:"state/mac-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobilityWindow            *uint16 `path:"state/mac-mobility-window" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-mobility-window" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacMobility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacMobility) IsYANGGoStruct() {}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// GetMacMobility retrieves the value of the leaf MacMobility from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobility is set, it can
// safely use t.GetMacMobility() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobility == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobility() bool {
	if t == nil || t.MacMobility == nil {
		return false
	}
	return *t.MacMobility
}

// GetMacMobilityThreshold retrieves the value of the leaf MacMobilityThreshold from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobilityThreshold is set, it can
// safely use t.GetMacMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobilityThreshold() uint8 {
	if t == nil || t.MacMobilityThreshold == nil {
		return 5
	}
	return *t.MacMobilityThreshold
}

// GetMacMobilityWindow retrieves the value of the leaf MacMobilityWindow from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobilityWindow is set, it can
// safely use t.GetMacMobilityWindow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobilityWindow == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobilityWindow() uint16 {
	if t == nil || t.MacMobilityWindow == nil {
		return 180
	}
	return *t.MacMobilityWindow
}

// SetDuplicateIpDetectionInterval sets the value of the leaf DuplicateIpDetectionInterval in the NetworkInstance_Fdb_MacMobility
// struct.
func (t *NetworkInstance_Fdb_MacMobility) SetDuplicateIpDetectionInterval(v uint16) {
	t.DuplicateIpDetectionInterval = &v
}

// SetIpMobilityThreshold sets the value of the leaf IpMobilityThreshold in the NetworkInstance_Fdb_MacMobility
// struct.
func (t *NetworkInstance_Fdb_MacMobility) SetIpMobilityThreshold(v uint16) {
	t.IpMobilityThreshold = &v
}

// SetMacMobility sets the value of the leaf MacMobility in the NetworkInstance_Fdb_MacMobility
// struct.
func (t *NetworkInstance_Fdb_MacMobility) SetMacMobility(v bool) {
	t.MacMobility = &v
}

// SetMacMobilityThreshold sets the value of the leaf MacMobilityThreshold in the NetworkInstance_Fdb_MacMobility
// struct.
func (t *NetworkInstance_Fdb_MacMobility) SetMacMobilityThreshold(v uint8) {
	t.MacMobilityThreshold = &v
}

// SetMacMobilityWindow sets the value of the leaf MacMobilityWindow in the NetworkInstance_Fdb_MacMobility
// struct.
func (t *NetworkInstance_Fdb_MacMobility) SetMacMobilityWindow(v uint16) {
	t.MacMobilityWindow = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacMobility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacMobility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MacMobilityThreshold == nil {
		var v uint8 = 5
		t.MacMobilityThreshold = &v
	}
	if t.MacMobilityWindow == nil {
		var v uint16 = 180
		t.MacMobilityWindow = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacMobility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacMobility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacMobility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacMobility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacMobility.
func (*NetworkInstance_Fdb_MacMobility) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table YANG schema element.
type NetworkInstance_Fdb_MacTable struct {
	Entry map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable) IsYANGGoStruct() {}

// NetworkInstance_Fdb_MacTable_Entry_Key represents the key for list Entry of element /openconfig-network-instance/network-instances/network-instance/fdb/mac-table.
type NetworkInstance_Fdb_MacTable_Entry_Key struct {
	MacAddress string `path:"mac-address"`
	Vlan       uint16 `path:"vlan"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Fdb_MacTable_Entry_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Fdb_MacTable_Entry_Key key struct.
func (t NetworkInstance_Fdb_MacTable_Entry_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"mac-address": t.MacAddress,
		"vlan":        t.Vlan,
	}, nil
}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_MacTable) NewEntry(MacAddress string, Vlan uint16) (*NetworkInstance_Fdb_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_MacTable_Entry{
		MacAddress: &MacAddress,
		Vlan:       &Vlan,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_MacTable) RenameEntry(oldK, newK NetworkInstance_Fdb_MacTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.Vlan = &newK.Vlan

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntryMap returns the list (map) from NetworkInstance_Fdb_MacTable.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Fdb_MacTable) GetOrCreateEntryMap() map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry {
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}
	return t.Entry
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_MacTable) GetOrCreateEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, Vlan)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_MacTable) GetEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_MacTable) DeleteEntry(MacAddress string, Vlan uint16) {
	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_MacTable) AppendEntry(v *NetworkInstance_Fdb_MacTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key for MacAddress")
	}

	if v.Vlan == nil {
		return fmt.Errorf("invalid nil key for Vlan")
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: *v.MacAddress,
		Vlan:       *v.Vlan,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable.
func (*NetworkInstance_Fdb_MacTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry struct {
	Age        *uint64                                       `path:"state/age" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryType  E_Entry_EntryType                             `path:"state/entry-type" module:"openconfig-network-instance/openconfig-network-instance"`
	Evi        *uint32                                       `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	Interface  *NetworkInstance_Fdb_MacTable_Entry_Interface `path:"interface" module:"openconfig-network-instance"`
	MacAddress *string                                       `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/mac-address|mac-address" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Vlan       *uint16                                       `path:"state/vlan|vlan" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/vlan|vlan" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry) IsYANGGoStruct() {}

// GetOrCreateInterface retrieves the value of the Interface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetOrCreateInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t.Interface != nil {
		return t.Interface
	}
	t.Interface = &NetworkInstance_Fdb_MacTable_Entry_Interface{}
	return t.Interface
}

// GetInterface returns the value of the Interface struct pointer
// from NetworkInstance_Fdb_MacTable_Entry. If the receiver or the field Interface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t != nil && t.Interface != nil {
		return t.Interface
	}
	return nil
}

// GetAge retrieves the value of the leaf Age from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Age is set, it can
// safely use t.GetAge() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Age == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetAge() uint64 {
	if t == nil || t.Age == nil {
		return 0
	}
	return *t.Age
}

// GetEntryType retrieves the value of the leaf EntryType from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryType is set, it can
// safely use t.GetEntryType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetEntryType() E_Entry_EntryType {
	if t == nil || t.EntryType == 0 {
		return 0
	}
	return t.EntryType
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// SetAge sets the value of the leaf Age in the NetworkInstance_Fdb_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_MacTable_Entry) SetAge(v uint64) {
	t.Age = &v
}

// SetEntryType sets the value of the leaf EntryType in the NetworkInstance_Fdb_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_MacTable_Entry) SetEntryType(v E_Entry_EntryType) {
	t.EntryType = v
}

// SetEvi sets the value of the leaf Evi in the NetworkInstance_Fdb_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_MacTable_Entry) SetEvi(v uint32) {
	t.Evi = &v
}

// SetMacAddress sets the value of the leaf MacAddress in the NetworkInstance_Fdb_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_MacTable_Entry) SetMacAddress(v string) {
	t.MacAddress = &v
}

// SetVlan sets the value of the leaf Vlan in the NetworkInstance_Fdb_MacTable_Entry
// struct.
func (t *NetworkInstance_Fdb_MacTable_Entry) SetVlan(v uint16) {
	t.Vlan = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Interface.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	if t.Vlan == nil {
		return nil, fmt.Errorf("nil value for key Vlan")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
		"vlan":        *t.Vlan,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry.
func (*NetworkInstance_Fdb_MacTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry_Interface represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry_Interface struct {
	InterfaceRef *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Fdb_MacTable_Entry_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry_Interface.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_NdProxy represents the /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy YANG schema element.
type NetworkInstance_Fdb_NdProxy struct {
	DuplicateIpDetectionInterval *uint16 `path:"state/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable                       *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"state/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NdSuppression                *bool   `path:"state/nd-suppression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/nd-suppression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_NdProxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_NdProxy) IsYANGGoStruct() {}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// GetNdSuppression retrieves the value of the leaf NdSuppression from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NdSuppression is set, it can
// safely use t.GetNdSuppression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NdSuppression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetNdSuppression() bool {
	if t == nil || t.NdSuppression == nil {
		return false
	}
	return *t.NdSuppression
}

// SetDuplicateIpDetectionInterval sets the value of the leaf DuplicateIpDetectionInterval in the NetworkInstance_Fdb_NdProxy
// struct.
func (t *NetworkInstance_Fdb_NdProxy) SetDuplicateIpDetectionInterval(v uint16) {
	t.DuplicateIpDetectionInterval = &v
}

// SetEnable sets the value of the leaf Enable in the NetworkInstance_Fdb_NdProxy
// struct.
func (t *NetworkInstance_Fdb_NdProxy) SetEnable(v bool) {
	t.Enable = &v
}

// SetIpMobilityThreshold sets the value of the leaf IpMobilityThreshold in the NetworkInstance_Fdb_NdProxy
// struct.
func (t *NetworkInstance_Fdb_NdProxy) SetIpMobilityThreshold(v uint16) {
	t.IpMobilityThreshold = &v
}

// SetNdSuppression sets the value of the leaf NdSuppression in the NetworkInstance_Fdb_NdProxy
// struct.
func (t *NetworkInstance_Fdb_NdProxy) SetNdSuppression(v bool) {
	t.NdSuppression = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_NdProxy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_NdProxy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
	if t.NdSuppression == nil {
		var v bool = false
		t.NdSuppression = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_NdProxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_NdProxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_NdProxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_NdProxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_NdProxy.
func (*NetworkInstance_Fdb_NdProxy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies YANG schema element.
type NetworkInstance_InterInstancePolicies struct {
	ApplyPolicy        *NetworkInstance_InterInstancePolicies_ApplyPolicy        `path:"apply-policy" module:"openconfig-network-instance"`
	ImportExportPolicy *NetworkInstance_InterInstancePolicies_ImportExportPolicy `path:"import-export-policy" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies) IsYANGGoStruct() {}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateImportExportPolicy retrieves the value of the ImportExportPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateImportExportPolicy() *NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	if t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	t.ImportExportPolicy = &NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
	return t.ImportExportPolicy
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetImportExportPolicy returns the value of the ImportExportPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ImportExportPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetImportExportPolicy() *NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	if t != nil && t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ApplyPolicy.PopulateDefaults()
	t.ImportExportPolicy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies.
func (*NetworkInstance_InterInstancePolicies) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies_ApplyPolicy represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy YANG schema element.
type NetworkInstance_InterInstancePolicies_ApplyPolicy struct {
	DefaultExportPolicy E_RoutingPolicy_DefaultPolicyType `path:"state/default-export-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/default-export-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DefaultImportPolicy E_RoutingPolicy_DefaultPolicyType `path:"state/default-import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/default-import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ExportPolicy        []string                          `path:"state/export-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/export-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportPolicy        []string                          `path:"state/import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies_ApplyPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies_ApplyPolicy) IsYANGGoStruct() {}

// GetDefaultExportPolicy retrieves the value of the leaf DefaultExportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultExportPolicy is set, it can
// safely use t.GetDefaultExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultExportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetDefaultExportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultExportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultExportPolicy
}

// GetDefaultImportPolicy retrieves the value of the leaf DefaultImportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultImportPolicy is set, it can
// safely use t.GetDefaultImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetDefaultImportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultImportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultImportPolicy
}

// GetExportPolicy retrieves the value of the leaf ExportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportPolicy is set, it can
// safely use t.GetExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetExportPolicy() []string {
	if t == nil || t.ExportPolicy == nil {
		return nil
	}
	return t.ExportPolicy
}

// GetImportPolicy retrieves the value of the leaf ImportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportPolicy is set, it can
// safely use t.GetImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetImportPolicy() []string {
	if t == nil || t.ImportPolicy == nil {
		return nil
	}
	return t.ImportPolicy
}

// SetDefaultExportPolicy sets the value of the leaf DefaultExportPolicy in the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) SetDefaultExportPolicy(v E_RoutingPolicy_DefaultPolicyType) {
	t.DefaultExportPolicy = v
}

// SetDefaultImportPolicy sets the value of the leaf DefaultImportPolicy in the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) SetDefaultImportPolicy(v E_RoutingPolicy_DefaultPolicyType) {
	t.DefaultImportPolicy = v
}

// SetExportPolicy sets the value of the leaf ExportPolicy in the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) SetExportPolicy(v []string) {
	t.ExportPolicy = v
}

// SetImportPolicy sets the value of the leaf ImportPolicy in the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) SetImportPolicy(v []string) {
	t.ImportPolicy = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies_ApplyPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DefaultExportPolicy == 0 {
		t.DefaultExportPolicy = RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	if t.DefaultImportPolicy == 0 {
		t.DefaultImportPolicy = RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies_ApplyPolicy.
func (*NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies_ImportExportPolicy represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy YANG schema element.
type NetworkInstance_InterInstancePolicies_ImportExportPolicy struct {
	ExportRouteTarget []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union `path:"state/export-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/export-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportRouteTarget []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union `path:"state/import-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/import-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies_ImportExportPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies_ImportExportPolicy) IsYANGGoStruct() {}

// GetExportRouteTarget retrieves the value of the leaf ExportRouteTarget from the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportRouteTarget is set, it can
// safely use t.GetExportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) GetExportRouteTarget() []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union {
	if t == nil || t.ExportRouteTarget == nil {
		return nil
	}
	return t.ExportRouteTarget
}

// GetImportRouteTarget retrieves the value of the leaf ImportRouteTarget from the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportRouteTarget is set, it can
// safely use t.GetImportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) GetImportRouteTarget() []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union {
	if t == nil || t.ImportRouteTarget == nil {
		return nil
	}
	return t.ImportRouteTarget
}

// SetExportRouteTarget sets the value of the leaf ExportRouteTarget in the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) SetExportRouteTarget(v []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union) {
	t.ExportRouteTarget = v
}

// SetImportRouteTarget sets the value of the leaf ImportRouteTarget in the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) SetImportRouteTarget(v []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union) {
	t.ImportRouteTarget = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ImportExportPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies_ImportExportPolicy.
func (*NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Interface represents the /openconfig-network-instance/network-instances/network-instance/interfaces/interface YANG schema element.
type NetworkInstance_Interface struct {
	AssociatedAddressFamilies []E_Types_ADDRESS_FAMILY      `path:"state/associated-address-families" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/associated-address-families" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Id                        *string                       `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/id|id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Interface                 *string                       `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IrbAnycastGateway         E_Interface_IrbAnycastGateway `path:"state/irb-anycast-gateway" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/irb-anycast-gateway" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacPinning                *bool                         `path:"state/mac-pinning" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-pinning" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface              *uint32                       `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Interface) IsYANGGoStruct() {}

// GetAssociatedAddressFamilies retrieves the value of the leaf AssociatedAddressFamilies from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedAddressFamilies is set, it can
// safely use t.GetAssociatedAddressFamilies() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedAddressFamilies == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetAssociatedAddressFamilies() []E_Types_ADDRESS_FAMILY {
	if t == nil || t.AssociatedAddressFamilies == nil {
		return nil
	}
	return t.AssociatedAddressFamilies
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetIrbAnycastGateway retrieves the value of the leaf IrbAnycastGateway from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IrbAnycastGateway is set, it can
// safely use t.GetIrbAnycastGateway() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IrbAnycastGateway == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetIrbAnycastGateway() E_Interface_IrbAnycastGateway {
	if t == nil || t.IrbAnycastGateway == 0 {
		return 0
	}
	return t.IrbAnycastGateway
}

// GetMacPinning retrieves the value of the leaf MacPinning from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacPinning is set, it can
// safely use t.GetMacPinning() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacPinning == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetMacPinning() bool {
	if t == nil || t.MacPinning == nil {
		return false
	}
	return *t.MacPinning
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetAssociatedAddressFamilies sets the value of the leaf AssociatedAddressFamilies in the NetworkInstance_Interface
// struct.
func (t *NetworkInstance_Interface) SetAssociatedAddressFamilies(v []E_Types_ADDRESS_FAMILY) {
	t.AssociatedAddressFamilies = v
}

// SetId sets the value of the leaf Id in the NetworkInstance_Interface
// struct.
func (t *NetworkInstance_Interface) SetId(v string) {
	t.Id = &v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Interface
// struct.
func (t *NetworkInstance_Interface) SetInterface(v string) {
	t.Interface = &v
}

// SetIrbAnycastGateway sets the value of the leaf IrbAnycastGateway in the NetworkInstance_Interface
// struct.
func (t *NetworkInstance_Interface) SetIrbAnycastGateway(v E_Interface_IrbAnycastGateway) {
	t.IrbAnycastGateway = v
}

// SetMacPinning sets the value of the leaf MacPinning in the NetworkInstance_Interface
// struct.
func (t *NetworkInstance_Interface) SetMacPinning(v bool) {
	t.MacPinning = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Interface
// struct.
func (t *NetworkInstance_Interface) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Interface.
func (*NetworkInstance_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls represents the /openconfig-network-instance/network-instances/network-instance/mpls YANG schema element.
type NetworkInstance_Mpls struct {
	Global             *NetworkInstance_Mpls_Global               `path:"global" module:"openconfig-network-instance"`
	Interface          map[string]*NetworkInstance_Mpls_Interface `path:"te-interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Lsps               *NetworkInstance_Mpls_Lsps                 `path:"lsps" module:"openconfig-network-instance"`
	SignalingProtocols *NetworkInstance_Mpls_SignalingProtocols   `path:"signaling-protocols" module:"openconfig-network-instance"`
	TeGlobalAttributes *NetworkInstance_Mpls_TeGlobalAttributes   `path:"te-global-attributes" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from NetworkInstance_Mpls.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls) GetOrCreateInterfaceMap() map[string]*NetworkInstance_Mpls_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Interface struct to the
// list Interface of NetworkInstance_Mpls. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls) AppendInterface(v *NetworkInstance_Mpls_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateGlobal() *NetworkInstance_Mpls_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_Global{}
	return t.Global
}

// GetOrCreateLsps retrieves the value of the Lsps field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateLsps() *NetworkInstance_Mpls_Lsps {
	if t.Lsps != nil {
		return t.Lsps
	}
	t.Lsps = &NetworkInstance_Mpls_Lsps{}
	return t.Lsps
}

// GetOrCreateSignalingProtocols retrieves the value of the SignalingProtocols field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	t.SignalingProtocols = &NetworkInstance_Mpls_SignalingProtocols{}
	return t.SignalingProtocols
}

// GetOrCreateTeGlobalAttributes retrieves the value of the TeGlobalAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	t.TeGlobalAttributes = &NetworkInstance_Mpls_TeGlobalAttributes{}
	return t.TeGlobalAttributes
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetGlobal() *NetworkInstance_Mpls_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetLsps returns the value of the Lsps struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Lsps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetLsps() *NetworkInstance_Mpls_Lsps {
	if t != nil && t.Lsps != nil {
		return t.Lsps
	}
	return nil
}

// GetSignalingProtocols returns the value of the SignalingProtocols struct pointer
// from NetworkInstance_Mpls. If the receiver or the field SignalingProtocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t != nil && t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	return nil
}

// GetTeGlobalAttributes returns the value of the TeGlobalAttributes struct pointer
// from NetworkInstance_Mpls. If the receiver or the field TeGlobalAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t != nil && t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	t.Lsps.PopulateDefaults()
	t.SignalingProtocols.PopulateDefaults()
	t.TeGlobalAttributes.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls.
func (*NetworkInstance_Mpls) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global represents the /openconfig-network-instance/network-instances/network-instance/mpls/global YANG schema element.
type NetworkInstance_Mpls_Global struct {
	Interface          map[string]*NetworkInstance_Mpls_Global_Interface          `path:"interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	NullLabel          E_MplsTypes_NULL_LABEL_TYPE                                `path:"state/null-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/null-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PwEncapsulation    E_MplsTypes_PSEUDOWIRE_ENCAPSULATION                       `path:"state/pw-encapsulation" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/pw-encapsulation" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReservedLabelBlock map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock `path:"reserved-label-blocks/reserved-label-block" module:"openconfig-network-instance/openconfig-network-instance"`
	TtlPropagation     *bool                                                      `path:"state/ttl-propagation" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ttl-propagation" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Global_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Global_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from NetworkInstance_Mpls_Global.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Global) GetOrCreateInterfaceMap() map[string]*NetworkInstance_Mpls_Global_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Global_Interface struct to the
// list Interface of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendInterface(v *NetworkInstance_Mpls_Global_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewReservedLabelBlock creates a new entry in the ReservedLabelBlock list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewReservedLabelBlock(LocalId string) (*NetworkInstance_Mpls_Global_ReservedLabelBlock, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ReservedLabelBlock[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ReservedLabelBlock", key)
	}

	t.ReservedLabelBlock[key] = &NetworkInstance_Mpls_Global_ReservedLabelBlock{
		LocalId: &LocalId,
	}

	return t.ReservedLabelBlock[key], nil
}

// RenameReservedLabelBlock renames an entry in the list ReservedLabelBlock within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameReservedLabelBlock(oldK, newK string) error {
	if _, ok := t.ReservedLabelBlock[newK]; ok {
		return fmt.Errorf("key %v already exists in ReservedLabelBlock", newK)
	}

	e, ok := t.ReservedLabelBlock[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ReservedLabelBlock", oldK)
	}
	e.LocalId = &newK

	t.ReservedLabelBlock[newK] = e
	delete(t.ReservedLabelBlock, oldK)
	return nil
}

// GetOrCreateReservedLabelBlockMap returns the list (map) from NetworkInstance_Mpls_Global.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Global) GetOrCreateReservedLabelBlockMap() map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock {
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}
	return t.ReservedLabelBlock
}

// GetOrCreateReservedLabelBlock retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	key := LocalId

	if v, ok := t.ReservedLabelBlock[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewReservedLabelBlock(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateReservedLabelBlock got unexpected error: %v", err))
	}
	return v
}

// GetReservedLabelBlock retrieves the value with the specified key from
// the ReservedLabelBlock map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.ReservedLabelBlock[key]; ok {
		return lm
	}
	return nil
}

// DeleteReservedLabelBlock deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteReservedLabelBlock(LocalId string) {
	key := LocalId

	delete(t.ReservedLabelBlock, key)
}

// AppendReservedLabelBlock appends the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock struct to the
// list ReservedLabelBlock of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendReservedLabelBlock(v *NetworkInstance_Mpls_Global_ReservedLabelBlock) error {
	if v.LocalId == nil {
		return fmt.Errorf("invalid nil key received for LocalId")
	}

	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	if _, ok := t.ReservedLabelBlock[key]; ok {
		return fmt.Errorf("duplicate key for list ReservedLabelBlock %v", key)
	}

	t.ReservedLabelBlock[key] = v
	return nil
}

// GetNullLabel retrieves the value of the leaf NullLabel from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NullLabel is set, it can
// safely use t.GetNullLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NullLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetNullLabel() E_MplsTypes_NULL_LABEL_TYPE {
	if t == nil || t.NullLabel == 0 {
		return MplsTypes_NULL_LABEL_TYPE_IMPLICIT
	}
	return t.NullLabel
}

// GetPwEncapsulation retrieves the value of the leaf PwEncapsulation from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PwEncapsulation is set, it can
// safely use t.GetPwEncapsulation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PwEncapsulation == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetPwEncapsulation() E_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	if t == nil || t.PwEncapsulation == 0 {
		return 0
	}
	return t.PwEncapsulation
}

// GetTtlPropagation retrieves the value of the leaf TtlPropagation from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TtlPropagation is set, it can
// safely use t.GetTtlPropagation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TtlPropagation == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetTtlPropagation() bool {
	if t == nil || t.TtlPropagation == nil {
		return true
	}
	return *t.TtlPropagation
}

// SetNullLabel sets the value of the leaf NullLabel in the NetworkInstance_Mpls_Global
// struct.
func (t *NetworkInstance_Mpls_Global) SetNullLabel(v E_MplsTypes_NULL_LABEL_TYPE) {
	t.NullLabel = v
}

// SetPwEncapsulation sets the value of the leaf PwEncapsulation in the NetworkInstance_Mpls_Global
// struct.
func (t *NetworkInstance_Mpls_Global) SetPwEncapsulation(v E_MplsTypes_PSEUDOWIRE_ENCAPSULATION) {
	t.PwEncapsulation = v
}

// SetTtlPropagation sets the value of the leaf TtlPropagation in the NetworkInstance_Mpls_Global
// struct.
func (t *NetworkInstance_Mpls_Global) SetTtlPropagation(v bool) {
	t.TtlPropagation = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.NullLabel == 0 {
		t.NullLabel = MplsTypes_NULL_LABEL_TYPE_IMPLICIT
	}
	if t.TtlPropagation == nil {
		var v bool = true
		t.TtlPropagation = &v
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.ReservedLabelBlock {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global.
func (*NetworkInstance_Mpls_Global) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_Global_Interface struct {
	InterfaceId  *string                                             `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef *NetworkInstance_Mpls_Global_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
	MplsEnabled  *bool                                               `path:"state/mpls-enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mpls-enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Global_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Global_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_Global_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetMplsEnabled retrieves the value of the leaf MplsEnabled from the NetworkInstance_Mpls_Global_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsEnabled is set, it can
// safely use t.GetMplsEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsEnabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface) GetMplsEnabled() bool {
	if t == nil || t.MplsEnabled == nil {
		return false
	}
	return *t.MplsEnabled
}

// SetInterfaceId sets the value of the leaf InterfaceId in the NetworkInstance_Mpls_Global_Interface
// struct.
func (t *NetworkInstance_Mpls_Global_Interface) SetInterfaceId(v string) {
	t.InterfaceId = &v
}

// SetMplsEnabled sets the value of the leaf MplsEnabled in the NetworkInstance_Mpls_Global_Interface
// struct.
func (t *NetworkInstance_Mpls_Global_Interface) SetMplsEnabled(v bool) {
	t.MplsEnabled = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MplsEnabled == nil {
		var v bool = false
		t.MplsEnabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_Interface.
func (*NetworkInstance_Mpls_Global_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_Global_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_ReservedLabelBlock represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block YANG schema element.
type NetworkInstance_Mpls_Global_ReservedLabelBlock struct {
	LocalId    *string                                                         `path:"state/local-id|local-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/local-id|local-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	LowerBound NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union `path:"state/lower-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lower-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpperBound NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union `path:"state/upper-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/upper-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_ReservedLabelBlock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_ReservedLabelBlock) IsYANGGoStruct() {}

// GetLocalId retrieves the value of the leaf LocalId from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalId is set, it can
// safely use t.GetLocalId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetLocalId() string {
	if t == nil || t.LocalId == nil {
		return ""
	}
	return *t.LocalId
}

// GetLowerBound retrieves the value of the leaf LowerBound from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowerBound is set, it can
// safely use t.GetLowerBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowerBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetLowerBound() NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	if t == nil || t.LowerBound == nil {
		return nil
	}
	return t.LowerBound
}

// GetUpperBound retrieves the value of the leaf UpperBound from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpperBound is set, it can
// safely use t.GetUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetUpperBound() NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	if t == nil || t.UpperBound == nil {
		return nil
	}
	return t.UpperBound
}

// SetLocalId sets the value of the leaf LocalId in the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) SetLocalId(v string) {
	t.LocalId = &v
}

// SetLowerBound sets the value of the leaf LowerBound in the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) SetLowerBound(v NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union) {
	t.LowerBound = v
}

// SetUpperBound sets the value of the leaf UpperBound in the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) SetUpperBound(v NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union) {
	t.UpperBound = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_ReservedLabelBlock
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_ReservedLabelBlock struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_ReservedLabelBlock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_ReservedLabelBlock.
func (*NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_Interface struct {
	AdminGroup           []string                                             `path:"state/admin-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/admin-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IgpFloodingBandwidth *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth `path:"igp-flooding-bandwidth" module:"openconfig-network-instance"`
	InterfaceId          *string                                              `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef         *NetworkInstance_Mpls_Interface_InterfaceRef         `path:"interface-ref" module:"openconfig-network-instance"`
	SrlgMembership       []string                                             `path:"state/srlg-membership" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/srlg-membership" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TeMetric             *uint32                                              `path:"state/te-metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/te-metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface) IsYANGGoStruct() {}

// GetOrCreateIgpFloodingBandwidth retrieves the value of the IgpFloodingBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	t.IgpFloodingBandwidth = &NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	return t.IgpFloodingBandwidth
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetIgpFloodingBandwidth returns the value of the IgpFloodingBandwidth struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field IgpFloodingBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t != nil && t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetAdminGroup retrieves the value of the leaf AdminGroup from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroup is set, it can
// safely use t.GetAdminGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetAdminGroup() []string {
	if t == nil || t.AdminGroup == nil {
		return nil
	}
	return t.AdminGroup
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetSrlgMembership retrieves the value of the leaf SrlgMembership from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrlgMembership is set, it can
// safely use t.GetSrlgMembership() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrlgMembership == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetSrlgMembership() []string {
	if t == nil || t.SrlgMembership == nil {
		return nil
	}
	return t.SrlgMembership
}

// GetTeMetric retrieves the value of the leaf TeMetric from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TeMetric is set, it can
// safely use t.GetTeMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TeMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetTeMetric() uint32 {
	if t == nil || t.TeMetric == nil {
		return 0
	}
	return *t.TeMetric
}

// SetAdminGroup sets the value of the leaf AdminGroup in the NetworkInstance_Mpls_Interface
// struct.
func (t *NetworkInstance_Mpls_Interface) SetAdminGroup(v []string) {
	t.AdminGroup = v
}

// SetInterfaceId sets the value of the leaf InterfaceId in the NetworkInstance_Mpls_Interface
// struct.
func (t *NetworkInstance_Mpls_Interface) SetInterfaceId(v string) {
	t.InterfaceId = &v
}

// SetSrlgMembership sets the value of the leaf SrlgMembership in the NetworkInstance_Mpls_Interface
// struct.
func (t *NetworkInstance_Mpls_Interface) SetSrlgMembership(v []string) {
	t.SrlgMembership = v
}

// SetTeMetric sets the value of the leaf TeMetric in the NetworkInstance_Mpls_Interface
// struct.
func (t *NetworkInstance_Mpls_Interface) SetTeMetric(v uint32) {
	t.TeMetric = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.IgpFloodingBandwidth.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface.
func (*NetworkInstance_Mpls_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface_IgpFloodingBandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth YANG schema element.
type NetworkInstance_Mpls_Interface_IgpFloodingBandwidth struct {
	DeltaPercentage        *uint8                                        `path:"state/delta-percentage" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/delta-percentage" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DownThresholds         []uint8                                       `path:"state/down-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/down-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ThresholdSpecification E_IgpFloodingBandwidth_ThresholdSpecification `path:"state/threshold-specification" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/threshold-specification" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ThresholdType          E_IgpFloodingBandwidth_ThresholdType          `path:"state/threshold-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/threshold-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpDownThresholds       []uint8                                       `path:"state/up-down-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/up-down-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpThresholds           []uint8                                       `path:"state/up-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/up-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface_IgpFloodingBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) IsYANGGoStruct() {}

// GetDeltaPercentage retrieves the value of the leaf DeltaPercentage from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeltaPercentage is set, it can
// safely use t.GetDeltaPercentage() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeltaPercentage == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetDeltaPercentage() uint8 {
	if t == nil || t.DeltaPercentage == nil {
		return 0
	}
	return *t.DeltaPercentage
}

// GetDownThresholds retrieves the value of the leaf DownThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DownThresholds is set, it can
// safely use t.GetDownThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DownThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetDownThresholds() []uint8 {
	if t == nil || t.DownThresholds == nil {
		return nil
	}
	return t.DownThresholds
}

// GetThresholdSpecification retrieves the value of the leaf ThresholdSpecification from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdSpecification is set, it can
// safely use t.GetThresholdSpecification() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdSpecification == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetThresholdSpecification() E_IgpFloodingBandwidth_ThresholdSpecification {
	if t == nil || t.ThresholdSpecification == 0 {
		return 0
	}
	return t.ThresholdSpecification
}

// GetThresholdType retrieves the value of the leaf ThresholdType from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdType is set, it can
// safely use t.GetThresholdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetThresholdType() E_IgpFloodingBandwidth_ThresholdType {
	if t == nil || t.ThresholdType == 0 {
		return 0
	}
	return t.ThresholdType
}

// GetUpDownThresholds retrieves the value of the leaf UpDownThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpDownThresholds is set, it can
// safely use t.GetUpDownThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpDownThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetUpDownThresholds() []uint8 {
	if t == nil || t.UpDownThresholds == nil {
		return nil
	}
	return t.UpDownThresholds
}

// GetUpThresholds retrieves the value of the leaf UpThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpThresholds is set, it can
// safely use t.GetUpThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetUpThresholds() []uint8 {
	if t == nil || t.UpThresholds == nil {
		return nil
	}
	return t.UpThresholds
}

// SetDeltaPercentage sets the value of the leaf DeltaPercentage in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) SetDeltaPercentage(v uint8) {
	t.DeltaPercentage = &v
}

// SetDownThresholds sets the value of the leaf DownThresholds in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) SetDownThresholds(v []uint8) {
	t.DownThresholds = v
}

// SetThresholdSpecification sets the value of the leaf ThresholdSpecification in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) SetThresholdSpecification(v E_IgpFloodingBandwidth_ThresholdSpecification) {
	t.ThresholdSpecification = v
}

// SetThresholdType sets the value of the leaf ThresholdType in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) SetThresholdType(v E_IgpFloodingBandwidth_ThresholdType) {
	t.ThresholdType = v
}

// SetUpDownThresholds sets the value of the leaf UpDownThresholds in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) SetUpDownThresholds(v []uint8) {
	t.UpDownThresholds = v
}

// SetUpThresholds sets the value of the leaf UpThresholds in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) SetUpThresholds(v []uint8) {
	t.UpThresholds = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_IgpFloodingBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface_IgpFloodingBandwidth.
func (*NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_Interface_InterfaceRef
// struct.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_Interface_InterfaceRef
// struct.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps YANG schema element.
type NetworkInstance_Mpls_Lsps struct {
	ConstrainedPath   *NetworkInstance_Mpls_Lsps_ConstrainedPath      `path:"constrained-path" module:"openconfig-network-instance"`
	StaticLsp         map[string]*NetworkInstance_Mpls_Lsps_StaticLsp `path:"static-lsps/static-lsp" module:"openconfig-network-instance/openconfig-network-instance"`
	UnconstrainedPath *NetworkInstance_Mpls_Lsps_UnconstrainedPath    `path:"unconstrained-path" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps) IsYANGGoStruct() {}

// NewStaticLsp creates a new entry in the StaticLsp list of the
// NetworkInstance_Mpls_Lsps struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps) NewStaticLsp(Name string) (*NetworkInstance_Mpls_Lsps_StaticLsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticLsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticLsp", key)
	}

	t.StaticLsp[key] = &NetworkInstance_Mpls_Lsps_StaticLsp{
		Name: &Name,
	}

	return t.StaticLsp[key], nil
}

// RenameStaticLsp renames an entry in the list StaticLsp within
// the NetworkInstance_Mpls_Lsps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps) RenameStaticLsp(oldK, newK string) error {
	if _, ok := t.StaticLsp[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticLsp", newK)
	}

	e, ok := t.StaticLsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticLsp", oldK)
	}
	e.Name = &newK

	t.StaticLsp[newK] = e
	delete(t.StaticLsp, oldK)
	return nil
}

// GetOrCreateStaticLspMap returns the list (map) from NetworkInstance_Mpls_Lsps.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateStaticLspMap() map[string]*NetworkInstance_Mpls_Lsps_StaticLsp {
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}
	return t.StaticLsp
}

// GetOrCreateStaticLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	key := Name

	if v, ok := t.StaticLsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticLsp(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticLsp got unexpected error: %v", err))
	}
	return v
}

// GetStaticLsp retrieves the value with the specified key from
// the StaticLsp map field of NetworkInstance_Mpls_Lsps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.StaticLsp[key]; ok {
		return lm
	}
	return nil
}

// DeleteStaticLsp deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps) DeleteStaticLsp(Name string) {
	key := Name

	delete(t.StaticLsp, key)
}

// AppendStaticLsp appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp struct to the
// list StaticLsp of NetworkInstance_Mpls_Lsps. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps) AppendStaticLsp(v *NetworkInstance_Mpls_Lsps_StaticLsp) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	if _, ok := t.StaticLsp[key]; ok {
		return fmt.Errorf("duplicate key for list StaticLsp %v", key)
	}

	t.StaticLsp[key] = v
	return nil
}

// GetOrCreateConstrainedPath retrieves the value of the ConstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	t.ConstrainedPath = &NetworkInstance_Mpls_Lsps_ConstrainedPath{}
	return t.ConstrainedPath
}

// GetOrCreateUnconstrainedPath retrieves the value of the UnconstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	t.UnconstrainedPath = &NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	return t.UnconstrainedPath
}

// GetConstrainedPath returns the value of the ConstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field ConstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t != nil && t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	return nil
}

// GetUnconstrainedPath returns the value of the UnconstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field UnconstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t != nil && t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ConstrainedPath.PopulateDefaults()
	t.UnconstrainedPath.PopulateDefaults()
	for _, e := range t.StaticLsp {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps.
func (*NetworkInstance_Mpls_Lsps) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath struct {
	NamedExplicitPath map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath `path:"named-explicit-paths/named-explicit-path" module:"openconfig-network-instance/openconfig-network-instance"`
	Tunnel            map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel            `path:"tunnels/tunnel" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath) IsYANGGoStruct() {}

// NewNamedExplicitPath creates a new entry in the NamedExplicitPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewNamedExplicitPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NamedExplicitPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NamedExplicitPath", key)
	}

	t.NamedExplicitPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
		Name: &Name,
	}

	return t.NamedExplicitPath[key], nil
}

// RenameNamedExplicitPath renames an entry in the list NamedExplicitPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameNamedExplicitPath(oldK, newK string) error {
	if _, ok := t.NamedExplicitPath[newK]; ok {
		return fmt.Errorf("key %v already exists in NamedExplicitPath", newK)
	}

	e, ok := t.NamedExplicitPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NamedExplicitPath", oldK)
	}
	e.Name = &newK

	t.NamedExplicitPath[newK] = e
	delete(t.NamedExplicitPath, oldK)
	return nil
}

// GetOrCreateNamedExplicitPathMap returns the list (map) from NetworkInstance_Mpls_Lsps_ConstrainedPath.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateNamedExplicitPathMap() map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}
	return t.NamedExplicitPath
}

// GetOrCreateNamedExplicitPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	key := Name

	if v, ok := t.NamedExplicitPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNamedExplicitPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNamedExplicitPath got unexpected error: %v", err))
	}
	return v
}

// GetNamedExplicitPath retrieves the value with the specified key from
// the NamedExplicitPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NamedExplicitPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteNamedExplicitPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteNamedExplicitPath(Name string) {
	key := Name

	delete(t.NamedExplicitPath, key)
}

// AppendNamedExplicitPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct to the
// list NamedExplicitPath of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendNamedExplicitPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	if _, ok := t.NamedExplicitPath[key]; ok {
		return fmt.Errorf("duplicate key for list NamedExplicitPath %v", key)
	}

	t.NamedExplicitPath[key] = v
	return nil
}

// NewTunnel creates a new entry in the Tunnel list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewTunnel(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tunnel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tunnel", key)
	}

	t.Tunnel[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{
		Name: &Name,
	}

	return t.Tunnel[key], nil
}

// RenameTunnel renames an entry in the list Tunnel within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameTunnel(oldK, newK string) error {
	if _, ok := t.Tunnel[newK]; ok {
		return fmt.Errorf("key %v already exists in Tunnel", newK)
	}

	e, ok := t.Tunnel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tunnel", oldK)
	}
	e.Name = &newK

	t.Tunnel[newK] = e
	delete(t.Tunnel, oldK)
	return nil
}

// GetOrCreateTunnelMap returns the list (map) from NetworkInstance_Mpls_Lsps_ConstrainedPath.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateTunnelMap() map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}
	return t.Tunnel
}

// GetOrCreateTunnel retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	key := Name

	if v, ok := t.Tunnel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnel(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnel got unexpected error: %v", err))
	}
	return v
}

// GetTunnel retrieves the value with the specified key from
// the Tunnel map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Tunnel[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnel deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteTunnel(Name string) {
	key := Name

	delete(t.Tunnel, key)
}

// AppendTunnel appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct to the
// list Tunnel of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendTunnel(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	if _, ok := t.Tunnel[key]; ok {
		return fmt.Errorf("duplicate key for list Tunnel %v", key)
	}

	t.Tunnel[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NamedExplicitPath {
		e.PopulateDefaults()
	}
	for _, e := range t.Tunnel {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct {
	ExplicitRouteObject   map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject `path:"explicit-route-objects/explicit-route-object" module:"openconfig-network-instance/openconfig-network-instance"`
	Name                  *string                                                                                    `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	SidProtectionRequired *bool                                                                                      `path:"state/sid-protection-required" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/sid-protection-required" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SidSelectionMode      E_NamedExplicitPath_SidSelectionMode                                                       `path:"state/sid-selection-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/sid-selection-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) IsYANGGoStruct() {}

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) NewExplicitRouteObject(Index uint8) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) RenameExplicitRouteObject(oldK, newK uint8) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObjectMap returns the list (map) from NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetOrCreateExplicitRouteObjectMap() map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}
	return t.ExplicitRouteObject
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetOrCreateExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteExplicitRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) DeleteExplicitRouteObject(Index uint8) {
	key := Index

	delete(t.ExplicitRouteObject, key)
}

// AppendExplicitRouteObject appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct to the
// list ExplicitRouteObject of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) AppendExplicitRouteObject(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSidProtectionRequired retrieves the value of the leaf SidProtectionRequired from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidProtectionRequired is set, it can
// safely use t.GetSidProtectionRequired() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidProtectionRequired == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetSidProtectionRequired() bool {
	if t == nil || t.SidProtectionRequired == nil {
		return false
	}
	return *t.SidProtectionRequired
}

// GetSidSelectionMode retrieves the value of the leaf SidSelectionMode from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidSelectionMode is set, it can
// safely use t.GetSidSelectionMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidSelectionMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetSidSelectionMode() E_NamedExplicitPath_SidSelectionMode {
	if t == nil || t.SidSelectionMode == 0 {
		return NamedExplicitPath_SidSelectionMode_MIXED_MODE
	}
	return t.SidSelectionMode
}

// SetName sets the value of the leaf Name in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) SetName(v string) {
	t.Name = &v
}

// SetSidProtectionRequired sets the value of the leaf SidProtectionRequired in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) SetSidProtectionRequired(v bool) {
	t.SidProtectionRequired = &v
}

// SetSidSelectionMode sets the value of the leaf SidSelectionMode in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) SetSidSelectionMode(v E_NamedExplicitPath_SidSelectionMode) {
	t.SidSelectionMode = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SidProtectionRequired == nil {
		var v bool = false
		t.SidProtectionRequired = &v
	}
	if t.SidSelectionMode == 0 {
		t.SidSelectionMode = NamedExplicitPath_SidSelectionMode_MIXED_MODE
	}
	for _, e := range t.ExplicitRouteObject {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct {
	Address *string            `path:"state/address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HopType E_Mpls_MplsHopType `path:"state/hop-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hop-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Index   *uint8             `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/index|index" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetHopType retrieves the value of the leaf HopType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopType is set, it can
// safely use t.GetHopType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetHopType() E_Mpls_MplsHopType {
	if t == nil || t.HopType == 0 {
		return 0
	}
	return t.HopType
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// SetAddress sets the value of the leaf Address in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) SetAddress(v string) {
	t.Address = &v
}

// SetHopType sets the value of the leaf HopType in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) SetHopType(v E_Mpls_MplsHopType) {
	t.HopType = v
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) SetIndex(v uint8) {
	t.Index = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct {
	AdminStatus              E_MplsTypes_TUNNEL_ADMIN_STATUS                                       `path:"state/admin-status" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/admin-status" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	AutoGenerated            *bool                                                                 `path:"state/auto-generated" module:"openconfig-network-instance/openconfig-network-instance"`
	Bandwidth                *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth           `path:"bandwidth" module:"openconfig-network-instance"`
	Counters                 *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters            `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	Description              *string                                                               `path:"state/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HoldPriority             *uint8                                                                `path:"state/hold-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hold-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Metric                   *int32                                                                `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MetricType               E_MplsTypes_LSP_METRIC_TYPE                                           `path:"state/metric-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name                     *string                                                               `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	OperStatus               E_MplsTypes_LSP_OPER_STATUS                                           `path:"state/oper-status" module:"openconfig-network-instance/openconfig-network-instance"`
	P2PTunnelAttributes      *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes `path:"p2p-tunnel-attributes" module:"openconfig-network-instance"`
	Preference               *uint8                                                                `path:"state/preference" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/preference" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ProtectionStyleRequested E_MplsTypes_PROTECTION_TYPE                                           `path:"state/protection-style-requested" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/protection-style-requested" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReoptimizeTimer          *uint16                                                               `path:"state/reoptimize-timer" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/reoptimize-timer" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Role                     E_MplsTypes_LSP_ROLE                                                  `path:"state/role" module:"openconfig-network-instance/openconfig-network-instance"`
	SetupPriority            *uint8                                                                `path:"state/setup-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/setup-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ShortcutEligible         *bool                                                                 `path:"state/shortcut-eligible" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/shortcut-eligible" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SignalingProtocol        E_MplsTypes_PATH_SETUP_PROTOCOL                                       `path:"state/signaling-protocol" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/signaling-protocol" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SoftPreemption           *bool                                                                 `path:"state/soft-preemption" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/soft-preemption" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Source                   *string                                                               `path:"state/source" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Type                     E_MplsTypes_TUNNEL_TYPE                                               `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) IsYANGGoStruct() {}

// GetOrCreateBandwidth retrieves the value of the Bandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t.Bandwidth != nil {
		return t.Bandwidth
	}
	t.Bandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	return t.Bandwidth
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	return t.Counters
}

// GetOrCreateP2PTunnelAttributes retrieves the value of the P2PTunnelAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	t.P2PTunnelAttributes = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	return t.P2PTunnelAttributes
}

// GetBandwidth returns the value of the Bandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Bandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t != nil && t.Bandwidth != nil {
		return t.Bandwidth
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetP2PTunnelAttributes returns the value of the P2PTunnelAttributes struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field P2PTunnelAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t != nil && t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetAdminStatus() E_MplsTypes_TUNNEL_ADMIN_STATUS {
	if t == nil || t.AdminStatus == 0 {
		return MplsTypes_TUNNEL_ADMIN_STATUS_ADMIN_UP
	}
	return t.AdminStatus
}

// GetAutoGenerated retrieves the value of the leaf AutoGenerated from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoGenerated is set, it can
// safely use t.GetAutoGenerated() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoGenerated == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetAutoGenerated() bool {
	if t == nil || t.AutoGenerated == nil {
		return false
	}
	return *t.AutoGenerated
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetMetric() int32 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetMetricType retrieves the value of the leaf MetricType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricType is set, it can
// safely use t.GetMetricType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetMetricType() E_MplsTypes_LSP_METRIC_TYPE {
	if t == nil || t.MetricType == 0 {
		return MplsTypes_LSP_METRIC_TYPE_LSP_METRIC_INHERITED
	}
	return t.MetricType
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOperStatus() E_MplsTypes_LSP_OPER_STATUS {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetProtectionStyleRequested retrieves the value of the leaf ProtectionStyleRequested from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectionStyleRequested is set, it can
// safely use t.GetProtectionStyleRequested() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectionStyleRequested == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetProtectionStyleRequested() E_MplsTypes_PROTECTION_TYPE {
	if t == nil || t.ProtectionStyleRequested == 0 {
		return MplsTypes_PROTECTION_TYPE_UNPROTECTED
	}
	return t.ProtectionStyleRequested
}

// GetReoptimizeTimer retrieves the value of the leaf ReoptimizeTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReoptimizeTimer is set, it can
// safely use t.GetReoptimizeTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReoptimizeTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetReoptimizeTimer() uint16 {
	if t == nil || t.ReoptimizeTimer == nil {
		return 0
	}
	return *t.ReoptimizeTimer
}

// GetRole retrieves the value of the leaf Role from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Role is set, it can
// safely use t.GetRole() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Role == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetRole() E_MplsTypes_LSP_ROLE {
	if t == nil || t.Role == 0 {
		return 0
	}
	return t.Role
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetShortcutEligible retrieves the value of the leaf ShortcutEligible from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ShortcutEligible is set, it can
// safely use t.GetShortcutEligible() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ShortcutEligible == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetShortcutEligible() bool {
	if t == nil || t.ShortcutEligible == nil {
		return true
	}
	return *t.ShortcutEligible
}

// GetSignalingProtocol retrieves the value of the leaf SignalingProtocol from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SignalingProtocol is set, it can
// safely use t.GetSignalingProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SignalingProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSignalingProtocol() E_MplsTypes_PATH_SETUP_PROTOCOL {
	if t == nil || t.SignalingProtocol == 0 {
		return 0
	}
	return t.SignalingProtocol
}

// GetSoftPreemption retrieves the value of the leaf SoftPreemption from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SoftPreemption is set, it can
// safely use t.GetSoftPreemption() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SoftPreemption == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSoftPreemption() bool {
	if t == nil || t.SoftPreemption == nil {
		return false
	}
	return *t.SoftPreemption
}

// GetSource retrieves the value of the leaf Source from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Source is set, it can
// safely use t.GetSource() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Source == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSource() string {
	if t == nil || t.Source == nil {
		return ""
	}
	return *t.Source
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetType() E_MplsTypes_TUNNEL_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetAdminStatus sets the value of the leaf AdminStatus in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetAdminStatus(v E_MplsTypes_TUNNEL_ADMIN_STATUS) {
	t.AdminStatus = v
}

// SetAutoGenerated sets the value of the leaf AutoGenerated in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetAutoGenerated(v bool) {
	t.AutoGenerated = &v
}

// SetDescription sets the value of the leaf Description in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetDescription(v string) {
	t.Description = &v
}

// SetHoldPriority sets the value of the leaf HoldPriority in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetHoldPriority(v uint8) {
	t.HoldPriority = &v
}

// SetMetric sets the value of the leaf Metric in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetMetric(v int32) {
	t.Metric = &v
}

// SetMetricType sets the value of the leaf MetricType in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetMetricType(v E_MplsTypes_LSP_METRIC_TYPE) {
	t.MetricType = v
}

// SetName sets the value of the leaf Name in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetName(v string) {
	t.Name = &v
}

// SetOperStatus sets the value of the leaf OperStatus in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetOperStatus(v E_MplsTypes_LSP_OPER_STATUS) {
	t.OperStatus = v
}

// SetPreference sets the value of the leaf Preference in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetPreference(v uint8) {
	t.Preference = &v
}

// SetProtectionStyleRequested sets the value of the leaf ProtectionStyleRequested in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetProtectionStyleRequested(v E_MplsTypes_PROTECTION_TYPE) {
	t.ProtectionStyleRequested = v
}

// SetReoptimizeTimer sets the value of the leaf ReoptimizeTimer in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetReoptimizeTimer(v uint16) {
	t.ReoptimizeTimer = &v
}

// SetRole sets the value of the leaf Role in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetRole(v E_MplsTypes_LSP_ROLE) {
	t.Role = v
}

// SetSetupPriority sets the value of the leaf SetupPriority in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetSetupPriority(v uint8) {
	t.SetupPriority = &v
}

// SetShortcutEligible sets the value of the leaf ShortcutEligible in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetShortcutEligible(v bool) {
	t.ShortcutEligible = &v
}

// SetSignalingProtocol sets the value of the leaf SignalingProtocol in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetSignalingProtocol(v E_MplsTypes_PATH_SETUP_PROTOCOL) {
	t.SignalingProtocol = v
}

// SetSoftPreemption sets the value of the leaf SoftPreemption in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetSoftPreemption(v bool) {
	t.SoftPreemption = &v
}

// SetSource sets the value of the leaf Source in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetSource(v string) {
	t.Source = &v
}

// SetType sets the value of the leaf Type in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) SetType(v E_MplsTypes_TUNNEL_TYPE) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminStatus == 0 {
		t.AdminStatus = MplsTypes_TUNNEL_ADMIN_STATUS_ADMIN_UP
	}
	if t.HoldPriority == nil {
		var v uint8 = 0
		t.HoldPriority = &v
	}
	if t.MetricType == 0 {
		t.MetricType = MplsTypes_LSP_METRIC_TYPE_LSP_METRIC_INHERITED
	}
	if t.ProtectionStyleRequested == 0 {
		t.ProtectionStyleRequested = MplsTypes_PROTECTION_TYPE_UNPROTECTED
	}
	if t.SetupPriority == nil {
		var v uint8 = 7
		t.SetupPriority = &v
	}
	if t.ShortcutEligible == nil {
		var v bool = true
		t.ShortcutEligible = &v
	}
	if t.SoftPreemption == nil {
		var v bool = false
		t.SoftPreemption = &v
	}
	t.Bandwidth.PopulateDefaults()
	t.Counters.PopulateDefaults()
	t.P2PTunnelAttributes.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth struct {
	AutoBandwidth     *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth `path:"auto-bandwidth" module:"openconfig-network-instance"`
	SetBandwidth      *uint64                                                                   `path:"state/set-bandwidth" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/set-bandwidth" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SignaledBandwidth *uint64                                                                   `path:"state/signaled-bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	SpecificationType E_Mpls_TeBandwidthType                                                    `path:"state/specification-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/specification-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) IsYANGGoStruct() {}

// GetOrCreateAutoBandwidth retrieves the value of the AutoBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetOrCreateAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if t.AutoBandwidth != nil {
		return t.AutoBandwidth
	}
	t.AutoBandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	return t.AutoBandwidth
}

// GetAutoBandwidth returns the value of the AutoBandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth. If the receiver or the field AutoBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if t != nil && t.AutoBandwidth != nil {
		return t.AutoBandwidth
	}
	return nil
}

// GetSetBandwidth retrieves the value of the leaf SetBandwidth from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetBandwidth is set, it can
// safely use t.GetSetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSetBandwidth() uint64 {
	if t == nil || t.SetBandwidth == nil {
		return 0
	}
	return *t.SetBandwidth
}

// GetSignaledBandwidth retrieves the value of the leaf SignaledBandwidth from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SignaledBandwidth is set, it can
// safely use t.GetSignaledBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SignaledBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSignaledBandwidth() uint64 {
	if t == nil || t.SignaledBandwidth == nil {
		return 0
	}
	return *t.SignaledBandwidth
}

// GetSpecificationType retrieves the value of the leaf SpecificationType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpecificationType is set, it can
// safely use t.GetSpecificationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpecificationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSpecificationType() E_Mpls_TeBandwidthType {
	if t == nil || t.SpecificationType == 0 {
		return Mpls_TeBandwidthType_SPECIFIED
	}
	return t.SpecificationType
}

// SetSetBandwidth sets the value of the leaf SetBandwidth in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) SetSetBandwidth(v uint64) {
	t.SetBandwidth = &v
}

// SetSignaledBandwidth sets the value of the leaf SignaledBandwidth in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) SetSignaledBandwidth(v uint64) {
	t.SignaledBandwidth = &v
}

// SetSpecificationType sets the value of the leaf SpecificationType in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) SetSpecificationType(v E_Mpls_TeBandwidthType) {
	t.SpecificationType = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SpecificationType == 0 {
		t.SpecificationType = Mpls_TeBandwidthType_SPECIFIED
	}
	t.AutoBandwidth.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth struct {
	AdjustInterval  *uint32                                                                             `path:"state/adjust-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/adjust-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	AdjustThreshold *uint8                                                                              `path:"state/adjust-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/adjust-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled         *bool                                                                               `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IntervalHighBw  *uint64                                                                             `path:"state/interval-high-bw" module:"openconfig-network-instance/openconfig-network-instance"`
	MaxBw           *uint64                                                                             `path:"state/max-bw" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-bw" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MinBw           *uint64                                                                             `path:"state/min-bw" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/min-bw" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Overflow        *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow  `path:"overflow" module:"openconfig-network-instance"`
	Underflow       *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow `path:"underflow" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) IsYANGGoStruct() {}

// GetOrCreateOverflow retrieves the value of the Overflow field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if t.Overflow != nil {
		return t.Overflow
	}
	t.Overflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	return t.Overflow
}

// GetOrCreateUnderflow retrieves the value of the Underflow field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if t.Underflow != nil {
		return t.Underflow
	}
	t.Underflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	return t.Underflow
}

// GetOverflow returns the value of the Overflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Overflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if t != nil && t.Overflow != nil {
		return t.Overflow
	}
	return nil
}

// GetUnderflow returns the value of the Underflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Underflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if t != nil && t.Underflow != nil {
		return t.Underflow
	}
	return nil
}

// GetAdjustInterval retrieves the value of the leaf AdjustInterval from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjustInterval is set, it can
// safely use t.GetAdjustInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjustInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetAdjustInterval() uint32 {
	if t == nil || t.AdjustInterval == nil {
		return 0
	}
	return *t.AdjustInterval
}

// GetAdjustThreshold retrieves the value of the leaf AdjustThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjustThreshold is set, it can
// safely use t.GetAdjustThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjustThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetAdjustThreshold() uint8 {
	if t == nil || t.AdjustThreshold == nil {
		return 0
	}
	return *t.AdjustThreshold
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetIntervalHighBw retrieves the value of the leaf IntervalHighBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IntervalHighBw is set, it can
// safely use t.GetIntervalHighBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IntervalHighBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetIntervalHighBw() uint64 {
	if t == nil || t.IntervalHighBw == nil {
		return 0
	}
	return *t.IntervalHighBw
}

// GetMaxBw retrieves the value of the leaf MaxBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxBw is set, it can
// safely use t.GetMaxBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetMaxBw() uint64 {
	if t == nil || t.MaxBw == nil {
		return 0
	}
	return *t.MaxBw
}

// GetMinBw retrieves the value of the leaf MinBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinBw is set, it can
// safely use t.GetMinBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetMinBw() uint64 {
	if t == nil || t.MinBw == nil {
		return 0
	}
	return *t.MinBw
}

// SetAdjustInterval sets the value of the leaf AdjustInterval in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) SetAdjustInterval(v uint32) {
	t.AdjustInterval = &v
}

// SetAdjustThreshold sets the value of the leaf AdjustThreshold in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) SetAdjustThreshold(v uint8) {
	t.AdjustThreshold = &v
}

// SetEnabled sets the value of the leaf Enabled in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetIntervalHighBw sets the value of the leaf IntervalHighBw in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) SetIntervalHighBw(v uint64) {
	t.IntervalHighBw = &v
}

// SetMaxBw sets the value of the leaf MaxBw in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) SetMaxBw(v uint64) {
	t.MaxBw = &v
}

// SetMinBw sets the value of the leaf MinBw in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) SetMinBw(v uint64) {
	t.MinBw = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.Overflow.PopulateDefaults()
	t.Underflow.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow struct {
	Enabled           *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	OverflowThreshold *uint8  `path:"state/overflow-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/overflow-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TriggerEventCount *uint16 `path:"state/trigger-event-count" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/trigger-event-count" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) IsYANGGoStruct() {
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetOverflowThreshold retrieves the value of the leaf OverflowThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverflowThreshold is set, it can
// safely use t.GetOverflowThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverflowThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetOverflowThreshold() uint8 {
	if t == nil || t.OverflowThreshold == nil {
		return 0
	}
	return *t.OverflowThreshold
}

// GetTriggerEventCount retrieves the value of the leaf TriggerEventCount from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TriggerEventCount is set, it can
// safely use t.GetTriggerEventCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TriggerEventCount == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetTriggerEventCount() uint16 {
	if t == nil || t.TriggerEventCount == nil {
		return 0
	}
	return *t.TriggerEventCount
}

// SetEnabled sets the value of the leaf Enabled in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetOverflowThreshold sets the value of the leaf OverflowThreshold in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) SetOverflowThreshold(v uint8) {
	t.OverflowThreshold = &v
}

// SetTriggerEventCount sets the value of the leaf TriggerEventCount in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) SetTriggerEventCount(v uint16) {
	t.TriggerEventCount = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow struct {
	Enabled            *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TriggerEventCount  *uint16 `path:"state/trigger-event-count" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/trigger-event-count" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UnderflowThreshold *uint8  `path:"state/underflow-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/underflow-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) IsYANGGoStruct() {
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetTriggerEventCount retrieves the value of the leaf TriggerEventCount from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TriggerEventCount is set, it can
// safely use t.GetTriggerEventCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TriggerEventCount == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetTriggerEventCount() uint16 {
	if t == nil || t.TriggerEventCount == nil {
		return 0
	}
	return *t.TriggerEventCount
}

// GetUnderflowThreshold retrieves the value of the leaf UnderflowThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnderflowThreshold is set, it can
// safely use t.GetUnderflowThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnderflowThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetUnderflowThreshold() uint8 {
	if t == nil || t.UnderflowThreshold == nil {
		return 0
	}
	return *t.UnderflowThreshold
}

// SetEnabled sets the value of the leaf Enabled in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetTriggerEventCount sets the value of the leaf TriggerEventCount in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) SetTriggerEventCount(v uint16) {
	t.TriggerEventCount = &v
}

// SetUnderflowThreshold sets the value of the leaf UnderflowThreshold in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) SetUnderflowThreshold(v uint8) {
	t.UnderflowThreshold = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters struct {
	Bytes                  *uint64 `path:"bytes" module:"openconfig-network-instance"`
	CurrentPathTime        *uint64 `path:"current-path-time" module:"openconfig-network-instance"`
	NextReoptimizationTime *uint64 `path:"next-reoptimization-time" module:"openconfig-network-instance"`
	OnlineTime             *uint64 `path:"online-time" module:"openconfig-network-instance"`
	Packets                *uint64 `path:"packets" module:"openconfig-network-instance"`
	PathChanges            *uint64 `path:"path-changes" module:"openconfig-network-instance"`
	StateChanges           *uint64 `path:"state-changes" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) IsYANGGoStruct() {}

// GetBytes retrieves the value of the leaf Bytes from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bytes is set, it can
// safely use t.GetBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetBytes() uint64 {
	if t == nil || t.Bytes == nil {
		return 0
	}
	return *t.Bytes
}

// GetCurrentPathTime retrieves the value of the leaf CurrentPathTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPathTime is set, it can
// safely use t.GetCurrentPathTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPathTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetCurrentPathTime() uint64 {
	if t == nil || t.CurrentPathTime == nil {
		return 0
	}
	return *t.CurrentPathTime
}

// GetNextReoptimizationTime retrieves the value of the leaf NextReoptimizationTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextReoptimizationTime is set, it can
// safely use t.GetNextReoptimizationTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextReoptimizationTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetNextReoptimizationTime() uint64 {
	if t == nil || t.NextReoptimizationTime == nil {
		return 0
	}
	return *t.NextReoptimizationTime
}

// GetOnlineTime retrieves the value of the leaf OnlineTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OnlineTime is set, it can
// safely use t.GetOnlineTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OnlineTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetOnlineTime() uint64 {
	if t == nil || t.OnlineTime == nil {
		return 0
	}
	return *t.OnlineTime
}

// GetPackets retrieves the value of the leaf Packets from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Packets is set, it can
// safely use t.GetPackets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Packets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetPackets() uint64 {
	if t == nil || t.Packets == nil {
		return 0
	}
	return *t.Packets
}

// GetPathChanges retrieves the value of the leaf PathChanges from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathChanges is set, it can
// safely use t.GetPathChanges() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathChanges == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetPathChanges() uint64 {
	if t == nil || t.PathChanges == nil {
		return 0
	}
	return *t.PathChanges
}

// GetStateChanges retrieves the value of the leaf StateChanges from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StateChanges is set, it can
// safely use t.GetStateChanges() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StateChanges == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetStateChanges() uint64 {
	if t == nil || t.StateChanges == nil {
		return 0
	}
	return *t.StateChanges
}

// SetBytes sets the value of the leaf Bytes in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) SetBytes(v uint64) {
	t.Bytes = &v
}

// SetCurrentPathTime sets the value of the leaf CurrentPathTime in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) SetCurrentPathTime(v uint64) {
	t.CurrentPathTime = &v
}

// SetNextReoptimizationTime sets the value of the leaf NextReoptimizationTime in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) SetNextReoptimizationTime(v uint64) {
	t.NextReoptimizationTime = &v
}

// SetOnlineTime sets the value of the leaf OnlineTime in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) SetOnlineTime(v uint64) {
	t.OnlineTime = &v
}

// SetPackets sets the value of the leaf Packets in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) SetPackets(v uint64) {
	t.Packets = &v
}

// SetPathChanges sets the value of the leaf PathChanges in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) SetPathChanges(v uint64) {
	t.PathChanges = &v
}

// SetStateChanges sets the value of the leaf StateChanges in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) SetStateChanges(v uint64) {
	t.StateChanges = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct {
	Destination        *string                                                                                           `path:"state/destination" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/destination" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	P2PPrimaryPath     map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath   `path:"p2p-primary-path/p2p-primary-path" module:"openconfig-network-instance/openconfig-network-instance"`
	P2PSecondaryPath   map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath `path:"p2p-secondary-paths/p2p-secondary-path" module:"openconfig-network-instance/openconfig-network-instance"`
	RecordRouteEnabled *bool                                                                                             `path:"state/record-route-enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/record-route-enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) IsYANGGoStruct() {}

// NewP2PPrimaryPath creates a new entry in the P2PPrimaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PPrimaryPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PPrimaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PPrimaryPath", key)
	}

	t.P2PPrimaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
		Name: &Name,
	}

	return t.P2PPrimaryPath[key], nil
}

// RenameP2PPrimaryPath renames an entry in the list P2PPrimaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PPrimaryPath(oldK, newK string) error {
	if _, ok := t.P2PPrimaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PPrimaryPath", newK)
	}

	e, ok := t.P2PPrimaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PPrimaryPath", oldK)
	}
	e.Name = &newK

	t.P2PPrimaryPath[newK] = e
	delete(t.P2PPrimaryPath, oldK)
	return nil
}

// GetOrCreateP2PPrimaryPathMap returns the list (map) from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PPrimaryPathMap() map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}
	return t.P2PPrimaryPath
}

// GetOrCreateP2PPrimaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PPrimaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	key := Name

	if v, ok := t.P2PPrimaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PPrimaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PPrimaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PPrimaryPath retrieves the value with the specified key from
// the P2PPrimaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PPrimaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PPrimaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteP2PPrimaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) DeleteP2PPrimaryPath(Name string) {
	key := Name

	delete(t.P2PPrimaryPath, key)
}

// AppendP2PPrimaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct to the
// list P2PPrimaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PPrimaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	if _, ok := t.P2PPrimaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PPrimaryPath %v", key)
	}

	t.P2PPrimaryPath[key] = v
	return nil
}

// NewP2PSecondaryPath creates a new entry in the P2PSecondaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PSecondaryPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PSecondaryPath", key)
	}

	t.P2PSecondaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
		Name: &Name,
	}

	return t.P2PSecondaryPath[key], nil
}

// RenameP2PSecondaryPath renames an entry in the list P2PSecondaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PSecondaryPath(oldK, newK string) error {
	if _, ok := t.P2PSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PSecondaryPath", newK)
	}

	e, ok := t.P2PSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PSecondaryPath", oldK)
	}
	e.Name = &newK

	t.P2PSecondaryPath[newK] = e
	delete(t.P2PSecondaryPath, oldK)
	return nil
}

// GetOrCreateP2PSecondaryPathMap returns the list (map) from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PSecondaryPathMap() map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}
	return t.P2PSecondaryPath
}

// GetOrCreateP2PSecondaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PSecondaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	key := Name

	if v, ok := t.P2PSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PSecondaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PSecondaryPath retrieves the value with the specified key from
// the P2PSecondaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PSecondaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteP2PSecondaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) DeleteP2PSecondaryPath(Name string) {
	key := Name

	delete(t.P2PSecondaryPath, key)
}

// AppendP2PSecondaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct to the
// list P2PSecondaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PSecondaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	if _, ok := t.P2PSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PSecondaryPath %v", key)
	}

	t.P2PSecondaryPath[key] = v
	return nil
}

// GetDestination retrieves the value of the leaf Destination from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Destination is set, it can
// safely use t.GetDestination() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Destination == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetDestination() string {
	if t == nil || t.Destination == nil {
		return ""
	}
	return *t.Destination
}

// GetRecordRouteEnabled retrieves the value of the leaf RecordRouteEnabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RecordRouteEnabled is set, it can
// safely use t.GetRecordRouteEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RecordRouteEnabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetRecordRouteEnabled() bool {
	if t == nil || t.RecordRouteEnabled == nil {
		return false
	}
	return *t.RecordRouteEnabled
}

// SetDestination sets the value of the leaf Destination in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) SetDestination(v string) {
	t.Destination = &v
}

// SetRecordRouteEnabled sets the value of the leaf RecordRouteEnabled in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) SetRecordRouteEnabled(v bool) {
	t.RecordRouteEnabled = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.P2PPrimaryPath {
		e.PopulateDefaults()
	}
	for _, e := range t.P2PSecondaryPath {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct {
	AdminGroups               *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups                                                `path:"admin-groups" module:"openconfig-network-instance"`
	AssociatedRsvpSessions    []uint64                                                                                                                                        `path:"state/associated-rsvp-sessions" module:"openconfig-network-instance/openconfig-network-instance"`
	CandidateSecondaryPath    map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath                          `path:"candidate-secondary-paths/candidate-secondary-path" module:"openconfig-network-instance/openconfig-network-instance"`
	CspfMetric                *uint64                                                                                                                                         `path:"state/cspf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	CspfTiebreaker            E_Mpls_CspfTieBreaking                                                                                                                          `path:"state/cspf-tiebreaker" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/cspf-tiebreaker" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ExplicitPathName          *string                                                                                                                                         `path:"state/explicit-path-name" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/explicit-path-name" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HoldPriority              *uint8                                                                                                                                          `path:"state/hold-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hold-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name                      *string                                                                                                                                         `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	PathComputationMethod     E_MplsTypes_PATH_COMPUTATION_METHOD                                                                                                             `path:"state/path-computation-method" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-computation-method" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathComputationServer     *string                                                                                                                                         `path:"state/path-computation-server" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-computation-server" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathControl               E_Pcep_LspControlType                                                                                                                           `path:"state/path-control" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-control" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathMetricBoundConstraint map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint `path:"path-metric-bound-constraints/path-metric-bound-constraint" module:"openconfig-network-instance/openconfig-network-instance"`
	Preference                *uint8                                                                                                                                          `path:"state/preference" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/preference" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RetryTimer                *uint16                                                                                                                                         `path:"state/retry-timer" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/retry-timer" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SetupPriority             *uint8                                                                                                                                          `path:"state/setup-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/setup-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SpfMetric                 *uint64                                                                                                                                         `path:"state/spf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	UseCspf                   *bool                                                                                                                                           `path:"state/use-cspf" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/use-cspf" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) IsYANGGoStruct() {
}

// NewCandidateSecondaryPath creates a new entry in the CandidateSecondaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) NewCandidateSecondaryPath(SecondaryPath string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	key := SecondaryPath

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CandidateSecondaryPath", key)
	}

	t.CandidateSecondaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
		SecondaryPath: &SecondaryPath,
	}

	return t.CandidateSecondaryPath[key], nil
}

// RenameCandidateSecondaryPath renames an entry in the list CandidateSecondaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) RenameCandidateSecondaryPath(oldK, newK string) error {
	if _, ok := t.CandidateSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in CandidateSecondaryPath", newK)
	}

	e, ok := t.CandidateSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CandidateSecondaryPath", oldK)
	}
	e.SecondaryPath = &newK

	t.CandidateSecondaryPath[newK] = e
	delete(t.CandidateSecondaryPath, oldK)
	return nil
}

// GetOrCreateCandidateSecondaryPathMap returns the list (map) from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateCandidateSecondaryPathMap() map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}
	return t.CandidateSecondaryPath
}

// GetOrCreateCandidateSecondaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateCandidateSecondaryPath(SecondaryPath string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	key := SecondaryPath

	if v, ok := t.CandidateSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCandidateSecondaryPath(SecondaryPath)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCandidateSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetCandidateSecondaryPath retrieves the value with the specified key from
// the CandidateSecondaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCandidateSecondaryPath(SecondaryPath string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	if t == nil {
		return nil
	}

	key := SecondaryPath

	if lm, ok := t.CandidateSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteCandidateSecondaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) DeleteCandidateSecondaryPath(SecondaryPath string) {
	key := SecondaryPath

	delete(t.CandidateSecondaryPath, key)
}

// AppendCandidateSecondaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct to the
// list CandidateSecondaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) AppendCandidateSecondaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) error {
	if v.SecondaryPath == nil {
		return fmt.Errorf("invalid nil key received for SecondaryPath")
	}

	key := *v.SecondaryPath

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list CandidateSecondaryPath %v", key)
	}

	t.CandidateSecondaryPath[key] = v
	return nil
}

// NewPathMetricBoundConstraint creates a new entry in the PathMetricBoundConstraint list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) NewPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PathMetricBoundConstraint", key)
	}

	t.PathMetricBoundConstraint[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
		Type: Type,
	}

	return t.PathMetricBoundConstraint[key], nil
}

// RenamePathMetricBoundConstraint renames an entry in the list PathMetricBoundConstraint within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) RenamePathMetricBoundConstraint(oldK, newK E_MplsTypes_PATH_METRIC_TYPE) error {
	if _, ok := t.PathMetricBoundConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in PathMetricBoundConstraint", newK)
	}

	e, ok := t.PathMetricBoundConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PathMetricBoundConstraint", oldK)
	}
	e.Type = newK

	t.PathMetricBoundConstraint[newK] = e
	delete(t.PathMetricBoundConstraint, oldK)
	return nil
}

// GetOrCreatePathMetricBoundConstraintMap returns the list (map) from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreatePathMetricBoundConstraintMap() map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)
	}
	return t.PathMetricBoundConstraint
}

// GetOrCreatePathMetricBoundConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreatePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {

	key := Type

	if v, ok := t.PathMetricBoundConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPathMetricBoundConstraint(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePathMetricBoundConstraint got unexpected error: %v", err))
	}
	return v
}

// GetPathMetricBoundConstraint retrieves the value with the specified key from
// the PathMetricBoundConstraint map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.PathMetricBoundConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeletePathMetricBoundConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) DeletePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) {
	key := Type

	delete(t.PathMetricBoundConstraint, key)
}

// AppendPathMetricBoundConstraint appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint struct to the
// list PathMetricBoundConstraint of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) AppendPathMetricBoundConstraint(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)
	}

	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list PathMetricBoundConstraint %v", key)
	}

	t.PathMetricBoundConstraint[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if t.AdminGroups != nil {
		return t.AdminGroups
	}
	t.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	return t.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if t != nil && t.AdminGroups != nil {
		return t.AdminGroups
	}
	return nil
}

// GetAssociatedRsvpSessions retrieves the value of the leaf AssociatedRsvpSessions from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedRsvpSessions is set, it can
// safely use t.GetAssociatedRsvpSessions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedRsvpSessions == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetAssociatedRsvpSessions() []uint64 {
	if t == nil || t.AssociatedRsvpSessions == nil {
		return nil
	}
	return t.AssociatedRsvpSessions
}

// GetCspfMetric retrieves the value of the leaf CspfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfMetric is set, it can
// safely use t.GetCspfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCspfMetric() uint64 {
	if t == nil || t.CspfMetric == nil {
		return 0
	}
	return *t.CspfMetric
}

// GetCspfTiebreaker retrieves the value of the leaf CspfTiebreaker from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfTiebreaker is set, it can
// safely use t.GetCspfTiebreaker() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfTiebreaker == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCspfTiebreaker() E_Mpls_CspfTieBreaking {
	if t == nil || t.CspfTiebreaker == 0 {
		return Mpls_CspfTieBreaking_RANDOM
	}
	return t.CspfTiebreaker
}

// GetExplicitPathName retrieves the value of the leaf ExplicitPathName from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExplicitPathName is set, it can
// safely use t.GetExplicitPathName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExplicitPathName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetExplicitPathName() string {
	if t == nil || t.ExplicitPathName == nil {
		return ""
	}
	return *t.ExplicitPathName
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPathComputationMethod retrieves the value of the leaf PathComputationMethod from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationMethod is set, it can
// safely use t.GetPathComputationMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationMethod == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPathComputationMethod() E_MplsTypes_PATH_COMPUTATION_METHOD {
	if t == nil || t.PathComputationMethod == 0 {
		return MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	return t.PathComputationMethod
}

// GetPathComputationServer retrieves the value of the leaf PathComputationServer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationServer is set, it can
// safely use t.GetPathComputationServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationServer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPathComputationServer() string {
	if t == nil || t.PathComputationServer == nil {
		return ""
	}
	return *t.PathComputationServer
}

// GetPathControl retrieves the value of the leaf PathControl from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathControl is set, it can
// safely use t.GetPathControl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathControl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPathControl() E_Pcep_LspControlType {
	if t == nil || t.PathControl == 0 {
		return 0
	}
	return t.PathControl
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetRetryTimer retrieves the value of the leaf RetryTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RetryTimer is set, it can
// safely use t.GetRetryTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RetryTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetRetryTimer() uint16 {
	if t == nil || t.RetryTimer == nil {
		return 0
	}
	return *t.RetryTimer
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetSpfMetric retrieves the value of the leaf SpfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpfMetric is set, it can
// safely use t.GetSpfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetSpfMetric() uint64 {
	if t == nil || t.SpfMetric == nil {
		return 0
	}
	return *t.SpfMetric
}

// GetUseCspf retrieves the value of the leaf UseCspf from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseCspf is set, it can
// safely use t.GetUseCspf() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseCspf == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetUseCspf() bool {
	if t == nil || t.UseCspf == nil {
		return false
	}
	return *t.UseCspf
}

// SetAssociatedRsvpSessions sets the value of the leaf AssociatedRsvpSessions in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetAssociatedRsvpSessions(v []uint64) {
	t.AssociatedRsvpSessions = v
}

// SetCspfMetric sets the value of the leaf CspfMetric in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetCspfMetric(v uint64) {
	t.CspfMetric = &v
}

// SetCspfTiebreaker sets the value of the leaf CspfTiebreaker in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetCspfTiebreaker(v E_Mpls_CspfTieBreaking) {
	t.CspfTiebreaker = v
}

// SetExplicitPathName sets the value of the leaf ExplicitPathName in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetExplicitPathName(v string) {
	t.ExplicitPathName = &v
}

// SetHoldPriority sets the value of the leaf HoldPriority in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetHoldPriority(v uint8) {
	t.HoldPriority = &v
}

// SetName sets the value of the leaf Name in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetName(v string) {
	t.Name = &v
}

// SetPathComputationMethod sets the value of the leaf PathComputationMethod in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetPathComputationMethod(v E_MplsTypes_PATH_COMPUTATION_METHOD) {
	t.PathComputationMethod = v
}

// SetPathComputationServer sets the value of the leaf PathComputationServer in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetPathComputationServer(v string) {
	t.PathComputationServer = &v
}

// SetPathControl sets the value of the leaf PathControl in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetPathControl(v E_Pcep_LspControlType) {
	t.PathControl = v
}

// SetPreference sets the value of the leaf Preference in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetPreference(v uint8) {
	t.Preference = &v
}

// SetRetryTimer sets the value of the leaf RetryTimer in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetRetryTimer(v uint16) {
	t.RetryTimer = &v
}

// SetSetupPriority sets the value of the leaf SetupPriority in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetSetupPriority(v uint8) {
	t.SetupPriority = &v
}

// SetSpfMetric sets the value of the leaf SpfMetric in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetSpfMetric(v uint64) {
	t.SpfMetric = &v
}

// SetUseCspf sets the value of the leaf UseCspf in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) SetUseCspf(v bool) {
	t.UseCspf = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CspfTiebreaker == 0 {
		t.CspfTiebreaker = Mpls_CspfTieBreaking_RANDOM
	}
	if t.HoldPriority == nil {
		var v uint8 = 0
		t.HoldPriority = &v
	}
	if t.PathComputationMethod == 0 {
		t.PathComputationMethod = MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	if t.SetupPriority == nil {
		var v uint8 = 7
		t.SetupPriority = &v
	}
	t.AdminGroups.PopulateDefaults()
	for _, e := range t.CandidateSecondaryPath {
		e.PopulateDefaults()
	}
	for _, e := range t.PathMetricBoundConstraint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups struct {
	ExcludeGroup    []string `path:"state/exclude-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/exclude-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IncludeAllGroup []string `path:"state/include-all-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/include-all-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IncludeAnyGroup []string `path:"state/include-any-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/include-any-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) IsYANGGoStruct() {
}

// GetExcludeGroup retrieves the value of the leaf ExcludeGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExcludeGroup is set, it can
// safely use t.GetExcludeGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExcludeGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetExcludeGroup() []string {
	if t == nil || t.ExcludeGroup == nil {
		return nil
	}
	return t.ExcludeGroup
}

// GetIncludeAllGroup retrieves the value of the leaf IncludeAllGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAllGroup is set, it can
// safely use t.GetIncludeAllGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAllGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetIncludeAllGroup() []string {
	if t == nil || t.IncludeAllGroup == nil {
		return nil
	}
	return t.IncludeAllGroup
}

// GetIncludeAnyGroup retrieves the value of the leaf IncludeAnyGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAnyGroup is set, it can
// safely use t.GetIncludeAnyGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAnyGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetIncludeAnyGroup() []string {
	if t == nil || t.IncludeAnyGroup == nil {
		return nil
	}
	return t.IncludeAnyGroup
}

// SetExcludeGroup sets the value of the leaf ExcludeGroup in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) SetExcludeGroup(v []string) {
	t.ExcludeGroup = v
}

// SetIncludeAllGroup sets the value of the leaf IncludeAllGroup in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) SetIncludeAllGroup(v []string) {
	t.IncludeAllGroup = v
}

// SetIncludeAnyGroup sets the value of the leaf IncludeAnyGroup in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) SetIncludeAnyGroup(v []string) {
	t.IncludeAnyGroup = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct {
	Active        *bool   `path:"state/active" module:"openconfig-network-instance/openconfig-network-instance"`
	Priority      *uint16 `path:"state/priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SecondaryPath *string `path:"state/secondary-path|secondary-path" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/secondary-path|secondary-path" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) IsYANGGoStruct() {
}

// GetActive retrieves the value of the leaf Active from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Active is set, it can
// safely use t.GetActive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Active == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetActive() bool {
	if t == nil || t.Active == nil {
		return false
	}
	return *t.Active
}

// GetPriority retrieves the value of the leaf Priority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetPriority() uint16 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// GetSecondaryPath retrieves the value of the leaf SecondaryPath from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecondaryPath is set, it can
// safely use t.GetSecondaryPath() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecondaryPath == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetSecondaryPath() string {
	if t == nil || t.SecondaryPath == nil {
		return ""
	}
	return *t.SecondaryPath
}

// SetActive sets the value of the leaf Active in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) SetActive(v bool) {
	t.Active = &v
}

// SetPriority sets the value of the leaf Priority in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) SetPriority(v uint16) {
	t.Priority = &v
}

// SetSecondaryPath sets the value of the leaf SecondaryPath in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) SetSecondaryPath(v string) {
	t.SecondaryPath = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SecondaryPath == nil {
		return nil, fmt.Errorf("nil value for key SecondaryPath")
	}

	return map[string]interface{}{
		"secondary-path": *t.SecondaryPath,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint struct {
	MetricUpperBound *uint64                      `path:"state/metric-upper-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric-upper-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Type             E_MplsTypes_PATH_METRIC_TYPE `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/type|type" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) IsYANGGoStruct() {
}

// GetMetricUpperBound retrieves the value of the leaf MetricUpperBound from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricUpperBound is set, it can
// safely use t.GetMetricUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricUpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) GetMetricUpperBound() uint64 {
	if t == nil || t.MetricUpperBound == nil {
		return 0
	}
	return *t.MetricUpperBound
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) GetType() E_MplsTypes_PATH_METRIC_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetMetricUpperBound sets the value of the leaf MetricUpperBound in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) SetMetricUpperBound(v uint64) {
	t.MetricUpperBound = &v
}

// SetType sets the value of the leaf Type in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) SetType(v E_MplsTypes_PATH_METRIC_TYPE) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MetricUpperBound == nil {
		var v uint64 = 0
		t.MetricUpperBound = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct {
	AdminGroups               *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups                                                `path:"admin-groups" module:"openconfig-network-instance"`
	AssociatedRsvpSessions    []uint64                                                                                                                                          `path:"state/associated-rsvp-sessions" module:"openconfig-network-instance/openconfig-network-instance"`
	CspfMetric                *uint64                                                                                                                                           `path:"state/cspf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	CspfTiebreaker            E_Mpls_CspfTieBreaking                                                                                                                            `path:"state/cspf-tiebreaker" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/cspf-tiebreaker" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ExplicitPathName          *string                                                                                                                                           `path:"state/explicit-path-name" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/explicit-path-name" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HoldPriority              *uint8                                                                                                                                            `path:"state/hold-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hold-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name                      *string                                                                                                                                           `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	PathComputationMethod     E_MplsTypes_PATH_COMPUTATION_METHOD                                                                                                               `path:"state/path-computation-method" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-computation-method" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathComputationServer     *string                                                                                                                                           `path:"state/path-computation-server" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-computation-server" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathControl               E_Pcep_LspControlType                                                                                                                             `path:"state/path-control" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-control" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathMetricBoundConstraint map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint `path:"path-metric-bound-constraints/path-metric-bound-constraint" module:"openconfig-network-instance/openconfig-network-instance"`
	Preference                *uint8                                                                                                                                            `path:"state/preference" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/preference" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RetryTimer                *uint16                                                                                                                                           `path:"state/retry-timer" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/retry-timer" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SetupPriority             *uint8                                                                                                                                            `path:"state/setup-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/setup-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SpfMetric                 *uint64                                                                                                                                           `path:"state/spf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	UseCspf                   *bool                                                                                                                                             `path:"state/use-cspf" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/use-cspf" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) IsYANGGoStruct() {
}

// NewPathMetricBoundConstraint creates a new entry in the PathMetricBoundConstraint list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) NewPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PathMetricBoundConstraint", key)
	}

	t.PathMetricBoundConstraint[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
		Type: Type,
	}

	return t.PathMetricBoundConstraint[key], nil
}

// RenamePathMetricBoundConstraint renames an entry in the list PathMetricBoundConstraint within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) RenamePathMetricBoundConstraint(oldK, newK E_MplsTypes_PATH_METRIC_TYPE) error {
	if _, ok := t.PathMetricBoundConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in PathMetricBoundConstraint", newK)
	}

	e, ok := t.PathMetricBoundConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PathMetricBoundConstraint", oldK)
	}
	e.Type = newK

	t.PathMetricBoundConstraint[newK] = e
	delete(t.PathMetricBoundConstraint, oldK)
	return nil
}

// GetOrCreatePathMetricBoundConstraintMap returns the list (map) from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreatePathMetricBoundConstraintMap() map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
	}
	return t.PathMetricBoundConstraint
}

// GetOrCreatePathMetricBoundConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreatePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {

	key := Type

	if v, ok := t.PathMetricBoundConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPathMetricBoundConstraint(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePathMetricBoundConstraint got unexpected error: %v", err))
	}
	return v
}

// GetPathMetricBoundConstraint retrieves the value with the specified key from
// the PathMetricBoundConstraint map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.PathMetricBoundConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeletePathMetricBoundConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) DeletePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) {
	key := Type

	delete(t.PathMetricBoundConstraint, key)
}

// AppendPathMetricBoundConstraint appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct to the
// list PathMetricBoundConstraint of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) AppendPathMetricBoundConstraint(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
	}

	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list PathMetricBoundConstraint %v", key)
	}

	t.PathMetricBoundConstraint[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if t.AdminGroups != nil {
		return t.AdminGroups
	}
	t.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	return t.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if t != nil && t.AdminGroups != nil {
		return t.AdminGroups
	}
	return nil
}

// GetAssociatedRsvpSessions retrieves the value of the leaf AssociatedRsvpSessions from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedRsvpSessions is set, it can
// safely use t.GetAssociatedRsvpSessions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedRsvpSessions == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAssociatedRsvpSessions() []uint64 {
	if t == nil || t.AssociatedRsvpSessions == nil {
		return nil
	}
	return t.AssociatedRsvpSessions
}

// GetCspfMetric retrieves the value of the leaf CspfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfMetric is set, it can
// safely use t.GetCspfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetCspfMetric() uint64 {
	if t == nil || t.CspfMetric == nil {
		return 0
	}
	return *t.CspfMetric
}

// GetCspfTiebreaker retrieves the value of the leaf CspfTiebreaker from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfTiebreaker is set, it can
// safely use t.GetCspfTiebreaker() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfTiebreaker == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetCspfTiebreaker() E_Mpls_CspfTieBreaking {
	if t == nil || t.CspfTiebreaker == 0 {
		return Mpls_CspfTieBreaking_RANDOM
	}
	return t.CspfTiebreaker
}

// GetExplicitPathName retrieves the value of the leaf ExplicitPathName from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExplicitPathName is set, it can
// safely use t.GetExplicitPathName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExplicitPathName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetExplicitPathName() string {
	if t == nil || t.ExplicitPathName == nil {
		return ""
	}
	return *t.ExplicitPathName
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPathComputationMethod retrieves the value of the leaf PathComputationMethod from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationMethod is set, it can
// safely use t.GetPathComputationMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationMethod == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathComputationMethod() E_MplsTypes_PATH_COMPUTATION_METHOD {
	if t == nil || t.PathComputationMethod == 0 {
		return MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	return t.PathComputationMethod
}

// GetPathComputationServer retrieves the value of the leaf PathComputationServer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationServer is set, it can
// safely use t.GetPathComputationServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationServer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathComputationServer() string {
	if t == nil || t.PathComputationServer == nil {
		return ""
	}
	return *t.PathComputationServer
}

// GetPathControl retrieves the value of the leaf PathControl from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathControl is set, it can
// safely use t.GetPathControl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathControl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathControl() E_Pcep_LspControlType {
	if t == nil || t.PathControl == 0 {
		return 0
	}
	return t.PathControl
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetRetryTimer retrieves the value of the leaf RetryTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RetryTimer is set, it can
// safely use t.GetRetryTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RetryTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetRetryTimer() uint16 {
	if t == nil || t.RetryTimer == nil {
		return 0
	}
	return *t.RetryTimer
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetSpfMetric retrieves the value of the leaf SpfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpfMetric is set, it can
// safely use t.GetSpfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetSpfMetric() uint64 {
	if t == nil || t.SpfMetric == nil {
		return 0
	}
	return *t.SpfMetric
}

// GetUseCspf retrieves the value of the leaf UseCspf from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseCspf is set, it can
// safely use t.GetUseCspf() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseCspf == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetUseCspf() bool {
	if t == nil || t.UseCspf == nil {
		return false
	}
	return *t.UseCspf
}

// SetAssociatedRsvpSessions sets the value of the leaf AssociatedRsvpSessions in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetAssociatedRsvpSessions(v []uint64) {
	t.AssociatedRsvpSessions = v
}

// SetCspfMetric sets the value of the leaf CspfMetric in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetCspfMetric(v uint64) {
	t.CspfMetric = &v
}

// SetCspfTiebreaker sets the value of the leaf CspfTiebreaker in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetCspfTiebreaker(v E_Mpls_CspfTieBreaking) {
	t.CspfTiebreaker = v
}

// SetExplicitPathName sets the value of the leaf ExplicitPathName in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetExplicitPathName(v string) {
	t.ExplicitPathName = &v
}

// SetHoldPriority sets the value of the leaf HoldPriority in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetHoldPriority(v uint8) {
	t.HoldPriority = &v
}

// SetName sets the value of the leaf Name in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetName(v string) {
	t.Name = &v
}

// SetPathComputationMethod sets the value of the leaf PathComputationMethod in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetPathComputationMethod(v E_MplsTypes_PATH_COMPUTATION_METHOD) {
	t.PathComputationMethod = v
}

// SetPathComputationServer sets the value of the leaf PathComputationServer in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetPathComputationServer(v string) {
	t.PathComputationServer = &v
}

// SetPathControl sets the value of the leaf PathControl in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetPathControl(v E_Pcep_LspControlType) {
	t.PathControl = v
}

// SetPreference sets the value of the leaf Preference in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetPreference(v uint8) {
	t.Preference = &v
}

// SetRetryTimer sets the value of the leaf RetryTimer in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetRetryTimer(v uint16) {
	t.RetryTimer = &v
}

// SetSetupPriority sets the value of the leaf SetupPriority in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetSetupPriority(v uint8) {
	t.SetupPriority = &v
}

// SetSpfMetric sets the value of the leaf SpfMetric in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetSpfMetric(v uint64) {
	t.SpfMetric = &v
}

// SetUseCspf sets the value of the leaf UseCspf in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) SetUseCspf(v bool) {
	t.UseCspf = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CspfTiebreaker == 0 {
		t.CspfTiebreaker = Mpls_CspfTieBreaking_RANDOM
	}
	if t.HoldPriority == nil {
		var v uint8 = 0
		t.HoldPriority = &v
	}
	if t.PathComputationMethod == 0 {
		t.PathComputationMethod = MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	if t.SetupPriority == nil {
		var v uint8 = 7
		t.SetupPriority = &v
	}
	t.AdminGroups.PopulateDefaults()
	for _, e := range t.PathMetricBoundConstraint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups struct {
	ExcludeGroup    []string `path:"state/exclude-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/exclude-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IncludeAllGroup []string `path:"state/include-all-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/include-all-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IncludeAnyGroup []string `path:"state/include-any-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/include-any-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) IsYANGGoStruct() {
}

// GetExcludeGroup retrieves the value of the leaf ExcludeGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExcludeGroup is set, it can
// safely use t.GetExcludeGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExcludeGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetExcludeGroup() []string {
	if t == nil || t.ExcludeGroup == nil {
		return nil
	}
	return t.ExcludeGroup
}

// GetIncludeAllGroup retrieves the value of the leaf IncludeAllGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAllGroup is set, it can
// safely use t.GetIncludeAllGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAllGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetIncludeAllGroup() []string {
	if t == nil || t.IncludeAllGroup == nil {
		return nil
	}
	return t.IncludeAllGroup
}

// GetIncludeAnyGroup retrieves the value of the leaf IncludeAnyGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAnyGroup is set, it can
// safely use t.GetIncludeAnyGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAnyGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetIncludeAnyGroup() []string {
	if t == nil || t.IncludeAnyGroup == nil {
		return nil
	}
	return t.IncludeAnyGroup
}

// SetExcludeGroup sets the value of the leaf ExcludeGroup in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) SetExcludeGroup(v []string) {
	t.ExcludeGroup = v
}

// SetIncludeAllGroup sets the value of the leaf IncludeAllGroup in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) SetIncludeAllGroup(v []string) {
	t.IncludeAllGroup = v
}

// SetIncludeAnyGroup sets the value of the leaf IncludeAnyGroup in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) SetIncludeAnyGroup(v []string) {
	t.IncludeAnyGroup = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct {
	MetricUpperBound *uint64                      `path:"state/metric-upper-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric-upper-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Type             E_MplsTypes_PATH_METRIC_TYPE `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/type|type" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) IsYANGGoStruct() {
}

// GetMetricUpperBound retrieves the value of the leaf MetricUpperBound from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricUpperBound is set, it can
// safely use t.GetMetricUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricUpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) GetMetricUpperBound() uint64 {
	if t == nil || t.MetricUpperBound == nil {
		return 0
	}
	return *t.MetricUpperBound
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) GetType() E_MplsTypes_PATH_METRIC_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// SetMetricUpperBound sets the value of the leaf MetricUpperBound in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) SetMetricUpperBound(v uint64) {
	t.MetricUpperBound = &v
}

// SetType sets the value of the leaf Type in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// struct.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) SetType(v E_MplsTypes_PATH_METRIC_TYPE) {
	t.Type = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MetricUpperBound == nil {
		var v uint64 = 0
		t.MetricUpperBound = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp struct {
	Egress  *NetworkInstance_Mpls_Lsps_StaticLsp_Egress  `path:"egress" module:"openconfig-network-instance"`
	Ingress *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress `path:"ingress" module:"openconfig-network-instance"`
	Name    *string                                      `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Transit *NetworkInstance_Mpls_Lsps_StaticLsp_Transit `path:"transit" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp) IsYANGGoStruct() {}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if t.Egress != nil {
		return t.Egress
	}
	t.Egress = &NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	return t.Egress
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if t.Ingress != nil {
		return t.Ingress
	}
	t.Ingress = &NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	return t.Ingress
}

// GetOrCreateTransit retrieves the value of the Transit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if t.Transit != nil {
		return t.Transit
	}
	t.Transit = &NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	return t.Transit
}

// GetEgress returns the value of the Egress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if t != nil && t.Egress != nil {
		return t.Egress
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if t != nil && t.Ingress != nil {
		return t.Ingress
	}
	return nil
}

// GetTransit returns the value of the Transit struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Transit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if t != nil && t.Transit != nil {
		return t.Transit
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_StaticLsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// SetName sets the value of the leaf Name in the NetworkInstance_Mpls_Lsps_StaticLsp
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) SetName(v string) {
	t.Name = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Egress.PopulateDefaults()
	t.Ingress.PopulateDefaults()
	t.Transit.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_StaticLsp struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp.
func (*NetworkInstance_Mpls_Lsps_StaticLsp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Egress represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Egress struct {
	IncomingLabel NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union    `path:"state/incoming-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/incoming-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Interface     *string                                                           `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LspNextHop    map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop `path:"lsp-next-hops/lsp-next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Metric        *uint8                                                            `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *string                                                           `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/next-hop" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel     NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union        `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface  *uint32                                                           `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Egress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Egress) IsYANGGoStruct() {}

// NewLspNextHop creates a new entry in the LspNextHop list of the
// NetworkInstance_Mpls_Lsps_StaticLsp_Egress struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) NewLspNextHop(Index uint32) (*NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LspNextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LspNextHop", key)
	}

	t.LspNextHop[key] = &NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop{
		Index: &Index,
	}

	return t.LspNextHop[key], nil
}

// RenameLspNextHop renames an entry in the list LspNextHop within
// the NetworkInstance_Mpls_Lsps_StaticLsp_Egress struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) RenameLspNextHop(oldK, newK uint32) error {
	if _, ok := t.LspNextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in LspNextHop", newK)
	}

	e, ok := t.LspNextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LspNextHop", oldK)
	}
	e.Index = &newK

	t.LspNextHop[newK] = e
	delete(t.LspNextHop, oldK)
	return nil
}

// GetOrCreateLspNextHopMap returns the list (map) from NetworkInstance_Mpls_Lsps_StaticLsp_Egress.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetOrCreateLspNextHopMap() map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop {
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop)
	}
	return t.LspNextHop
}

// GetOrCreateLspNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_StaticLsp_Egress. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetOrCreateLspNextHop(Index uint32) *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop {

	key := Index

	if v, ok := t.LspNextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLspNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLspNextHop got unexpected error: %v", err))
	}
	return v
}

// GetLspNextHop retrieves the value with the specified key from
// the LspNextHop map field of NetworkInstance_Mpls_Lsps_StaticLsp_Egress. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetLspNextHop(Index uint32) *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.LspNextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteLspNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_StaticLsp_Egress. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) DeleteLspNextHop(Index uint32) {
	key := Index

	delete(t.LspNextHop, key)
}

// AppendLspNextHop appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop struct to the
// list LspNextHop of NetworkInstance_Mpls_Lsps_StaticLsp_Egress. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) AppendLspNextHop(v *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop)
	}

	if _, ok := t.LspNextHop[key]; ok {
		return fmt.Errorf("duplicate key for list LspNextHop %v", key)
	}

	t.LspNextHop[key] = v
	return nil
}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetMetric() uint8 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetIncomingLabel sets the value of the leaf IncomingLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) SetIncomingLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) {
	t.IncomingLabel = v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) SetInterface(v string) {
	t.Interface = &v
}

// SetMetric sets the value of the leaf Metric in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) SetMetric(v uint8) {
	t.Metric = &v
}

// SetNextHop sets the value of the leaf NextHop in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) SetNextHop(v string) {
	t.NextHop = &v
}

// SetPushLabel sets the value of the leaf PushLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) SetPushLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) {
	t.PushLabel = v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LspNextHop {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Egress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Egress.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/lsp-next-hops/lsp-next-hop YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop struct {
	Index        *uint32                                                               `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/index|index" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Interface    *string                                                               `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpAddress    *string                                                               `path:"state/ip-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel    NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop_PushLabel_Union `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32                                                               `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetIpAddress retrieves the value of the leaf IpAddress from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) SetIndex(v uint32) {
	t.Index = &v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) SetInterface(v string) {
	t.Interface = &v
}

// SetIpAddress sets the value of the leaf IpAddress in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) SetIpAddress(v string) {
	t.IpAddress = &v
}

// SetPushLabel sets the value of the leaf PushLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) SetPushLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop_PushLabel_Union) {
	t.PushLabel = v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Egress_LspNextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Ingress represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Ingress struct {
	IncomingLabel NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union    `path:"state/incoming-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/incoming-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Interface     *string                                                            `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LspNextHop    map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop `path:"lsp-next-hops/lsp-next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Metric        *uint8                                                             `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *string                                                            `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/next-hop" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel     NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union        `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface  *uint32                                                            `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Ingress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) IsYANGGoStruct() {}

// NewLspNextHop creates a new entry in the LspNextHop list of the
// NetworkInstance_Mpls_Lsps_StaticLsp_Ingress struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) NewLspNextHop(Index uint32) (*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LspNextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LspNextHop", key)
	}

	t.LspNextHop[key] = &NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop{
		Index: &Index,
	}

	return t.LspNextHop[key], nil
}

// RenameLspNextHop renames an entry in the list LspNextHop within
// the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) RenameLspNextHop(oldK, newK uint32) error {
	if _, ok := t.LspNextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in LspNextHop", newK)
	}

	e, ok := t.LspNextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LspNextHop", oldK)
	}
	e.Index = &newK

	t.LspNextHop[newK] = e
	delete(t.LspNextHop, oldK)
	return nil
}

// GetOrCreateLspNextHopMap returns the list (map) from NetworkInstance_Mpls_Lsps_StaticLsp_Ingress.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetOrCreateLspNextHopMap() map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop {
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop)
	}
	return t.LspNextHop
}

// GetOrCreateLspNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_StaticLsp_Ingress. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetOrCreateLspNextHop(Index uint32) *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop {

	key := Index

	if v, ok := t.LspNextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLspNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLspNextHop got unexpected error: %v", err))
	}
	return v
}

// GetLspNextHop retrieves the value with the specified key from
// the LspNextHop map field of NetworkInstance_Mpls_Lsps_StaticLsp_Ingress. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetLspNextHop(Index uint32) *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.LspNextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteLspNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_StaticLsp_Ingress. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) DeleteLspNextHop(Index uint32) {
	key := Index

	delete(t.LspNextHop, key)
}

// AppendLspNextHop appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop struct to the
// list LspNextHop of NetworkInstance_Mpls_Lsps_StaticLsp_Ingress. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) AppendLspNextHop(v *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop)
	}

	if _, ok := t.LspNextHop[key]; ok {
		return fmt.Errorf("duplicate key for list LspNextHop %v", key)
	}

	t.LspNextHop[key] = v
	return nil
}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetMetric() uint8 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetIncomingLabel sets the value of the leaf IncomingLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) SetIncomingLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) {
	t.IncomingLabel = v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) SetInterface(v string) {
	t.Interface = &v
}

// SetMetric sets the value of the leaf Metric in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) SetMetric(v uint8) {
	t.Metric = &v
}

// SetNextHop sets the value of the leaf NextHop in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) SetNextHop(v string) {
	t.NextHop = &v
}

// SetPushLabel sets the value of the leaf PushLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) SetPushLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) {
	t.PushLabel = v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LspNextHop {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Ingress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Ingress.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/lsp-next-hops/lsp-next-hop YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop struct {
	Index        *uint32                                                                `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/index|index" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Interface    *string                                                                `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpAddress    *string                                                                `path:"state/ip-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel    NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop_PushLabel_Union `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32                                                                `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetIpAddress retrieves the value of the leaf IpAddress from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) SetIndex(v uint32) {
	t.Index = &v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) SetInterface(v string) {
	t.Interface = &v
}

// SetIpAddress sets the value of the leaf IpAddress in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) SetIpAddress(v string) {
	t.IpAddress = &v
}

// SetPushLabel sets the value of the leaf PushLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) SetPushLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop_PushLabel_Union) {
	t.PushLabel = v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_LspNextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Transit represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Transit struct {
	IncomingLabel NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union    `path:"state/incoming-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/incoming-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Interface     *string                                                            `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LspNextHop    map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop `path:"lsp-next-hops/lsp-next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Metric        *uint8                                                             `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *string                                                            `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/next-hop" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel     NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union        `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface  *uint32                                                            `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Transit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Transit) IsYANGGoStruct() {}

// NewLspNextHop creates a new entry in the LspNextHop list of the
// NetworkInstance_Mpls_Lsps_StaticLsp_Transit struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) NewLspNextHop(Index uint32) (*NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LspNextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LspNextHop", key)
	}

	t.LspNextHop[key] = &NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop{
		Index: &Index,
	}

	return t.LspNextHop[key], nil
}

// RenameLspNextHop renames an entry in the list LspNextHop within
// the NetworkInstance_Mpls_Lsps_StaticLsp_Transit struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) RenameLspNextHop(oldK, newK uint32) error {
	if _, ok := t.LspNextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in LspNextHop", newK)
	}

	e, ok := t.LspNextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LspNextHop", oldK)
	}
	e.Index = &newK

	t.LspNextHop[newK] = e
	delete(t.LspNextHop, oldK)
	return nil
}

// GetOrCreateLspNextHopMap returns the list (map) from NetworkInstance_Mpls_Lsps_StaticLsp_Transit.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetOrCreateLspNextHopMap() map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop {
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop)
	}
	return t.LspNextHop
}

// GetOrCreateLspNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_StaticLsp_Transit. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetOrCreateLspNextHop(Index uint32) *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop {

	key := Index

	if v, ok := t.LspNextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLspNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLspNextHop got unexpected error: %v", err))
	}
	return v
}

// GetLspNextHop retrieves the value with the specified key from
// the LspNextHop map field of NetworkInstance_Mpls_Lsps_StaticLsp_Transit. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetLspNextHop(Index uint32) *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.LspNextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteLspNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_StaticLsp_Transit. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) DeleteLspNextHop(Index uint32) {
	key := Index

	delete(t.LspNextHop, key)
}

// AppendLspNextHop appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop struct to the
// list LspNextHop of NetworkInstance_Mpls_Lsps_StaticLsp_Transit. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) AppendLspNextHop(v *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LspNextHop == nil {
		t.LspNextHop = make(map[uint32]*NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop)
	}

	if _, ok := t.LspNextHop[key]; ok {
		return fmt.Errorf("duplicate key for list LspNextHop %v", key)
	}

	t.LspNextHop[key] = v
	return nil
}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetMetric() uint8 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetIncomingLabel sets the value of the leaf IncomingLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) SetIncomingLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) {
	t.IncomingLabel = v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) SetInterface(v string) {
	t.Interface = &v
}

// SetMetric sets the value of the leaf Metric in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) SetMetric(v uint8) {
	t.Metric = &v
}

// SetNextHop sets the value of the leaf NextHop in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) SetNextHop(v string) {
	t.NextHop = &v
}

// SetPushLabel sets the value of the leaf PushLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) SetPushLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) {
	t.PushLabel = v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LspNextHop {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Transit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Transit.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/lsp-next-hops/lsp-next-hop YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop struct {
	Index        *uint32                                                                `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/index|index" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Interface    *string                                                                `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpAddress    *string                                                                `path:"state/ip-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel    NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop_PushLabel_Union `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32                                                                `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetIpAddress retrieves the value of the leaf IpAddress from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetIndex sets the value of the leaf Index in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) SetIndex(v uint32) {
	t.Index = &v
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) SetInterface(v string) {
	t.Interface = &v
}

// SetIpAddress sets the value of the leaf IpAddress in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) SetIpAddress(v string) {
	t.IpAddress = &v
}

// SetPushLabel sets the value of the leaf PushLabel in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) SetPushLabel(v NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop_PushLabel_Union) {
	t.PushLabel = v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// struct.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Transit_LspNextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath struct {
	PathSetupProtocol *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol `path:"path-setup-protocol" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath) IsYANGGoStruct() {}

// GetOrCreatePathSetupProtocol retrieves the value of the PathSetupProtocol field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetOrCreatePathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if t.PathSetupProtocol != nil {
		return t.PathSetupProtocol
	}
	t.PathSetupProtocol = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	return t.PathSetupProtocol
}

// GetPathSetupProtocol returns the value of the PathSetupProtocol struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath. If the receiver or the field PathSetupProtocol is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetPathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if t != nil && t.PathSetupProtocol != nil {
		return t.PathSetupProtocol
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PathSetupProtocol.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_UnconstrainedPath.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol struct {
	Ldp *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp `path:"ldp" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) IsYANGGoStruct() {}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetOrCreateLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if t.Ldp != nil {
		return t.Ldp
	}
	t.Ldp = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	return t.Ldp
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if t != nil && t.Ldp != nil {
		return t.Ldp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ldp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp struct {
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols struct {
	Ldp            *NetworkInstance_Mpls_SignalingProtocols_Ldp            `path:"ldp" module:"openconfig-network-instance"`
	RsvpTe         *NetworkInstance_Mpls_SignalingProtocols_RsvpTe         `path:"rsvp-te" module:"openconfig-network-instance"`
	SegmentRouting *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting `path:"segment-routing" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols) IsYANGGoStruct() {}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if t.Ldp != nil {
		return t.Ldp
	}
	t.Ldp = &NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	return t.Ldp
}

// GetOrCreateRsvpTe retrieves the value of the RsvpTe field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if t.RsvpTe != nil {
		return t.RsvpTe
	}
	t.RsvpTe = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	return t.RsvpTe
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	return t.SegmentRouting
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if t != nil && t.Ldp != nil {
		return t.Ldp
	}
	return nil
}

// GetRsvpTe returns the value of the RsvpTe struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field RsvpTe is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if t != nil && t.RsvpTe != nil {
		return t.RsvpTe
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ldp.PopulateDefaults()
	t.RsvpTe.PopulateDefaults()
	t.SegmentRouting.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols.
func (*NetworkInstance_Mpls_SignalingProtocols) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp struct {
	Global              *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global                                                                `path:"global" module:"openconfig-network-instance"`
	InterfaceAttributes *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes                                                   `path:"interface-attributes" module:"openconfig-network-instance"`
	Neighbor            map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor `path:"neighbors/neighbor" module:"openconfig-network-instance/openconfig-network-instance"`
	Targeted            *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted                                                              `path:"targeted" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp) IsYANGGoStruct() {}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key represents the key for list Neighbor of element /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key struct {
	LsrId        string `path:"lsr-id"`
	LabelSpaceId uint16 `path:"label-space-id"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key key struct.
func (t NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"lsr-id":         t.LsrId,
		"label-space-id": t.LabelSpaceId,
	}, nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) NewNeighbor(LsrId string, LabelSpaceId uint16) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
		LsrId:        &LsrId,
		LabelSpaceId: &LabelSpaceId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) RenameNeighbor(oldK, newK NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.LsrId = &newK.LsrId
	e.LabelSpaceId = &newK.LabelSpaceId

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighborMap returns the list (map) from NetworkInstance_Mpls_SignalingProtocols_Ldp.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateNeighborMap() map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}
	return t.Neighbor
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateNeighbor(LsrId string, LabelSpaceId uint16) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(LsrId, LabelSpaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetNeighbor(LsrId string, LabelSpaceId uint16) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) DeleteNeighbor(LsrId string, LabelSpaceId uint16) {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct to the
// list Neighbor of NetworkInstance_Mpls_SignalingProtocols_Ldp. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) AppendNeighbor(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) error {
	if v.LsrId == nil {
		return fmt.Errorf("invalid nil key for LsrId")
	}

	if v.LabelSpaceId == nil {
		return fmt.Errorf("invalid nil key for LabelSpaceId")
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        *v.LsrId,
		LabelSpaceId: *v.LabelSpaceId,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateGlobal() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	return t.Global
}

// GetOrCreateInterfaceAttributes retrieves the value of the InterfaceAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateInterfaceAttributes() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	if t.InterfaceAttributes != nil {
		return t.InterfaceAttributes
	}
	t.InterfaceAttributes = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	return t.InterfaceAttributes
}

// GetOrCreateTargeted retrieves the value of the Targeted field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateTargeted() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	if t.Targeted != nil {
		return t.Targeted
	}
	t.Targeted = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	return t.Targeted
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetGlobal() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetInterfaceAttributes returns the value of the InterfaceAttributes struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field InterfaceAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetInterfaceAttributes() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	if t != nil && t.InterfaceAttributes != nil {
		return t.InterfaceAttributes
	}
	return nil
}

// GetTargeted returns the value of the Targeted struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field Targeted is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetTargeted() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	if t != nil && t.Targeted != nil {
		return t.Targeted
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	t.InterfaceAttributes.PopulateDefaults()
	t.Targeted.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Global represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Global struct {
	Authentication  *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication  `path:"authentication" module:"openconfig-network-instance"`
	GracefulRestart *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart `path:"graceful-restart" module:"openconfig-network-instance"`
	LsrId           *string                                                             `path:"state/lsr-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsr-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	return t.Authentication
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetOrCreateGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Global. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetLsrId retrieves the value of the leaf LsrId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LsrId is set, it can
// safely use t.GetLsrId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LsrId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetLsrId() string {
	if t == nil || t.LsrId == nil {
		return ""
	}
	return *t.LsrId
}

// SetLsrId sets the value of the leaf LsrId in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) SetLsrId(v string) {
	t.LsrId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Authentication.PopulateDefaults()
	t.GracefulRestart.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_Global.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication struct {
	AuthenticationKey *string `path:"state/authentication-key" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/authentication-key" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable            *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) IsYANGGoStruct() {}

// GetAuthenticationKey retrieves the value of the leaf AuthenticationKey from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationKey is set, it can
// safely use t.GetAuthenticationKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationKey == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) GetAuthenticationKey() string {
	if t == nil || t.AuthenticationKey == nil {
		return ""
	}
	return *t.AuthenticationKey
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// SetAuthenticationKey sets the value of the leaf AuthenticationKey in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) SetAuthenticationKey(v string) {
	t.AuthenticationKey = &v
}

// SetEnable sets the value of the leaf Enable in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) SetEnable(v bool) {
	t.Enable = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart struct {
	Enabled            *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ForwardingHoldtime *uint16 `path:"state/forwarding-holdtime" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/forwarding-holdtime" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelperEnable       *bool   `path:"state/helper-enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/helper-enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReconnectTime      *uint16 `path:"state/reconnect-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/reconnect-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RecoveryTime       *uint16 `path:"state/recovery-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/recovery-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetForwardingHoldtime retrieves the value of the leaf ForwardingHoldtime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingHoldtime is set, it can
// safely use t.GetForwardingHoldtime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingHoldtime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetForwardingHoldtime() uint16 {
	if t == nil || t.ForwardingHoldtime == nil {
		return 0
	}
	return *t.ForwardingHoldtime
}

// GetHelperEnable retrieves the value of the leaf HelperEnable from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelperEnable is set, it can
// safely use t.GetHelperEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelperEnable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetHelperEnable() bool {
	if t == nil || t.HelperEnable == nil {
		return false
	}
	return *t.HelperEnable
}

// GetReconnectTime retrieves the value of the leaf ReconnectTime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReconnectTime is set, it can
// safely use t.GetReconnectTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReconnectTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetReconnectTime() uint16 {
	if t == nil || t.ReconnectTime == nil {
		return 0
	}
	return *t.ReconnectTime
}

// GetRecoveryTime retrieves the value of the leaf RecoveryTime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RecoveryTime is set, it can
// safely use t.GetRecoveryTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RecoveryTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetRecoveryTime() uint16 {
	if t == nil || t.RecoveryTime == nil {
		return 0
	}
	return *t.RecoveryTime
}

// SetEnabled sets the value of the leaf Enabled in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) SetEnabled(v bool) {
	t.Enabled = &v
}

// SetForwardingHoldtime sets the value of the leaf ForwardingHoldtime in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) SetForwardingHoldtime(v uint16) {
	t.ForwardingHoldtime = &v
}

// SetHelperEnable sets the value of the leaf HelperEnable in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) SetHelperEnable(v bool) {
	t.HelperEnable = &v
}

// SetReconnectTime sets the value of the leaf ReconnectTime in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) SetReconnectTime(v uint16) {
	t.ReconnectTime = &v
}

// SetRecoveryTime sets the value of the leaf RecoveryTime in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) SetRecoveryTime(v uint16) {
	t.RecoveryTime = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes struct {
	HelloHoldtime *uint16                                                                               `path:"state/hello-holdtime" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-holdtime" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloInterval *uint16                                                                               `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Interface     map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetOrCreateInterfaceMap() map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetHelloHoldtime retrieves the value of the leaf HelloHoldtime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloHoldtime is set, it can
// safely use t.GetHelloHoldtime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloHoldtime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetHelloHoldtime() uint16 {
	if t == nil || t.HelloHoldtime == nil {
		return 0
	}
	return *t.HelloHoldtime
}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetHelloInterval() uint16 {
	if t == nil || t.HelloInterval == nil {
		return 0
	}
	return *t.HelloInterval
}

// SetHelloHoldtime sets the value of the leaf HelloHoldtime in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) SetHelloHoldtime(v uint16) {
	t.HelloHoldtime = &v
}

// SetHelloInterval sets the value of the leaf HelloInterval in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) SetHelloInterval(v uint16) {
	t.HelloInterval = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct {
	AddressFamily map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily `path:"address-families/address-family" module:"openconfig-network-instance/openconfig-network-instance"`
	Counters      *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters                               `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	HelloHoldtime *uint16                                                                                                           `path:"state/hello-holdtime" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-holdtime" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloInterval *uint16                                                                                                           `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	InterfaceId   *string                                                                                                           `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef  *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef                           `path:"interface-ref" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) IsYANGGoStruct() {}

// NewAddressFamily creates a new entry in the AddressFamily list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) NewAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
	}

	key := AfiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AddressFamily[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AddressFamily", key)
	}

	t.AddressFamily[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
		AfiName: AfiName,
	}

	return t.AddressFamily[key], nil
}

// RenameAddressFamily renames an entry in the list AddressFamily within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) RenameAddressFamily(oldK, newK E_MplsLdp_MplsLdpAfi) error {
	if _, ok := t.AddressFamily[newK]; ok {
		return fmt.Errorf("key %v already exists in AddressFamily", newK)
	}

	e, ok := t.AddressFamily[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AddressFamily", oldK)
	}
	e.AfiName = newK

	t.AddressFamily[newK] = e
	delete(t.AddressFamily, oldK)
	return nil
}

// GetOrCreateAddressFamilyMap returns the list (map) from NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateAddressFamilyMap() map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
	}
	return t.AddressFamily
}

// GetOrCreateAddressFamily retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {

	key := AfiName

	if v, ok := t.AddressFamily[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddressFamily(AfiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddressFamily got unexpected error: %v", err))
	}
	return v
}

// GetAddressFamily retrieves the value with the specified key from
// the AddressFamily map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {

	if t == nil {
		return nil
	}

	key := AfiName

	if lm, ok := t.AddressFamily[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddressFamily deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) DeleteAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) {
	key := AfiName

	delete(t.AddressFamily, key)
}

// AppendAddressFamily appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily struct to the
// list AddressFamily of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) AppendAddressFamily(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) error {
	key := v.AfiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
	}

	if _, ok := t.AddressFamily[key]; ok {
		return fmt.Errorf("duplicate key for list AddressFamily %v", key)
	}

	t.AddressFamily[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	return t.Counters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetHelloHoldtime retrieves the value of the leaf HelloHoldtime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloHoldtime is set, it can
// safely use t.GetHelloHoldtime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloHoldtime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetHelloHoldtime() uint16 {
	if t == nil || t.HelloHoldtime == nil {
		return 0
	}
	return *t.HelloHoldtime
}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetHelloInterval() uint16 {
	if t == nil || t.HelloInterval == nil {
		return 0
	}
	return *t.HelloInterval
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// SetHelloHoldtime sets the value of the leaf HelloHoldtime in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) SetHelloHoldtime(v uint16) {
	t.HelloHoldtime = &v
}

// SetHelloInterval sets the value of the leaf HelloInterval in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) SetHelloInterval(v uint16) {
	t.HelloInterval = &v
}

// SetInterfaceId sets the value of the leaf InterfaceId in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) SetInterfaceId(v string) {
	t.InterfaceId = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
	for _, e := range t.AddressFamily {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily struct {
	AfiName E_MplsLdp_MplsLdpAfi `path:"state/afi-name|afi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/afi-name|afi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Enabled *bool                `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) IsYANGGoStruct() {
}

// GetAfiName retrieves the value of the leaf AfiName from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiName is set, it can
// safely use t.GetAfiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) GetAfiName() E_MplsLdp_MplsLdpAfi {
	if t == nil || t.AfiName == 0 {
		return 0
	}
	return t.AfiName
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// SetAfiName sets the value of the leaf AfiName in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) SetAfiName(v E_MplsLdp_MplsLdpAfi) {
	t.AfiName = v
}

// SetEnabled sets the value of the leaf Enabled in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) SetEnabled(v bool) {
	t.Enabled = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name": t.AfiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters struct {
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) IsYANGGoStruct() {
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// SetInterface sets the value of the leaf Interface in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) SetInterface(v string) {
	t.Interface = &v
}

// SetSubinterface sets the value of the leaf Subinterface in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) SetSubinterface(v uint32) {
	t.Subinterface = &v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct {
	Authentication                   *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication                                                                             `path:"authentication" module:"openconfig-network-instance"`
	EnableDownstreamOnDemand         *bool                                                                                                                                            `path:"state/enable-downstream-on-demand" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable-downstream-on-demand" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloAdjacency                   map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency `path:"hello-adjacencies/hello-adjacency" module:"openconfig-network-instance/openconfig-network-instance"`
	LabelSpaceId                     *uint16                                                                                                                                          `path:"state/label-space-id|label-space-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/label-space-id|label-space-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	LsrId                            *string                                                                                                                                          `path:"state/lsr-id|lsr-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/lsr-id|lsr-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	NegotiatedLabelAdvertisementMode E_MplsLdp_LabelAdvertisementMode                                                                                                                 `path:"state/negotiated-label-advertisement-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerLabelAdvertisementMode       E_MplsLdp_LabelAdvertisementMode                                                                                                                 `path:"state/peer-label-advertisement-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	SessionState                     E_MplsLdp_Neighbor_SessionState                                                                                                                  `path:"state/session-state" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) IsYANGGoStruct() {}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key represents the key for list HelloAdjacency of element /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key struct {
	RemoteAddress string `path:"remote-address"`
	LocalAddress  string `path:"local-address"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key key struct.
func (t NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"remote-address": t.RemoteAddress,
		"local-address":  t.LocalAddress,
	}, nil
}

// NewHelloAdjacency creates a new entry in the HelloAdjacency list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) NewHelloAdjacency(RemoteAddress string, LocalAddress string) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HelloAdjacency == nil {
		t.HelloAdjacency = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HelloAdjacency[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HelloAdjacency", key)
	}

	t.HelloAdjacency[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
		RemoteAddress: &RemoteAddress,
		LocalAddress:  &LocalAddress,
	}

	return t.HelloAdjacency[key], nil
}

// RenameHelloAdjacency renames an entry in the list HelloAdjacency within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) RenameHelloAdjacency(oldK, newK NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key) error {
	if _, ok := t.HelloAdjacency[newK]; ok {
		return fmt.Errorf("key %v already exists in HelloAdjacency", newK)
	}

	e, ok := t.HelloAdjacency[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HelloAdjacency", oldK)
	}
	e.RemoteAddress = &newK.RemoteAddress
	e.LocalAddress = &newK.LocalAddress

	t.HelloAdjacency[newK] = e
	delete(t.HelloAdjacency, oldK)
	return nil
}

// GetOrCreateHelloAdjacencyMap returns the list (map) from NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor.
//
// It initializes the field if not already initialized.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetOrCreateHelloAdjacencyMap() map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	if t.HelloAdjacency == nil {
		t.HelloAdjacency = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
	}
	return t.HelloAdjacency
}

// GetOrCreateHelloAdjacency retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetOrCreateHelloAdjacency(RemoteAddress string, LocalAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	if v, ok := t.HelloAdjacency[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHelloAdjacency(RemoteAddress, LocalAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHelloAdjacency got unexpected error: %v", err))
	}
	return v
}

// GetHelloAdjacency retrieves the value with the specified key from
// the HelloAdjacency map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetHelloAdjacency(RemoteAddress string, LocalAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	if lm, ok := t.HelloAdjacency[key]; ok {
		return lm
	}
	return nil
}

// DeleteHelloAdjacency deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) DeleteHelloAdjacency(RemoteAddress string, LocalAddress string) {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	delete(t.HelloAdjacency, key)
}

// AppendHelloAdjacency appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency struct to the
// list HelloAdjacency of NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) AppendHelloAdjacency(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) error {
	if v.RemoteAddress == nil {
		return fmt.Errorf("invalid nil key for RemoteAddress")
	}

	if v.LocalAddress == nil {
		return fmt.Errorf("invalid nil key for LocalAddress")
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: *v.RemoteAddress,
		LocalAddress:  *v.LocalAddress,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HelloAdjacency == nil {
		t.HelloAdjacency = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
	}

	if _, ok := t.HelloAdjacency[key]; ok {
		return fmt.Errorf("duplicate key for list HelloAdjacency %v", key)
	}

	t.HelloAdjacency[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	return t.Authentication
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetEnableDownstreamOnDemand retrieves the value of the leaf EnableDownstreamOnDemand from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableDownstreamOnDemand is set, it can
// safely use t.GetEnableDownstreamOnDemand() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableDownstreamOnDemand == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetEnableDownstreamOnDemand() bool {
	if t == nil || t.EnableDownstreamOnDemand == nil {
		return false
	}
	return *t.EnableDownstreamOnDemand
}

// GetLabelSpaceId retrieves the value of the leaf LabelSpaceId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelSpaceId is set, it can
// safely use t.GetLabelSpaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelSpaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetLabelSpaceId() uint16 {
	if t == nil || t.LabelSpaceId == nil {
		return 0
	}
	return *t.LabelSpaceId
}

// GetLsrId retrieves the value of the leaf LsrId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LsrId is set, it can
// safely use t.GetLsrId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LsrId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetLsrId() string {
	if t == nil || t.LsrId == nil {
		return ""
	}
	return *t.LsrId
}

// GetNegotiatedLabelAdvertisementMode retrieves the value of the leaf NegotiatedLabelAdvertisementMode from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NegotiatedLabelAdvertisementMode is set, it can
// safely use t.GetNegotiatedLabelAdvertisementMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NegotiatedLabelAdvertisementMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetNegotiatedLabelAdvertisementMode() E_MplsLdp_LabelAdvertisementMode {
	if t == nil || t.NegotiatedLabelAdvertisementMode == 0 {
		return 0
	}
	return t.NegotiatedLabelAdvertisementMode
}

// GetPeerLabelAdvertisementMode retrieves the value of the leaf PeerLabelAdvertisementMode from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerLabelAdvertisementMode is set, it can
// safely use t.GetPeerLabelAdvertisementMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerLabelAdvertisementMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetPeerLabelAdvertisementMode() E_MplsLdp_LabelAdvertisementMode {
	if t == nil || t.PeerLabelAdvertisementMode == 0 {
		return 0
	}
	return t.PeerLabelAdvertisementMode
}

// GetSessionState retrieves the value of the leaf SessionState from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionState is set, it can
// safely use t.GetSessionState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetSessionState() E_MplsLdp_Neighbor_SessionState {
	if t == nil || t.SessionState == 0 {
		return 0
	}
	return t.SessionState
}

// SetEnableDownstreamOnDemand sets the value of the leaf EnableDownstreamOnDemand in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) SetEnableDownstreamOnDemand(v bool) {
	t.EnableDownstreamOnDemand = &v
}

// SetLabelSpaceId sets the value of the leaf LabelSpaceId in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) SetLabelSpaceId(v uint16) {
	t.LabelSpaceId = &v
}

// SetLsrId sets the value of the leaf LsrId in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) SetLsrId(v string) {
	t.LsrId = &v
}

// SetNegotiatedLabelAdvertisementMode sets the value of the leaf NegotiatedLabelAdvertisementMode in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) SetNegotiatedLabelAdvertisementMode(v E_MplsLdp_LabelAdvertisementMode) {
	t.NegotiatedLabelAdvertisementMode = v
}

// SetPeerLabelAdvertisementMode sets the value of the leaf PeerLabelAdvertisementMode in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) SetPeerLabelAdvertisementMode(v E_MplsLdp_LabelAdvertisementMode) {
	t.PeerLabelAdvertisementMode = v
}

// SetSessionState sets the value of the leaf SessionState in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) SetSessionState(v E_MplsLdp_Neighbor_SessionState) {
	t.SessionState = v
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.EnableDownstreamOnDemand == nil {
		var v bool = false
		t.EnableDownstreamOnDemand = &v
	}
	t.Authentication.PopulateDefaults()
	for _, e := range t.HelloAdjacency {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LabelSpaceId == nil {
		return nil, fmt.Errorf("nil value for key LabelSpaceId")
	}

	if t.LsrId == nil {
		return nil, fmt.Errorf("nil value for key LsrId")
	}

	return map[string]interface{}{
		"label-space-id": *t.LabelSpaceId,
		"lsr-id":         *t.LsrId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) ΛBelongingModule() string {
	return "openconfig-network-instance"
}
