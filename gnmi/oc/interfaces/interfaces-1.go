/*
Package interfaces is a generated package which contains definitions
of structs which generate gNMI paths for a YANG schema.

This package was generated by ygnmi version: v0.11.1: (ygot: v0.29.18)
using the following YANG input files:
  - public/release/models/acl/openconfig-acl.yang
  - public/release/models/acl/openconfig-packet-match.yang
  - public/release/models/aft/openconfig-aft.yang
  - public/release/models/bfd/openconfig-bfd.yang
  - public/release/models/bgp/openconfig-bgp-policy.yang
  - public/release/models/bgp/openconfig-bgp-types.yang
  - public/release/models/interfaces/openconfig-if-aggregate.yang
  - public/release/models/interfaces/openconfig-if-ethernet.yang
  - public/release/models/interfaces/openconfig-if-ip-ext.yang
  - public/release/models/interfaces/openconfig-if-ip.yang
  - public/release/models/interfaces/openconfig-interfaces.yang
  - public/release/models/isis/openconfig-isis.yang
  - public/release/models/lacp/openconfig-lacp.yang
  - public/release/models/lldp/openconfig-lldp-types.yang
  - public/release/models/lldp/openconfig-lldp.yang
  - public/release/models/local-routing/openconfig-local-routing.yang
  - public/release/models/mpls/openconfig-mpls-types.yang
  - public/release/models/multicast/openconfig-pim.yang
  - public/release/models/network-instance/openconfig-network-instance.yang
  - public/release/models/openconfig-extensions.yang
  - public/release/models/optical-transport/openconfig-transport-types.yang
  - public/release/models/ospf/openconfig-ospfv2.yang
  - public/release/models/platform/openconfig-platform-cpu.yang
  - public/release/models/platform/openconfig-platform-integrated-circuit.yang
  - public/release/models/platform/openconfig-platform-software.yang
  - public/release/models/platform/openconfig-platform-transceiver.yang
  - public/release/models/platform/openconfig-platform.yang
  - public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
  - public/release/models/policy/openconfig-policy-types.yang
  - public/release/models/qos/openconfig-qos-elements.yang
  - public/release/models/qos/openconfig-qos-interfaces.yang
  - public/release/models/qos/openconfig-qos-types.yang
  - public/release/models/qos/openconfig-qos.yang
  - public/release/models/rib/openconfig-rib-bgp.yang
  - public/release/models/segment-routing/openconfig-segment-routing-types.yang
  - public/release/models/system/openconfig-system.yang
  - public/release/models/types/openconfig-inet-types.yang
  - public/release/models/types/openconfig-types.yang
  - public/release/models/types/openconfig-yang-types.yang
  - public/release/models/vlan/openconfig-vlan.yang
  - public/third_party/ietf/iana-if-type.yang
  - public/third_party/ietf/ietf-inet-types.yang
  - public/third_party/ietf/ietf-interfaces.yang
  - public/third_party/ietf/ietf-yang-types.yang
  - yang/openconfig-bgp-gue.yang

Imported modules were sourced from:
  - public/release/models/...
  - public/third_party/ietf/...
*/
package interfaces

import (
	"reflect"

	oc "github.com/openconfig/lemming/gnmi/oc"
	"github.com/openconfig/ygnmi/ygnmi"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Interface_Ethernet_EnableFlowControlPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/enable-flow-control YANG schema element.
type Interface_Ethernet_EnableFlowControlPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_EnableFlowControlPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/enable-flow-control YANG schema element.
type Interface_Ethernet_EnableFlowControlPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/enable-flow-control"
//	Path from root:       "/interfaces/interface/ethernet/state/enable-flow-control"
func (n *Interface_Ethernet_EnableFlowControlPath) State() ygnmi.SingletonQuery[bool] {
	return ygnmi.NewSingletonQuery[bool](
		"Interface_Ethernet",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "enable-flow-control"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_Ethernet).EnableFlowControl
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/enable-flow-control"
//	Path from root:       "/interfaces/interface/ethernet/state/enable-flow-control"
func (n *Interface_Ethernet_EnableFlowControlPathAny) State() ygnmi.WildcardQuery[bool] {
	return ygnmi.NewWildcardQuery[bool](
		"Interface_Ethernet",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "enable-flow-control"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_Ethernet).EnableFlowControl
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/enable-flow-control"
//	Path from root:       "/interfaces/interface/ethernet/config/enable-flow-control"
func (n *Interface_Ethernet_EnableFlowControlPath) Config() ygnmi.ConfigQuery[bool] {
	return ygnmi.NewConfigQuery[bool](
		"Interface_Ethernet",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "enable-flow-control"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_Ethernet).EnableFlowControl
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/enable-flow-control"
//	Path from root:       "/interfaces/interface/ethernet/config/enable-flow-control"
func (n *Interface_Ethernet_EnableFlowControlPathAny) Config() ygnmi.WildcardQuery[bool] {
	return ygnmi.NewWildcardQuery[bool](
		"Interface_Ethernet",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "enable-flow-control"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_Ethernet).EnableFlowControl
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_FecModePath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/fec-mode YANG schema element.
type Interface_Ethernet_FecModePath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_FecModePathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/fec-mode YANG schema element.
type Interface_Ethernet_FecModePathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/fec-mode"
//	Path from root:       "/interfaces/interface/ethernet/state/fec-mode"
func (n *Interface_Ethernet_FecModePath) State() ygnmi.SingletonQuery[oc.E_IfEthernet_INTERFACE_FEC] {
	return ygnmi.NewSingletonQuery[oc.E_IfEthernet_INTERFACE_FEC](
		"Interface_Ethernet",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "fec-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_INTERFACE_FEC, bool) {
			ret := gs.(*oc.Interface_Ethernet).FecMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/fec-mode"
//	Path from root:       "/interfaces/interface/ethernet/state/fec-mode"
func (n *Interface_Ethernet_FecModePathAny) State() ygnmi.WildcardQuery[oc.E_IfEthernet_INTERFACE_FEC] {
	return ygnmi.NewWildcardQuery[oc.E_IfEthernet_INTERFACE_FEC](
		"Interface_Ethernet",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "fec-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_INTERFACE_FEC, bool) {
			ret := gs.(*oc.Interface_Ethernet).FecMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/fec-mode"
//	Path from root:       "/interfaces/interface/ethernet/config/fec-mode"
func (n *Interface_Ethernet_FecModePath) Config() ygnmi.ConfigQuery[oc.E_IfEthernet_INTERFACE_FEC] {
	return ygnmi.NewConfigQuery[oc.E_IfEthernet_INTERFACE_FEC](
		"Interface_Ethernet",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "fec-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_INTERFACE_FEC, bool) {
			ret := gs.(*oc.Interface_Ethernet).FecMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/fec-mode"
//	Path from root:       "/interfaces/interface/ethernet/config/fec-mode"
func (n *Interface_Ethernet_FecModePathAny) Config() ygnmi.WildcardQuery[oc.E_IfEthernet_INTERFACE_FEC] {
	return ygnmi.NewWildcardQuery[oc.E_IfEthernet_INTERFACE_FEC](
		"Interface_Ethernet",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "fec-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_INTERFACE_FEC, bool) {
			ret := gs.(*oc.Interface_Ethernet).FecMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_HwMacAddressPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/hw-mac-address YANG schema element.
type Interface_Ethernet_HwMacAddressPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_HwMacAddressPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/hw-mac-address YANG schema element.
type Interface_Ethernet_HwMacAddressPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/hw-mac-address"
//	Path from root:       "/interfaces/interface/ethernet/state/hw-mac-address"
func (n *Interface_Ethernet_HwMacAddressPath) State() ygnmi.SingletonQuery[string] {
	return ygnmi.NewSingletonQuery[string](
		"Interface_Ethernet",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "hw-mac-address"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_Ethernet).HwMacAddress
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/hw-mac-address"
//	Path from root:       "/interfaces/interface/ethernet/state/hw-mac-address"
func (n *Interface_Ethernet_HwMacAddressPathAny) State() ygnmi.WildcardQuery[string] {
	return ygnmi.NewWildcardQuery[string](
		"Interface_Ethernet",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "hw-mac-address"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_Ethernet).HwMacAddress
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_MacAddressPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/mac-address YANG schema element.
type Interface_Ethernet_MacAddressPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_MacAddressPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/mac-address YANG schema element.
type Interface_Ethernet_MacAddressPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/mac-address"
//	Path from root:       "/interfaces/interface/ethernet/state/mac-address"
func (n *Interface_Ethernet_MacAddressPath) State() ygnmi.SingletonQuery[string] {
	return ygnmi.NewSingletonQuery[string](
		"Interface_Ethernet",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "mac-address"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_Ethernet).MacAddress
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/mac-address"
//	Path from root:       "/interfaces/interface/ethernet/state/mac-address"
func (n *Interface_Ethernet_MacAddressPathAny) State() ygnmi.WildcardQuery[string] {
	return ygnmi.NewWildcardQuery[string](
		"Interface_Ethernet",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "mac-address"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_Ethernet).MacAddress
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/mac-address"
//	Path from root:       "/interfaces/interface/ethernet/config/mac-address"
func (n *Interface_Ethernet_MacAddressPath) Config() ygnmi.ConfigQuery[string] {
	return ygnmi.NewConfigQuery[string](
		"Interface_Ethernet",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "mac-address"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_Ethernet).MacAddress
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/mac-address"
//	Path from root:       "/interfaces/interface/ethernet/config/mac-address"
func (n *Interface_Ethernet_MacAddressPathAny) Config() ygnmi.WildcardQuery[string] {
	return ygnmi.NewWildcardQuery[string](
		"Interface_Ethernet",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "mac-address"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_Ethernet).MacAddress
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_NegotiatedDuplexModePath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/negotiated-duplex-mode YANG schema element.
type Interface_Ethernet_NegotiatedDuplexModePath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_NegotiatedDuplexModePathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/negotiated-duplex-mode YANG schema element.
type Interface_Ethernet_NegotiatedDuplexModePathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/negotiated-duplex-mode"
//	Path from root:       "/interfaces/interface/ethernet/state/negotiated-duplex-mode"
func (n *Interface_Ethernet_NegotiatedDuplexModePath) State() ygnmi.SingletonQuery[oc.E_Ethernet_NegotiatedDuplexMode] {
	return ygnmi.NewSingletonQuery[oc.E_Ethernet_NegotiatedDuplexMode](
		"Interface_Ethernet",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "negotiated-duplex-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_Ethernet_NegotiatedDuplexMode, bool) {
			ret := gs.(*oc.Interface_Ethernet).NegotiatedDuplexMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/negotiated-duplex-mode"
//	Path from root:       "/interfaces/interface/ethernet/state/negotiated-duplex-mode"
func (n *Interface_Ethernet_NegotiatedDuplexModePathAny) State() ygnmi.WildcardQuery[oc.E_Ethernet_NegotiatedDuplexMode] {
	return ygnmi.NewWildcardQuery[oc.E_Ethernet_NegotiatedDuplexMode](
		"Interface_Ethernet",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "negotiated-duplex-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_Ethernet_NegotiatedDuplexMode, bool) {
			ret := gs.(*oc.Interface_Ethernet).NegotiatedDuplexMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_NegotiatedPortSpeedPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/negotiated-port-speed YANG schema element.
type Interface_Ethernet_NegotiatedPortSpeedPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_NegotiatedPortSpeedPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/negotiated-port-speed YANG schema element.
type Interface_Ethernet_NegotiatedPortSpeedPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/negotiated-port-speed"
//	Path from root:       "/interfaces/interface/ethernet/state/negotiated-port-speed"
func (n *Interface_Ethernet_NegotiatedPortSpeedPath) State() ygnmi.SingletonQuery[oc.E_IfEthernet_ETHERNET_SPEED] {
	return ygnmi.NewSingletonQuery[oc.E_IfEthernet_ETHERNET_SPEED](
		"Interface_Ethernet",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "negotiated-port-speed"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_ETHERNET_SPEED, bool) {
			ret := gs.(*oc.Interface_Ethernet).NegotiatedPortSpeed
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/negotiated-port-speed"
//	Path from root:       "/interfaces/interface/ethernet/state/negotiated-port-speed"
func (n *Interface_Ethernet_NegotiatedPortSpeedPathAny) State() ygnmi.WildcardQuery[oc.E_IfEthernet_ETHERNET_SPEED] {
	return ygnmi.NewWildcardQuery[oc.E_IfEthernet_ETHERNET_SPEED](
		"Interface_Ethernet",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "negotiated-port-speed"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_ETHERNET_SPEED, bool) {
			ret := gs.(*oc.Interface_Ethernet).NegotiatedPortSpeed
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_PortSpeedPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/port-speed YANG schema element.
type Interface_Ethernet_PortSpeedPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_PortSpeedPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/port-speed YANG schema element.
type Interface_Ethernet_PortSpeedPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/port-speed"
//	Path from root:       "/interfaces/interface/ethernet/state/port-speed"
func (n *Interface_Ethernet_PortSpeedPath) State() ygnmi.SingletonQuery[oc.E_IfEthernet_ETHERNET_SPEED] {
	return ygnmi.NewSingletonQuery[oc.E_IfEthernet_ETHERNET_SPEED](
		"Interface_Ethernet",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "port-speed"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_ETHERNET_SPEED, bool) {
			ret := gs.(*oc.Interface_Ethernet).PortSpeed
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/port-speed"
//	Path from root:       "/interfaces/interface/ethernet/state/port-speed"
func (n *Interface_Ethernet_PortSpeedPathAny) State() ygnmi.WildcardQuery[oc.E_IfEthernet_ETHERNET_SPEED] {
	return ygnmi.NewWildcardQuery[oc.E_IfEthernet_ETHERNET_SPEED](
		"Interface_Ethernet",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "port-speed"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_ETHERNET_SPEED, bool) {
			ret := gs.(*oc.Interface_Ethernet).PortSpeed
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/port-speed"
//	Path from root:       "/interfaces/interface/ethernet/config/port-speed"
func (n *Interface_Ethernet_PortSpeedPath) Config() ygnmi.ConfigQuery[oc.E_IfEthernet_ETHERNET_SPEED] {
	return ygnmi.NewConfigQuery[oc.E_IfEthernet_ETHERNET_SPEED](
		"Interface_Ethernet",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "port-speed"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_ETHERNET_SPEED, bool) {
			ret := gs.(*oc.Interface_Ethernet).PortSpeed
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/port-speed"
//	Path from root:       "/interfaces/interface/ethernet/config/port-speed"
func (n *Interface_Ethernet_PortSpeedPathAny) Config() ygnmi.WildcardQuery[oc.E_IfEthernet_ETHERNET_SPEED] {
	return ygnmi.NewWildcardQuery[oc.E_IfEthernet_ETHERNET_SPEED](
		"Interface_Ethernet",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "port-speed"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_IfEthernet_ETHERNET_SPEED, bool) {
			ret := gs.(*oc.Interface_Ethernet).PortSpeed
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_StandaloneLinkTrainingPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/standalone-link-training YANG schema element.
type Interface_Ethernet_StandaloneLinkTrainingPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_StandaloneLinkTrainingPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/standalone-link-training YANG schema element.
type Interface_Ethernet_StandaloneLinkTrainingPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/standalone-link-training"
//	Path from root:       "/interfaces/interface/ethernet/state/standalone-link-training"
func (n *Interface_Ethernet_StandaloneLinkTrainingPath) State() ygnmi.SingletonQuery[bool] {
	return ygnmi.NewSingletonQuery[bool](
		"Interface_Ethernet",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "standalone-link-training"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_Ethernet).StandaloneLinkTraining
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "state/standalone-link-training"
//	Path from root:       "/interfaces/interface/ethernet/state/standalone-link-training"
func (n *Interface_Ethernet_StandaloneLinkTrainingPathAny) State() ygnmi.WildcardQuery[bool] {
	return ygnmi.NewWildcardQuery[bool](
		"Interface_Ethernet",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "standalone-link-training"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_Ethernet).StandaloneLinkTraining
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/standalone-link-training"
//	Path from root:       "/interfaces/interface/ethernet/config/standalone-link-training"
func (n *Interface_Ethernet_StandaloneLinkTrainingPath) Config() ygnmi.ConfigQuery[bool] {
	return ygnmi.NewConfigQuery[bool](
		"Interface_Ethernet",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "standalone-link-training"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_Ethernet).StandaloneLinkTraining
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "config/standalone-link-training"
//	Path from root:       "/interfaces/interface/ethernet/config/standalone-link-training"
func (n *Interface_Ethernet_StandaloneLinkTrainingPathAny) Config() ygnmi.WildcardQuery[bool] {
	return ygnmi.NewWildcardQuery[bool](
		"Interface_Ethernet",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "standalone-link-training"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_Ethernet).StandaloneLinkTraining
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_EthernetPath represents the /openconfig-interfaces/interfaces/interface/ethernet YANG schema element.
type Interface_EthernetPath struct {
	*ygnmi.NodePath
}

// Interface_EthernetPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet YANG schema element.
type Interface_EthernetPathAny struct {
	*ygnmi.NodePath
}

// AggregateId (leaf): Specify the logical aggregate interface to which
// this interface belongs
//
//	Defining module:      "openconfig-if-aggregate"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/aggregate-id"
//	Path from root:       "/interfaces/interface/ethernet/*/aggregate-id"
func (n *Interface_EthernetPath) AggregateId() *Interface_Ethernet_AggregateIdPath {
	ps := &Interface_Ethernet_AggregateIdPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "aggregate-id"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// AggregateId (leaf): Specify the logical aggregate interface to which
// this interface belongs
//
//	Defining module:      "openconfig-if-aggregate"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/aggregate-id"
//	Path from root:       "/interfaces/interface/ethernet/*/aggregate-id"
func (n *Interface_EthernetPathAny) AggregateId() *Interface_Ethernet_AggregateIdPathAny {
	ps := &Interface_Ethernet_AggregateIdPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "aggregate-id"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// AutoNegotiate (leaf): Set to TRUE to request the interface to auto-negotiate
// transmission parameters with its peer interface.  When
// set to FALSE, the transmission parameters are specified
// manually.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/auto-negotiate"
//	Path from root:       "/interfaces/interface/ethernet/*/auto-negotiate"
func (n *Interface_EthernetPath) AutoNegotiate() *Interface_Ethernet_AutoNegotiatePath {
	ps := &Interface_Ethernet_AutoNegotiatePath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "auto-negotiate"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// AutoNegotiate (leaf): Set to TRUE to request the interface to auto-negotiate
// transmission parameters with its peer interface.  When
// set to FALSE, the transmission parameters are specified
// manually.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/auto-negotiate"
//	Path from root:       "/interfaces/interface/ethernet/*/auto-negotiate"
func (n *Interface_EthernetPathAny) AutoNegotiate() *Interface_Ethernet_AutoNegotiatePathAny {
	ps := &Interface_Ethernet_AutoNegotiatePathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "auto-negotiate"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Counters (container): Ethernet interface counters
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/counters"
//	Path from root:       "/interfaces/interface/ethernet/state/counters"
func (n *Interface_EthernetPath) Counters() *Interface_Ethernet_CountersPath {
	ps := &Interface_Ethernet_CountersPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "counters"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Counters (container): Ethernet interface counters
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/counters"
//	Path from root:       "/interfaces/interface/ethernet/state/counters"
func (n *Interface_EthernetPathAny) Counters() *Interface_Ethernet_CountersPathAny {
	ps := &Interface_Ethernet_CountersPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "counters"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// DuplexMode (leaf): When auto-negotiate is TRUE, this optionally sets the
// duplex mode that will be advertised to the peer.  If
// unspecified, the interface should negotiate the duplex mode
// directly (typically full-duplex).  When auto-negotiate is
// FALSE, this sets the duplex mode on the interface directly.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/duplex-mode"
//	Path from root:       "/interfaces/interface/ethernet/*/duplex-mode"
func (n *Interface_EthernetPath) DuplexMode() *Interface_Ethernet_DuplexModePath {
	ps := &Interface_Ethernet_DuplexModePath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "duplex-mode"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// DuplexMode (leaf): When auto-negotiate is TRUE, this optionally sets the
// duplex mode that will be advertised to the peer.  If
// unspecified, the interface should negotiate the duplex mode
// directly (typically full-duplex).  When auto-negotiate is
// FALSE, this sets the duplex mode on the interface directly.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/duplex-mode"
//	Path from root:       "/interfaces/interface/ethernet/*/duplex-mode"
func (n *Interface_EthernetPathAny) DuplexMode() *Interface_Ethernet_DuplexModePathAny {
	ps := &Interface_Ethernet_DuplexModePathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "duplex-mode"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// EnableFlowControl (leaf): Enable or disable flow control for this interface.
// Ethernet flow control is a mechanism by which a receiver
// may send PAUSE frames to a sender to stop transmission for
// a specified time.
//
// This setting should override auto-negotiated flow control
// settings.  If left unspecified, and auto-negotiate is TRUE,
// flow control mode is negotiated with the peer interface.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/enable-flow-control"
//	Path from root:       "/interfaces/interface/ethernet/*/enable-flow-control"
func (n *Interface_EthernetPath) EnableFlowControl() *Interface_Ethernet_EnableFlowControlPath {
	ps := &Interface_Ethernet_EnableFlowControlPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "enable-flow-control"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// EnableFlowControl (leaf): Enable or disable flow control for this interface.
// Ethernet flow control is a mechanism by which a receiver
// may send PAUSE frames to a sender to stop transmission for
// a specified time.
//
// This setting should override auto-negotiated flow control
// settings.  If left unspecified, and auto-negotiate is TRUE,
// flow control mode is negotiated with the peer interface.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/enable-flow-control"
//	Path from root:       "/interfaces/interface/ethernet/*/enable-flow-control"
func (n *Interface_EthernetPathAny) EnableFlowControl() *Interface_Ethernet_EnableFlowControlPathAny {
	ps := &Interface_Ethernet_EnableFlowControlPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "enable-flow-control"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// FecMode (leaf): The FEC mode applied to the physical channels associated with
// the interface.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/fec-mode"
//	Path from root:       "/interfaces/interface/ethernet/*/fec-mode"
func (n *Interface_EthernetPath) FecMode() *Interface_Ethernet_FecModePath {
	ps := &Interface_Ethernet_FecModePath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "fec-mode"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// FecMode (leaf): The FEC mode applied to the physical channels associated with
// the interface.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/fec-mode"
//	Path from root:       "/interfaces/interface/ethernet/*/fec-mode"
func (n *Interface_EthernetPathAny) FecMode() *Interface_Ethernet_FecModePathAny {
	ps := &Interface_Ethernet_FecModePathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "fec-mode"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// HwMacAddress (leaf): Represents the 'burned-in', or system-assigned, MAC
// address for the Ethernet interface.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/hw-mac-address"
//	Path from root:       "/interfaces/interface/ethernet/state/hw-mac-address"
func (n *Interface_EthernetPath) HwMacAddress() *Interface_Ethernet_HwMacAddressPath {
	ps := &Interface_Ethernet_HwMacAddressPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "hw-mac-address"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// HwMacAddress (leaf): Represents the 'burned-in', or system-assigned, MAC
// address for the Ethernet interface.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/hw-mac-address"
//	Path from root:       "/interfaces/interface/ethernet/state/hw-mac-address"
func (n *Interface_EthernetPathAny) HwMacAddress() *Interface_Ethernet_HwMacAddressPathAny {
	ps := &Interface_Ethernet_HwMacAddressPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "hw-mac-address"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// MacAddress (leaf): Assigns a MAC address to the Ethernet interface.  If not
// specified, the corresponding operational state leaf is
// expected to show the system-assigned MAC address.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/mac-address"
//	Path from root:       "/interfaces/interface/ethernet/*/mac-address"
func (n *Interface_EthernetPath) MacAddress() *Interface_Ethernet_MacAddressPath {
	ps := &Interface_Ethernet_MacAddressPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "mac-address"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// MacAddress (leaf): Assigns a MAC address to the Ethernet interface.  If not
// specified, the corresponding operational state leaf is
// expected to show the system-assigned MAC address.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/mac-address"
//	Path from root:       "/interfaces/interface/ethernet/*/mac-address"
func (n *Interface_EthernetPathAny) MacAddress() *Interface_Ethernet_MacAddressPathAny {
	ps := &Interface_Ethernet_MacAddressPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "mac-address"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// NegotiatedDuplexMode (leaf): When auto-negotiate is set to TRUE, and the interface has
// completed auto-negotiation with the remote peer, this value
// shows the duplex mode that has been negotiated.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/negotiated-duplex-mode"
//	Path from root:       "/interfaces/interface/ethernet/state/negotiated-duplex-mode"
func (n *Interface_EthernetPath) NegotiatedDuplexMode() *Interface_Ethernet_NegotiatedDuplexModePath {
	ps := &Interface_Ethernet_NegotiatedDuplexModePath{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "negotiated-duplex-mode"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// NegotiatedDuplexMode (leaf): When auto-negotiate is set to TRUE, and the interface has
// completed auto-negotiation with the remote peer, this value
// shows the duplex mode that has been negotiated.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/negotiated-duplex-mode"
//	Path from root:       "/interfaces/interface/ethernet/state/negotiated-duplex-mode"
func (n *Interface_EthernetPathAny) NegotiatedDuplexMode() *Interface_Ethernet_NegotiatedDuplexModePathAny {
	ps := &Interface_Ethernet_NegotiatedDuplexModePathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "negotiated-duplex-mode"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// NegotiatedPortSpeed (leaf): When auto-negotiate is set to TRUE, and the interface has
// completed auto-negotiation with the remote peer, this value
// shows the interface speed that has been negotiated.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/negotiated-port-speed"
//	Path from root:       "/interfaces/interface/ethernet/state/negotiated-port-speed"
func (n *Interface_EthernetPath) NegotiatedPortSpeed() *Interface_Ethernet_NegotiatedPortSpeedPath {
	ps := &Interface_Ethernet_NegotiatedPortSpeedPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "negotiated-port-speed"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// NegotiatedPortSpeed (leaf): When auto-negotiate is set to TRUE, and the interface has
// completed auto-negotiation with the remote peer, this value
// shows the interface speed that has been negotiated.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/negotiated-port-speed"
//	Path from root:       "/interfaces/interface/ethernet/state/negotiated-port-speed"
func (n *Interface_EthernetPathAny) NegotiatedPortSpeed() *Interface_Ethernet_NegotiatedPortSpeedPathAny {
	ps := &Interface_Ethernet_NegotiatedPortSpeedPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "negotiated-port-speed"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// PortSpeed (leaf): When auto-negotiate is TRUE, this optionally sets the
// port-speed mode that will be advertised to the peer for
// negotiation.  If unspecified, it is expected that the
// interface will select the highest speed available based on
// negotiation.  When auto-negotiate is set to FALSE, sets the
// link speed to a fixed value -- supported values are defined
// by ETHERNET_SPEED identities
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/port-speed"
//	Path from root:       "/interfaces/interface/ethernet/*/port-speed"
func (n *Interface_EthernetPath) PortSpeed() *Interface_Ethernet_PortSpeedPath {
	ps := &Interface_Ethernet_PortSpeedPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "port-speed"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// PortSpeed (leaf): When auto-negotiate is TRUE, this optionally sets the
// port-speed mode that will be advertised to the peer for
// negotiation.  If unspecified, it is expected that the
// interface will select the highest speed available based on
// negotiation.  When auto-negotiate is set to FALSE, sets the
// link speed to a fixed value -- supported values are defined
// by ETHERNET_SPEED identities
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/port-speed"
//	Path from root:       "/interfaces/interface/ethernet/*/port-speed"
func (n *Interface_EthernetPathAny) PortSpeed() *Interface_Ethernet_PortSpeedPathAny {
	ps := &Interface_Ethernet_PortSpeedPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "port-speed"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// StandaloneLinkTraining (leaf): Link training is automatic tuning of the SerDes transmit and
// receive parameters to ensure an optimal connection over copper
// links. It is normally run as part of the auto negotiation
// sequence as specified in IEEE 802.3 Clause 73.
//
// Standalone link training is used when full auto negotiation is
// not desired on an Ethernet link but link training is needed.
// It is configured by setting the standalone-link-training leaf
// to TRUE and augo-negotiate leaf to FALSE.
//
// Note: If auto-negotiate is true, then the value of standalone
// link training leaf will be ignored.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/standalone-link-training"
//	Path from root:       "/interfaces/interface/ethernet/*/standalone-link-training"
func (n *Interface_EthernetPath) StandaloneLinkTraining() *Interface_Ethernet_StandaloneLinkTrainingPath {
	ps := &Interface_Ethernet_StandaloneLinkTrainingPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "standalone-link-training"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// StandaloneLinkTraining (leaf): Link training is automatic tuning of the SerDes transmit and
// receive parameters to ensure an optimal connection over copper
// links. It is normally run as part of the auto negotiation
// sequence as specified in IEEE 802.3 Clause 73.
//
// Standalone link training is used when full auto negotiation is
// not desired on an Ethernet link but link training is needed.
// It is configured by setting the standalone-link-training leaf
// to TRUE and augo-negotiate leaf to FALSE.
//
// Note: If auto-negotiate is true, then the value of standalone
// link training leaf will be ignored.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/standalone-link-training"
//	Path from root:       "/interfaces/interface/ethernet/*/standalone-link-training"
func (n *Interface_EthernetPathAny) StandaloneLinkTraining() *Interface_Ethernet_StandaloneLinkTrainingPathAny {
	ps := &Interface_Ethernet_StandaloneLinkTrainingPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "standalone-link-training"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// SwitchedVlan (container): Enclosing container for VLAN interface-specific
// data on Ethernet interfaces.  These are for standard
// L2, switched-style VLANs.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "switched-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan"
func (n *Interface_EthernetPath) SwitchedVlan() *Interface_Ethernet_SwitchedVlanPath {
	ps := &Interface_Ethernet_SwitchedVlanPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"switched-vlan"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// SwitchedVlan (container): Enclosing container for VLAN interface-specific
// data on Ethernet interfaces.  These are for standard
// L2, switched-style VLANs.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "switched-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan"
func (n *Interface_EthernetPathAny) SwitchedVlan() *Interface_Ethernet_SwitchedVlanPathAny {
	ps := &Interface_Ethernet_SwitchedVlanPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"switched-vlan"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_EthernetPath) State() ygnmi.SingletonQuery[*oc.Interface_Ethernet] {
	return ygnmi.NewSingletonQuery[*oc.Interface_Ethernet](
		"Interface_Ethernet",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_EthernetPathAny) State() ygnmi.WildcardQuery[*oc.Interface_Ethernet] {
	return ygnmi.NewWildcardQuery[*oc.Interface_Ethernet](
		"Interface_Ethernet",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_EthernetPath) Config() ygnmi.ConfigQuery[*oc.Interface_Ethernet] {
	return ygnmi.NewConfigQuery[*oc.Interface_Ethernet](
		"Interface_Ethernet",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_EthernetPathAny) Config() ygnmi.WildcardQuery[*oc.Interface_Ethernet] {
	return ygnmi.NewWildcardQuery[*oc.Interface_Ethernet](
		"Interface_Ethernet",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_In_8021QFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-8021q-frames YANG schema element.
type Interface_Ethernet_Counters_In_8021QFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_In_8021QFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-8021q-frames YANG schema element.
type Interface_Ethernet_Counters_In_8021QFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-8021q-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-8021q-frames"
func (n *Interface_Ethernet_Counters_In_8021QFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-8021q-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).In_8021QFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-8021q-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-8021q-frames"
func (n *Interface_Ethernet_Counters_In_8021QFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-8021q-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).In_8021QFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InBlockErrorsPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-block-errors YANG schema element.
type Interface_Ethernet_Counters_InBlockErrorsPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InBlockErrorsPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-block-errors YANG schema element.
type Interface_Ethernet_Counters_InBlockErrorsPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-block-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-block-errors"
func (n *Interface_Ethernet_Counters_InBlockErrorsPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-block-errors"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InBlockErrors
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-block-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-block-errors"
func (n *Interface_Ethernet_Counters_InBlockErrorsPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-block-errors"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InBlockErrors
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InCarrierErrorsPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-carrier-errors YANG schema element.
type Interface_Ethernet_Counters_InCarrierErrorsPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InCarrierErrorsPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-carrier-errors YANG schema element.
type Interface_Ethernet_Counters_InCarrierErrorsPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-carrier-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-carrier-errors"
func (n *Interface_Ethernet_Counters_InCarrierErrorsPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-carrier-errors"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InCarrierErrors
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-carrier-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-carrier-errors"
func (n *Interface_Ethernet_Counters_InCarrierErrorsPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-carrier-errors"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InCarrierErrors
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InCrcErrorsPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-crc-errors YANG schema element.
type Interface_Ethernet_Counters_InCrcErrorsPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InCrcErrorsPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-crc-errors YANG schema element.
type Interface_Ethernet_Counters_InCrcErrorsPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-crc-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-crc-errors"
func (n *Interface_Ethernet_Counters_InCrcErrorsPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-crc-errors"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InCrcErrors
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-crc-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-crc-errors"
func (n *Interface_Ethernet_Counters_InCrcErrorsPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-crc-errors"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InCrcErrors
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InFragmentFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-fragment-frames YANG schema element.
type Interface_Ethernet_Counters_InFragmentFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InFragmentFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-fragment-frames YANG schema element.
type Interface_Ethernet_Counters_InFragmentFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-fragment-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-fragment-frames"
func (n *Interface_Ethernet_Counters_InFragmentFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-fragment-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InFragmentFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-fragment-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-fragment-frames"
func (n *Interface_Ethernet_Counters_InFragmentFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-fragment-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InFragmentFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InInterruptedTxPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-interrupted-tx YANG schema element.
type Interface_Ethernet_Counters_InInterruptedTxPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InInterruptedTxPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-interrupted-tx YANG schema element.
type Interface_Ethernet_Counters_InInterruptedTxPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-interrupted-tx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-interrupted-tx"
func (n *Interface_Ethernet_Counters_InInterruptedTxPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-interrupted-tx"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InInterruptedTx
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-interrupted-tx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-interrupted-tx"
func (n *Interface_Ethernet_Counters_InInterruptedTxPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-interrupted-tx"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InInterruptedTx
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InJabberFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-jabber-frames YANG schema element.
type Interface_Ethernet_Counters_InJabberFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InJabberFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-jabber-frames YANG schema element.
type Interface_Ethernet_Counters_InJabberFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-jabber-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-jabber-frames"
func (n *Interface_Ethernet_Counters_InJabberFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-jabber-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InJabberFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-jabber-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-jabber-frames"
func (n *Interface_Ethernet_Counters_InJabberFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-jabber-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InJabberFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InLateCollisionPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-late-collision YANG schema element.
type Interface_Ethernet_Counters_InLateCollisionPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InLateCollisionPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-late-collision YANG schema element.
type Interface_Ethernet_Counters_InLateCollisionPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-late-collision"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-late-collision"
func (n *Interface_Ethernet_Counters_InLateCollisionPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-late-collision"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InLateCollision
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-late-collision"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-late-collision"
func (n *Interface_Ethernet_Counters_InLateCollisionPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-late-collision"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InLateCollision
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InMacControlFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-mac-control-frames YANG schema element.
type Interface_Ethernet_Counters_InMacControlFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InMacControlFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-mac-control-frames YANG schema element.
type Interface_Ethernet_Counters_InMacControlFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-mac-control-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-control-frames"
func (n *Interface_Ethernet_Counters_InMacControlFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-mac-control-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InMacControlFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-mac-control-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-control-frames"
func (n *Interface_Ethernet_Counters_InMacControlFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-mac-control-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InMacControlFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InMacErrorsRxPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-mac-errors-rx YANG schema element.
type Interface_Ethernet_Counters_InMacErrorsRxPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InMacErrorsRxPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-mac-errors-rx YANG schema element.
type Interface_Ethernet_Counters_InMacErrorsRxPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-mac-errors-rx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-errors-rx"
func (n *Interface_Ethernet_Counters_InMacErrorsRxPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-mac-errors-rx"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InMacErrorsRx
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-mac-errors-rx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-errors-rx"
func (n *Interface_Ethernet_Counters_InMacErrorsRxPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-mac-errors-rx"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InMacErrorsRx
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InMacPauseFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-mac-pause-frames YANG schema element.
type Interface_Ethernet_Counters_InMacPauseFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InMacPauseFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-mac-pause-frames YANG schema element.
type Interface_Ethernet_Counters_InMacPauseFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-mac-pause-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-pause-frames"
func (n *Interface_Ethernet_Counters_InMacPauseFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-mac-pause-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InMacPauseFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-mac-pause-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-pause-frames"
func (n *Interface_Ethernet_Counters_InMacPauseFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-mac-pause-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InMacPauseFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InMaxsizeExceededPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-maxsize-exceeded YANG schema element.
type Interface_Ethernet_Counters_InMaxsizeExceededPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InMaxsizeExceededPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-maxsize-exceeded YANG schema element.
type Interface_Ethernet_Counters_InMaxsizeExceededPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-maxsize-exceeded"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-maxsize-exceeded"
func (n *Interface_Ethernet_Counters_InMaxsizeExceededPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-maxsize-exceeded"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InMaxsizeExceeded
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-maxsize-exceeded"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-maxsize-exceeded"
func (n *Interface_Ethernet_Counters_InMaxsizeExceededPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-maxsize-exceeded"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InMaxsizeExceeded
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InOversizeFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-oversize-frames YANG schema element.
type Interface_Ethernet_Counters_InOversizeFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InOversizeFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-oversize-frames YANG schema element.
type Interface_Ethernet_Counters_InOversizeFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-oversize-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-oversize-frames"
func (n *Interface_Ethernet_Counters_InOversizeFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-oversize-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InOversizeFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-oversize-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-oversize-frames"
func (n *Interface_Ethernet_Counters_InOversizeFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-oversize-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InOversizeFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InSingleCollisionPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-single-collision YANG schema element.
type Interface_Ethernet_Counters_InSingleCollisionPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InSingleCollisionPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-single-collision YANG schema element.
type Interface_Ethernet_Counters_InSingleCollisionPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-single-collision"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-single-collision"
func (n *Interface_Ethernet_Counters_InSingleCollisionPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-single-collision"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InSingleCollision
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-single-collision"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-single-collision"
func (n *Interface_Ethernet_Counters_InSingleCollisionPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-single-collision"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InSingleCollision
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InSymbolErrorPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-symbol-error YANG schema element.
type Interface_Ethernet_Counters_InSymbolErrorPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InSymbolErrorPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-symbol-error YANG schema element.
type Interface_Ethernet_Counters_InSymbolErrorPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-symbol-error"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-symbol-error"
func (n *Interface_Ethernet_Counters_InSymbolErrorPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-symbol-error"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InSymbolError
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-symbol-error"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-symbol-error"
func (n *Interface_Ethernet_Counters_InSymbolErrorPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-symbol-error"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InSymbolError
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_InUndersizeFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-undersize-frames YANG schema element.
type Interface_Ethernet_Counters_InUndersizeFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_InUndersizeFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/in-undersize-frames YANG schema element.
type Interface_Ethernet_Counters_InUndersizeFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-undersize-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-undersize-frames"
func (n *Interface_Ethernet_Counters_InUndersizeFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-undersize-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InUndersizeFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "in-undersize-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-undersize-frames"
func (n *Interface_Ethernet_Counters_InUndersizeFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"in-undersize-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).InUndersizeFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_Out_8021QFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/out-8021q-frames YANG schema element.
type Interface_Ethernet_Counters_Out_8021QFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_Out_8021QFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/out-8021q-frames YANG schema element.
type Interface_Ethernet_Counters_Out_8021QFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "out-8021q-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-8021q-frames"
func (n *Interface_Ethernet_Counters_Out_8021QFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"out-8021q-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).Out_8021QFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "out-8021q-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-8021q-frames"
func (n *Interface_Ethernet_Counters_Out_8021QFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"out-8021q-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).Out_8021QFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_OutMacControlFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/out-mac-control-frames YANG schema element.
type Interface_Ethernet_Counters_OutMacControlFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_OutMacControlFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/out-mac-control-frames YANG schema element.
type Interface_Ethernet_Counters_OutMacControlFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "out-mac-control-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-control-frames"
func (n *Interface_Ethernet_Counters_OutMacControlFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"out-mac-control-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).OutMacControlFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "out-mac-control-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-control-frames"
func (n *Interface_Ethernet_Counters_OutMacControlFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"out-mac-control-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).OutMacControlFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_OutMacErrorsTxPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/out-mac-errors-tx YANG schema element.
type Interface_Ethernet_Counters_OutMacErrorsTxPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_OutMacErrorsTxPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/out-mac-errors-tx YANG schema element.
type Interface_Ethernet_Counters_OutMacErrorsTxPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "out-mac-errors-tx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-errors-tx"
func (n *Interface_Ethernet_Counters_OutMacErrorsTxPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"out-mac-errors-tx"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).OutMacErrorsTx
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "out-mac-errors-tx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-errors-tx"
func (n *Interface_Ethernet_Counters_OutMacErrorsTxPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"out-mac-errors-tx"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).OutMacErrorsTx
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_Counters_OutMacPauseFramesPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/out-mac-pause-frames YANG schema element.
type Interface_Ethernet_Counters_OutMacPauseFramesPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_Counters_OutMacPauseFramesPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters/out-mac-pause-frames YANG schema element.
type Interface_Ethernet_Counters_OutMacPauseFramesPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "out-mac-pause-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-pause-frames"
func (n *Interface_Ethernet_Counters_OutMacPauseFramesPath) State() ygnmi.SingletonQuery[uint64] {
	return ygnmi.NewSingletonQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"out-mac-pause-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).OutMacPauseFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-if-ethernet"
//	Path from parent:     "out-mac-pause-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-pause-frames"
func (n *Interface_Ethernet_Counters_OutMacPauseFramesPathAny) State() ygnmi.WildcardQuery[uint64] {
	return ygnmi.NewWildcardQuery[uint64](
		"Interface_Ethernet_Counters",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"out-mac-pause-frames"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint64, bool) {
			ret := gs.(*oc.Interface_Ethernet_Counters).OutMacPauseFrames
			if ret == nil {
				var zero uint64
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_Counters) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_CountersPath represents the /openconfig-interfaces/interfaces/interface/ethernet/state/counters YANG schema element.
type Interface_Ethernet_CountersPath struct {
	*ygnmi.NodePath
}

// Interface_Ethernet_CountersPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/state/counters YANG schema element.
type Interface_Ethernet_CountersPathAny struct {
	*ygnmi.NodePath
}

// In_8021QFrames (leaf): Number of 802.1q tagged frames received on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-8021q-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-8021q-frames"
func (n *Interface_Ethernet_CountersPath) In_8021QFrames() *Interface_Ethernet_Counters_In_8021QFramesPath {
	ps := &Interface_Ethernet_Counters_In_8021QFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-8021q-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// In_8021QFrames (leaf): Number of 802.1q tagged frames received on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-8021q-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-8021q-frames"
func (n *Interface_Ethernet_CountersPathAny) In_8021QFrames() *Interface_Ethernet_Counters_In_8021QFramesPathAny {
	ps := &Interface_Ethernet_Counters_In_8021QFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-8021q-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InBlockErrors (leaf): The number of received errored blocks. Error detection codes
// are capable of detecting whether one or more errors have
// occurred in a given sequence of bits  the block. It is
// normally not possible to determine the exact number of errored
// bits within the block
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-block-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-block-errors"
func (n *Interface_Ethernet_CountersPath) InBlockErrors() *Interface_Ethernet_Counters_InBlockErrorsPath {
	ps := &Interface_Ethernet_Counters_InBlockErrorsPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-block-errors"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InBlockErrors (leaf): The number of received errored blocks. Error detection codes
// are capable of detecting whether one or more errors have
// occurred in a given sequence of bits  the block. It is
// normally not possible to determine the exact number of errored
// bits within the block
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-block-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-block-errors"
func (n *Interface_Ethernet_CountersPathAny) InBlockErrors() *Interface_Ethernet_Counters_InBlockErrorsPathAny {
	ps := &Interface_Ethernet_Counters_InBlockErrorsPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-block-errors"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InCarrierErrors (leaf): The number of received errored frames due to a carrier issue.
// The value refers to MIB counter for
// dot3StatsCarrierSenseErrors
// oid=1.3.6.1.2.1.10.7.2.1.11
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-carrier-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-carrier-errors"
func (n *Interface_Ethernet_CountersPath) InCarrierErrors() *Interface_Ethernet_Counters_InCarrierErrorsPath {
	ps := &Interface_Ethernet_Counters_InCarrierErrorsPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-carrier-errors"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InCarrierErrors (leaf): The number of received errored frames due to a carrier issue.
// The value refers to MIB counter for
// dot3StatsCarrierSenseErrors
// oid=1.3.6.1.2.1.10.7.2.1.11
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-carrier-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-carrier-errors"
func (n *Interface_Ethernet_CountersPathAny) InCarrierErrors() *Interface_Ethernet_Counters_InCarrierErrorsPathAny {
	ps := &Interface_Ethernet_Counters_InCarrierErrorsPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-carrier-errors"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InCrcErrors (leaf): The total number of frames received that
// had a length (excluding framing bits, but
// including FCS octets) of between 64 and 1518
// octets, inclusive, but had either a bad
// Frame Check Sequence (FCS) with an integral
// number of octets (FCS Error) or a bad FCS with
// a non-integral number of octets (Alignment Error)
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-crc-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-crc-errors"
func (n *Interface_Ethernet_CountersPath) InCrcErrors() *Interface_Ethernet_Counters_InCrcErrorsPath {
	ps := &Interface_Ethernet_Counters_InCrcErrorsPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-crc-errors"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InCrcErrors (leaf): The total number of frames received that
// had a length (excluding framing bits, but
// including FCS octets) of between 64 and 1518
// octets, inclusive, but had either a bad
// Frame Check Sequence (FCS) with an integral
// number of octets (FCS Error) or a bad FCS with
// a non-integral number of octets (Alignment Error)
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-crc-errors"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-crc-errors"
func (n *Interface_Ethernet_CountersPathAny) InCrcErrors() *Interface_Ethernet_Counters_InCrcErrorsPathAny {
	ps := &Interface_Ethernet_Counters_InCrcErrorsPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-crc-errors"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InFragmentFrames (leaf): The total number of frames received that were less than
// 64 octets in length (excluding framing bits but including
// FCS octets) and had either a bad Frame Check Sequence
// (FCS) with an integral number of octets (FCS Error) or a
// bad FCS with a non-integral number of octets (Alignment
// Error).
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-fragment-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-fragment-frames"
func (n *Interface_Ethernet_CountersPath) InFragmentFrames() *Interface_Ethernet_Counters_InFragmentFramesPath {
	ps := &Interface_Ethernet_Counters_InFragmentFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-fragment-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InFragmentFrames (leaf): The total number of frames received that were less than
// 64 octets in length (excluding framing bits but including
// FCS octets) and had either a bad Frame Check Sequence
// (FCS) with an integral number of octets (FCS Error) or a
// bad FCS with a non-integral number of octets (Alignment
// Error).
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-fragment-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-fragment-frames"
func (n *Interface_Ethernet_CountersPathAny) InFragmentFrames() *Interface_Ethernet_Counters_InFragmentFramesPathAny {
	ps := &Interface_Ethernet_Counters_InFragmentFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-fragment-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InInterruptedTx (leaf): The number of received errored frames due to interrupted
// transmission issue. The value refers to MIB counter for
// dot3StatsDeferredTransmissions
// oid=1.3.6.1.2.1.10.7.2.1.7
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-interrupted-tx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-interrupted-tx"
func (n *Interface_Ethernet_CountersPath) InInterruptedTx() *Interface_Ethernet_Counters_InInterruptedTxPath {
	ps := &Interface_Ethernet_Counters_InInterruptedTxPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-interrupted-tx"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InInterruptedTx (leaf): The number of received errored frames due to interrupted
// transmission issue. The value refers to MIB counter for
// dot3StatsDeferredTransmissions
// oid=1.3.6.1.2.1.10.7.2.1.7
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-interrupted-tx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-interrupted-tx"
func (n *Interface_Ethernet_CountersPathAny) InInterruptedTx() *Interface_Ethernet_Counters_InInterruptedTxPathAny {
	ps := &Interface_Ethernet_Counters_InInterruptedTxPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-interrupted-tx"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InJabberFrames (leaf): Number of jabber frames received on the
// interface.  Jabber frames are typically defined as oversize
// frames which also have a bad CRC.  Implementations may use
// slightly different definitions of what constitutes a jabber
// frame.  Often indicative of a NIC hardware problem.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-jabber-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-jabber-frames"
func (n *Interface_Ethernet_CountersPath) InJabberFrames() *Interface_Ethernet_Counters_InJabberFramesPath {
	ps := &Interface_Ethernet_Counters_InJabberFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-jabber-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InJabberFrames (leaf): Number of jabber frames received on the
// interface.  Jabber frames are typically defined as oversize
// frames which also have a bad CRC.  Implementations may use
// slightly different definitions of what constitutes a jabber
// frame.  Often indicative of a NIC hardware problem.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-jabber-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-jabber-frames"
func (n *Interface_Ethernet_CountersPathAny) InJabberFrames() *Interface_Ethernet_Counters_InJabberFramesPathAny {
	ps := &Interface_Ethernet_Counters_InJabberFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-jabber-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InLateCollision (leaf): The number of received errored frames due to late collision
// issue. The value refers to MIB counter for
// dot3StatsLateCollisions
// oid=1.3.6.1.2.1.10.7.2.1.8
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-late-collision"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-late-collision"
func (n *Interface_Ethernet_CountersPath) InLateCollision() *Interface_Ethernet_Counters_InLateCollisionPath {
	ps := &Interface_Ethernet_Counters_InLateCollisionPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-late-collision"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InLateCollision (leaf): The number of received errored frames due to late collision
// issue. The value refers to MIB counter for
// dot3StatsLateCollisions
// oid=1.3.6.1.2.1.10.7.2.1.8
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-late-collision"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-late-collision"
func (n *Interface_Ethernet_CountersPathAny) InLateCollision() *Interface_Ethernet_Counters_InLateCollisionPathAny {
	ps := &Interface_Ethernet_Counters_InLateCollisionPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-late-collision"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InMacControlFrames (leaf): MAC layer control frames received on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-mac-control-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-control-frames"
func (n *Interface_Ethernet_CountersPath) InMacControlFrames() *Interface_Ethernet_Counters_InMacControlFramesPath {
	ps := &Interface_Ethernet_Counters_InMacControlFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-mac-control-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InMacControlFrames (leaf): MAC layer control frames received on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-mac-control-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-control-frames"
func (n *Interface_Ethernet_CountersPathAny) InMacControlFrames() *Interface_Ethernet_Counters_InMacControlFramesPathAny {
	ps := &Interface_Ethernet_Counters_InMacControlFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-mac-control-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InMacErrorsRx (leaf): The number of received errored frames due to MAC errors
// received. The value refers to MIB counter for
// dot3StatsInternalMacReceiveErrors
// oid=1.3.6.1.2.1.10.7.2.1.16
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-mac-errors-rx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-errors-rx"
func (n *Interface_Ethernet_CountersPath) InMacErrorsRx() *Interface_Ethernet_Counters_InMacErrorsRxPath {
	ps := &Interface_Ethernet_Counters_InMacErrorsRxPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-mac-errors-rx"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InMacErrorsRx (leaf): The number of received errored frames due to MAC errors
// received. The value refers to MIB counter for
// dot3StatsInternalMacReceiveErrors
// oid=1.3.6.1.2.1.10.7.2.1.16
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-mac-errors-rx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-errors-rx"
func (n *Interface_Ethernet_CountersPathAny) InMacErrorsRx() *Interface_Ethernet_Counters_InMacErrorsRxPathAny {
	ps := &Interface_Ethernet_Counters_InMacErrorsRxPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-mac-errors-rx"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InMacPauseFrames (leaf): MAC layer PAUSE frames received on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-mac-pause-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-pause-frames"
func (n *Interface_Ethernet_CountersPath) InMacPauseFrames() *Interface_Ethernet_Counters_InMacPauseFramesPath {
	ps := &Interface_Ethernet_Counters_InMacPauseFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-mac-pause-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InMacPauseFrames (leaf): MAC layer PAUSE frames received on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-mac-pause-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-mac-pause-frames"
func (n *Interface_Ethernet_CountersPathAny) InMacPauseFrames() *Interface_Ethernet_Counters_InMacPauseFramesPathAny {
	ps := &Interface_Ethernet_Counters_InMacPauseFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-mac-pause-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InMaxsizeExceeded (leaf): The total number frames received that are well-formed but
// dropped due to exceeding the maximum frame size on the interface
// (e.g., MTU or MRU)
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-maxsize-exceeded"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-maxsize-exceeded"
func (n *Interface_Ethernet_CountersPath) InMaxsizeExceeded() *Interface_Ethernet_Counters_InMaxsizeExceededPath {
	ps := &Interface_Ethernet_Counters_InMaxsizeExceededPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-maxsize-exceeded"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InMaxsizeExceeded (leaf): The total number frames received that are well-formed but
// dropped due to exceeding the maximum frame size on the interface
// (e.g., MTU or MRU)
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-maxsize-exceeded"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-maxsize-exceeded"
func (n *Interface_Ethernet_CountersPathAny) InMaxsizeExceeded() *Interface_Ethernet_Counters_InMaxsizeExceededPathAny {
	ps := &Interface_Ethernet_Counters_InMaxsizeExceededPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-maxsize-exceeded"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InOversizeFrames (leaf): The total number of frames received that were
// longer than 1518 octets (excluding framing bits,
// but including FCS octets) and were otherwise
// well formed.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-oversize-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-oversize-frames"
func (n *Interface_Ethernet_CountersPath) InOversizeFrames() *Interface_Ethernet_Counters_InOversizeFramesPath {
	ps := &Interface_Ethernet_Counters_InOversizeFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-oversize-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InOversizeFrames (leaf): The total number of frames received that were
// longer than 1518 octets (excluding framing bits,
// but including FCS octets) and were otherwise
// well formed.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-oversize-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-oversize-frames"
func (n *Interface_Ethernet_CountersPathAny) InOversizeFrames() *Interface_Ethernet_Counters_InOversizeFramesPathAny {
	ps := &Interface_Ethernet_Counters_InOversizeFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-oversize-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InSingleCollision (leaf): The number of received errored frames due to single collision
// issue. The value refers to MIB counter for
// dot3StatsSingleCollisionFrames
// oid=1.3.6.1.2.1.10.7.2.1.4
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-single-collision"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-single-collision"
func (n *Interface_Ethernet_CountersPath) InSingleCollision() *Interface_Ethernet_Counters_InSingleCollisionPath {
	ps := &Interface_Ethernet_Counters_InSingleCollisionPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-single-collision"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InSingleCollision (leaf): The number of received errored frames due to single collision
// issue. The value refers to MIB counter for
// dot3StatsSingleCollisionFrames
// oid=1.3.6.1.2.1.10.7.2.1.4
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-single-collision"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-single-collision"
func (n *Interface_Ethernet_CountersPathAny) InSingleCollision() *Interface_Ethernet_Counters_InSingleCollisionPathAny {
	ps := &Interface_Ethernet_Counters_InSingleCollisionPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-single-collision"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InSymbolError (leaf): The number of received errored frames due to symbol error.
// The value refers to MIB counter for
// in-symbol-error
// oid=1.3.6.1.2.1.10.7.2.1.18
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-symbol-error"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-symbol-error"
func (n *Interface_Ethernet_CountersPath) InSymbolError() *Interface_Ethernet_Counters_InSymbolErrorPath {
	ps := &Interface_Ethernet_Counters_InSymbolErrorPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-symbol-error"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InSymbolError (leaf): The number of received errored frames due to symbol error.
// The value refers to MIB counter for
// in-symbol-error
// oid=1.3.6.1.2.1.10.7.2.1.18
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-symbol-error"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-symbol-error"
func (n *Interface_Ethernet_CountersPathAny) InSymbolError() *Interface_Ethernet_Counters_InSymbolErrorPathAny {
	ps := &Interface_Ethernet_Counters_InSymbolErrorPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-symbol-error"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InUndersizeFrames (leaf): The total number of frames received that were
// less than 64 octets long (excluding framing bits,
// but including FCS octets) and were otherwise well
// formed.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-undersize-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-undersize-frames"
func (n *Interface_Ethernet_CountersPath) InUndersizeFrames() *Interface_Ethernet_Counters_InUndersizeFramesPath {
	ps := &Interface_Ethernet_Counters_InUndersizeFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-undersize-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InUndersizeFrames (leaf): The total number of frames received that were
// less than 64 octets long (excluding framing bits,
// but including FCS octets) and were otherwise well
// formed.
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "in-undersize-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/in-undersize-frames"
func (n *Interface_Ethernet_CountersPathAny) InUndersizeFrames() *Interface_Ethernet_Counters_InUndersizeFramesPathAny {
	ps := &Interface_Ethernet_Counters_InUndersizeFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"in-undersize-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Out_8021QFrames (leaf): Number of 802.1q tagged frames sent on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "out-8021q-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-8021q-frames"
func (n *Interface_Ethernet_CountersPath) Out_8021QFrames() *Interface_Ethernet_Counters_Out_8021QFramesPath {
	ps := &Interface_Ethernet_Counters_Out_8021QFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"out-8021q-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Out_8021QFrames (leaf): Number of 802.1q tagged frames sent on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "out-8021q-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-8021q-frames"
func (n *Interface_Ethernet_CountersPathAny) Out_8021QFrames() *Interface_Ethernet_Counters_Out_8021QFramesPathAny {
	ps := &Interface_Ethernet_Counters_Out_8021QFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"out-8021q-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// OutMacControlFrames (leaf): MAC layer control frames sent on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "out-mac-control-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-control-frames"
func (n *Interface_Ethernet_CountersPath) OutMacControlFrames() *Interface_Ethernet_Counters_OutMacControlFramesPath {
	ps := &Interface_Ethernet_Counters_OutMacControlFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"out-mac-control-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// OutMacControlFrames (leaf): MAC layer control frames sent on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "out-mac-control-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-control-frames"
func (n *Interface_Ethernet_CountersPathAny) OutMacControlFrames() *Interface_Ethernet_Counters_OutMacControlFramesPathAny {
	ps := &Interface_Ethernet_Counters_OutMacControlFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"out-mac-control-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// OutMacErrorsTx (leaf): The number of sent errored frames due to MAC errors
// transmitted. The value refers to MIB counter for
// dot3StatsInternalMacTransmitErrors
// oid=1.3.6.1.2.1.10.7.2.1.10
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "out-mac-errors-tx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-errors-tx"
func (n *Interface_Ethernet_CountersPath) OutMacErrorsTx() *Interface_Ethernet_Counters_OutMacErrorsTxPath {
	ps := &Interface_Ethernet_Counters_OutMacErrorsTxPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"out-mac-errors-tx"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// OutMacErrorsTx (leaf): The number of sent errored frames due to MAC errors
// transmitted. The value refers to MIB counter for
// dot3StatsInternalMacTransmitErrors
// oid=1.3.6.1.2.1.10.7.2.1.10
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "out-mac-errors-tx"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-errors-tx"
func (n *Interface_Ethernet_CountersPathAny) OutMacErrorsTx() *Interface_Ethernet_Counters_OutMacErrorsTxPathAny {
	ps := &Interface_Ethernet_Counters_OutMacErrorsTxPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"out-mac-errors-tx"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// OutMacPauseFrames (leaf): MAC layer PAUSE frames sent on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "out-mac-pause-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-pause-frames"
func (n *Interface_Ethernet_CountersPath) OutMacPauseFrames() *Interface_Ethernet_Counters_OutMacPauseFramesPath {
	ps := &Interface_Ethernet_Counters_OutMacPauseFramesPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"out-mac-pause-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// OutMacPauseFrames (leaf): MAC layer PAUSE frames sent on the interface
//
//	Defining module:      "openconfig-if-ethernet"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "out-mac-pause-frames"
//	Path from root:       "/interfaces/interface/ethernet/state/counters/out-mac-pause-frames"
func (n *Interface_Ethernet_CountersPathAny) OutMacPauseFrames() *Interface_Ethernet_Counters_OutMacPauseFramesPathAny {
	ps := &Interface_Ethernet_Counters_OutMacPauseFramesPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"out-mac-pause-frames"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_Ethernet_CountersPath) State() ygnmi.SingletonQuery[*oc.Interface_Ethernet_Counters] {
	return ygnmi.NewSingletonQuery[*oc.Interface_Ethernet_Counters](
		"Interface_Ethernet_Counters",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_Ethernet_CountersPathAny) State() ygnmi.WildcardQuery[*oc.Interface_Ethernet_Counters] {
	return ygnmi.NewWildcardQuery[*oc.Interface_Ethernet_Counters](
		"Interface_Ethernet_Counters",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_SwitchedVlan_AccessVlanPath represents the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/access-vlan YANG schema element.
type Interface_Ethernet_SwitchedVlan_AccessVlanPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_SwitchedVlan_AccessVlanPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/access-vlan YANG schema element.
type Interface_Ethernet_SwitchedVlan_AccessVlanPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/access-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/state/access-vlan"
func (n *Interface_Ethernet_SwitchedVlan_AccessVlanPath) State() ygnmi.SingletonQuery[uint16] {
	return ygnmi.NewSingletonQuery[uint16](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "access-vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).AccessVlan
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/access-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/state/access-vlan"
func (n *Interface_Ethernet_SwitchedVlan_AccessVlanPathAny) State() ygnmi.WildcardQuery[uint16] {
	return ygnmi.NewWildcardQuery[uint16](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "access-vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).AccessVlan
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/access-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/config/access-vlan"
func (n *Interface_Ethernet_SwitchedVlan_AccessVlanPath) Config() ygnmi.ConfigQuery[uint16] {
	return ygnmi.NewConfigQuery[uint16](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "access-vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).AccessVlan
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/access-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/config/access-vlan"
func (n *Interface_Ethernet_SwitchedVlan_AccessVlanPathAny) Config() ygnmi.WildcardQuery[uint16] {
	return ygnmi.NewWildcardQuery[uint16](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "access-vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).AccessVlan
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_SwitchedVlan_InterfaceModePath represents the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/interface-mode YANG schema element.
type Interface_Ethernet_SwitchedVlan_InterfaceModePath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_SwitchedVlan_InterfaceModePathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/interface-mode YANG schema element.
type Interface_Ethernet_SwitchedVlan_InterfaceModePathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/interface-mode"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/state/interface-mode"
func (n *Interface_Ethernet_SwitchedVlan_InterfaceModePath) State() ygnmi.SingletonQuery[oc.E_VlanTypes_VlanModeType] {
	return ygnmi.NewSingletonQuery[oc.E_VlanTypes_VlanModeType](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "interface-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_VlanTypes_VlanModeType, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).InterfaceMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/interface-mode"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/state/interface-mode"
func (n *Interface_Ethernet_SwitchedVlan_InterfaceModePathAny) State() ygnmi.WildcardQuery[oc.E_VlanTypes_VlanModeType] {
	return ygnmi.NewWildcardQuery[oc.E_VlanTypes_VlanModeType](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "interface-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_VlanTypes_VlanModeType, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).InterfaceMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/interface-mode"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/config/interface-mode"
func (n *Interface_Ethernet_SwitchedVlan_InterfaceModePath) Config() ygnmi.ConfigQuery[oc.E_VlanTypes_VlanModeType] {
	return ygnmi.NewConfigQuery[oc.E_VlanTypes_VlanModeType](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "interface-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_VlanTypes_VlanModeType, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).InterfaceMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/interface-mode"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/config/interface-mode"
func (n *Interface_Ethernet_SwitchedVlan_InterfaceModePathAny) Config() ygnmi.WildcardQuery[oc.E_VlanTypes_VlanModeType] {
	return ygnmi.NewWildcardQuery[oc.E_VlanTypes_VlanModeType](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "interface-mode"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.E_VlanTypes_VlanModeType, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).InterfaceMode
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_SwitchedVlan_NativeVlanPath represents the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/native-vlan YANG schema element.
type Interface_Ethernet_SwitchedVlan_NativeVlanPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_SwitchedVlan_NativeVlanPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/native-vlan YANG schema element.
type Interface_Ethernet_SwitchedVlan_NativeVlanPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/native-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/state/native-vlan"
func (n *Interface_Ethernet_SwitchedVlan_NativeVlanPath) State() ygnmi.SingletonQuery[uint16] {
	return ygnmi.NewSingletonQuery[uint16](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "native-vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).NativeVlan
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/native-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/state/native-vlan"
func (n *Interface_Ethernet_SwitchedVlan_NativeVlanPathAny) State() ygnmi.WildcardQuery[uint16] {
	return ygnmi.NewWildcardQuery[uint16](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "native-vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).NativeVlan
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/native-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/config/native-vlan"
func (n *Interface_Ethernet_SwitchedVlan_NativeVlanPath) Config() ygnmi.ConfigQuery[uint16] {
	return ygnmi.NewConfigQuery[uint16](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "native-vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).NativeVlan
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/native-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/config/native-vlan"
func (n *Interface_Ethernet_SwitchedVlan_NativeVlanPathAny) Config() ygnmi.WildcardQuery[uint16] {
	return ygnmi.NewWildcardQuery[uint16](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "native-vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).NativeVlan
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_SwitchedVlan_TrunkVlansPath represents the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/trunk-vlans YANG schema element.
type Interface_Ethernet_SwitchedVlan_TrunkVlansPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_Ethernet_SwitchedVlan_TrunkVlansPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/trunk-vlans YANG schema element.
type Interface_Ethernet_SwitchedVlan_TrunkVlansPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/trunk-vlans"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/state/trunk-vlans"
func (n *Interface_Ethernet_SwitchedVlan_TrunkVlansPath) State() ygnmi.SingletonQuery[[]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union] {
	return ygnmi.NewSingletonQuery[[]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "trunk-vlans"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) ([]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).TrunkVlans
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/trunk-vlans"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/state/trunk-vlans"
func (n *Interface_Ethernet_SwitchedVlan_TrunkVlansPathAny) State() ygnmi.WildcardQuery[[]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union] {
	return ygnmi.NewWildcardQuery[[]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "trunk-vlans"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) ([]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).TrunkVlans
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/trunk-vlans"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/config/trunk-vlans"
func (n *Interface_Ethernet_SwitchedVlan_TrunkVlansPath) Config() ygnmi.ConfigQuery[[]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union] {
	return ygnmi.NewConfigQuery[[]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "trunk-vlans"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) ([]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).TrunkVlans
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/trunk-vlans"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/config/trunk-vlans"
func (n *Interface_Ethernet_SwitchedVlan_TrunkVlansPathAny) Config() ygnmi.WildcardQuery[[]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union] {
	return ygnmi.NewWildcardQuery[[]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "trunk-vlans"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) ([]oc.Interface_Ethernet_SwitchedVlan_TrunkVlans_Union, bool) {
			ret := gs.(*oc.Interface_Ethernet_SwitchedVlan).TrunkVlans
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_Ethernet_SwitchedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_Ethernet_SwitchedVlanPath represents the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan YANG schema element.
type Interface_Ethernet_SwitchedVlanPath struct {
	*ygnmi.NodePath
}

// Interface_Ethernet_SwitchedVlanPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan YANG schema element.
type Interface_Ethernet_SwitchedVlanPathAny struct {
	*ygnmi.NodePath
}

// AccessVlan (leaf): Assign the access vlan to the access port.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/access-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/*/access-vlan"
func (n *Interface_Ethernet_SwitchedVlanPath) AccessVlan() *Interface_Ethernet_SwitchedVlan_AccessVlanPath {
	ps := &Interface_Ethernet_SwitchedVlan_AccessVlanPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "access-vlan"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// AccessVlan (leaf): Assign the access vlan to the access port.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/access-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/*/access-vlan"
func (n *Interface_Ethernet_SwitchedVlanPathAny) AccessVlan() *Interface_Ethernet_SwitchedVlan_AccessVlanPathAny {
	ps := &Interface_Ethernet_SwitchedVlan_AccessVlanPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "access-vlan"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InterfaceMode (leaf): Set the interface to access or trunk mode for
// VLANs
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/interface-mode"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/*/interface-mode"
func (n *Interface_Ethernet_SwitchedVlanPath) InterfaceMode() *Interface_Ethernet_SwitchedVlan_InterfaceModePath {
	ps := &Interface_Ethernet_SwitchedVlan_InterfaceModePath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "interface-mode"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// InterfaceMode (leaf): Set the interface to access or trunk mode for
// VLANs
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/interface-mode"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/*/interface-mode"
func (n *Interface_Ethernet_SwitchedVlanPathAny) InterfaceMode() *Interface_Ethernet_SwitchedVlan_InterfaceModePathAny {
	ps := &Interface_Ethernet_SwitchedVlan_InterfaceModePathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "interface-mode"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// NativeVlan (leaf): Set the native VLAN id for untagged frames arriving on
// a trunk interface.  Tagged frames sent on an interface
// configured with a native VLAN should have their tags
// stripped prior to transmission. This configuration is only
// valid on a trunk interface.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/native-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/*/native-vlan"
func (n *Interface_Ethernet_SwitchedVlanPath) NativeVlan() *Interface_Ethernet_SwitchedVlan_NativeVlanPath {
	ps := &Interface_Ethernet_SwitchedVlan_NativeVlanPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "native-vlan"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// NativeVlan (leaf): Set the native VLAN id for untagged frames arriving on
// a trunk interface.  Tagged frames sent on an interface
// configured with a native VLAN should have their tags
// stripped prior to transmission. This configuration is only
// valid on a trunk interface.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/native-vlan"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/*/native-vlan"
func (n *Interface_Ethernet_SwitchedVlanPathAny) NativeVlan() *Interface_Ethernet_SwitchedVlan_NativeVlanPathAny {
	ps := &Interface_Ethernet_SwitchedVlan_NativeVlanPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "native-vlan"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// TrunkVlans (leaf-list): Specify VLANs, or ranges thereof, that the interface may
// carry when in trunk mode.  If not specified, all VLANs are
// allowed on the interface. Ranges are specified in the form
// x..y, where x<y - ranges are assumed to be inclusive (such
// that the VLAN range is x <= range <= y.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/trunk-vlans"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/*/trunk-vlans"
func (n *Interface_Ethernet_SwitchedVlanPath) TrunkVlans() *Interface_Ethernet_SwitchedVlan_TrunkVlansPath {
	ps := &Interface_Ethernet_SwitchedVlan_TrunkVlansPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "trunk-vlans"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// TrunkVlans (leaf-list): Specify VLANs, or ranges thereof, that the interface may
// carry when in trunk mode.  If not specified, all VLANs are
// allowed on the interface. Ranges are specified in the form
// x..y, where x<y - ranges are assumed to be inclusive (such
// that the VLAN range is x <= range <= y.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/trunk-vlans"
//	Path from root:       "/interfaces/interface/ethernet/switched-vlan/*/trunk-vlans"
func (n *Interface_Ethernet_SwitchedVlanPathAny) TrunkVlans() *Interface_Ethernet_SwitchedVlan_TrunkVlansPathAny {
	ps := &Interface_Ethernet_SwitchedVlan_TrunkVlansPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "trunk-vlans"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_Ethernet_SwitchedVlanPath) State() ygnmi.SingletonQuery[*oc.Interface_Ethernet_SwitchedVlan] {
	return ygnmi.NewSingletonQuery[*oc.Interface_Ethernet_SwitchedVlan](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_Ethernet_SwitchedVlanPathAny) State() ygnmi.WildcardQuery[*oc.Interface_Ethernet_SwitchedVlan] {
	return ygnmi.NewWildcardQuery[*oc.Interface_Ethernet_SwitchedVlan](
		"Interface_Ethernet_SwitchedVlan",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_Ethernet_SwitchedVlanPath) Config() ygnmi.ConfigQuery[*oc.Interface_Ethernet_SwitchedVlan] {
	return ygnmi.NewConfigQuery[*oc.Interface_Ethernet_SwitchedVlan](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_Ethernet_SwitchedVlanPathAny) Config() ygnmi.WildcardQuery[*oc.Interface_Ethernet_SwitchedVlan] {
	return ygnmi.NewWildcardQuery[*oc.Interface_Ethernet_SwitchedVlan](
		"Interface_Ethernet_SwitchedVlan",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_HoldTime_DownPath represents the /openconfig-interfaces/interfaces/interface/hold-time/state/down YANG schema element.
type Interface_HoldTime_DownPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_HoldTime_DownPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/hold-time/state/down YANG schema element.
type Interface_HoldTime_DownPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/down"
//	Path from root:       "/interfaces/interface/hold-time/state/down"
func (n *Interface_HoldTime_DownPath) State() ygnmi.SingletonQuery[uint32] {
	return ygnmi.NewSingletonQuery[uint32](
		"Interface_HoldTime",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "down"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_HoldTime).Down
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_HoldTime) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/down"
//	Path from root:       "/interfaces/interface/hold-time/state/down"
func (n *Interface_HoldTime_DownPathAny) State() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_HoldTime",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "down"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_HoldTime).Down
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_HoldTime) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/down"
//	Path from root:       "/interfaces/interface/hold-time/config/down"
func (n *Interface_HoldTime_DownPath) Config() ygnmi.ConfigQuery[uint32] {
	return ygnmi.NewConfigQuery[uint32](
		"Interface_HoldTime",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "down"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_HoldTime).Down
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_HoldTime) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/down"
//	Path from root:       "/interfaces/interface/hold-time/config/down"
func (n *Interface_HoldTime_DownPathAny) Config() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_HoldTime",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "down"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_HoldTime).Down
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_HoldTime) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_HoldTime_UpPath represents the /openconfig-interfaces/interfaces/interface/hold-time/state/up YANG schema element.
type Interface_HoldTime_UpPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_HoldTime_UpPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/hold-time/state/up YANG schema element.
type Interface_HoldTime_UpPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/up"
//	Path from root:       "/interfaces/interface/hold-time/state/up"
func (n *Interface_HoldTime_UpPath) State() ygnmi.SingletonQuery[uint32] {
	return ygnmi.NewSingletonQuery[uint32](
		"Interface_HoldTime",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "up"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_HoldTime).Up
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_HoldTime) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/up"
//	Path from root:       "/interfaces/interface/hold-time/state/up"
func (n *Interface_HoldTime_UpPathAny) State() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_HoldTime",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "up"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_HoldTime).Up
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_HoldTime) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/up"
//	Path from root:       "/interfaces/interface/hold-time/config/up"
func (n *Interface_HoldTime_UpPath) Config() ygnmi.ConfigQuery[uint32] {
	return ygnmi.NewConfigQuery[uint32](
		"Interface_HoldTime",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "up"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_HoldTime).Up
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_HoldTime) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/up"
//	Path from root:       "/interfaces/interface/hold-time/config/up"
func (n *Interface_HoldTime_UpPathAny) Config() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_HoldTime",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "up"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_HoldTime).Up
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_HoldTime) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_HoldTimePath represents the /openconfig-interfaces/interfaces/interface/hold-time YANG schema element.
type Interface_HoldTimePath struct {
	*ygnmi.NodePath
}

// Interface_HoldTimePathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/hold-time YANG schema element.
type Interface_HoldTimePathAny struct {
	*ygnmi.NodePath
}

// Down (leaf): Dampens advertisement when the interface transitions from
// up to down.  A zero value means dampening is turned off,
// i.e., immediate notification.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/down"
//	Path from root:       "/interfaces/interface/hold-time/*/down"
func (n *Interface_HoldTimePath) Down() *Interface_HoldTime_DownPath {
	ps := &Interface_HoldTime_DownPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "down"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Down (leaf): Dampens advertisement when the interface transitions from
// up to down.  A zero value means dampening is turned off,
// i.e., immediate notification.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/down"
//	Path from root:       "/interfaces/interface/hold-time/*/down"
func (n *Interface_HoldTimePathAny) Down() *Interface_HoldTime_DownPathAny {
	ps := &Interface_HoldTime_DownPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "down"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Up (leaf): Dampens advertisement when the interface
// transitions from down to up.  A zero value means dampening
// is turned off, i.e., immediate notification.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/up"
//	Path from root:       "/interfaces/interface/hold-time/*/up"
func (n *Interface_HoldTimePath) Up() *Interface_HoldTime_UpPath {
	ps := &Interface_HoldTime_UpPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "up"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Up (leaf): Dampens advertisement when the interface
// transitions from down to up.  A zero value means dampening
// is turned off, i.e., immediate notification.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/up"
//	Path from root:       "/interfaces/interface/hold-time/*/up"
func (n *Interface_HoldTimePathAny) Up() *Interface_HoldTime_UpPathAny {
	ps := &Interface_HoldTime_UpPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "up"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_HoldTimePath) State() ygnmi.SingletonQuery[*oc.Interface_HoldTime] {
	return ygnmi.NewSingletonQuery[*oc.Interface_HoldTime](
		"Interface_HoldTime",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_HoldTimePathAny) State() ygnmi.WildcardQuery[*oc.Interface_HoldTime] {
	return ygnmi.NewWildcardQuery[*oc.Interface_HoldTime](
		"Interface_HoldTime",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_HoldTimePath) Config() ygnmi.ConfigQuery[*oc.Interface_HoldTime] {
	return ygnmi.NewConfigQuery[*oc.Interface_HoldTime](
		"Interface_HoldTime",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_HoldTimePathAny) Config() ygnmi.WildcardQuery[*oc.Interface_HoldTime] {
	return ygnmi.NewWildcardQuery[*oc.Interface_HoldTime](
		"Interface_HoldTime",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_PenaltyBasedAied_DecayHalfLifePath represents the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/decay-half-life YANG schema element.
type Interface_PenaltyBasedAied_DecayHalfLifePath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_PenaltyBasedAied_DecayHalfLifePathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/decay-half-life YANG schema element.
type Interface_PenaltyBasedAied_DecayHalfLifePathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/decay-half-life"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/decay-half-life"
func (n *Interface_PenaltyBasedAied_DecayHalfLifePath) State() ygnmi.SingletonQuery[uint32] {
	return ygnmi.NewSingletonQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "decay-half-life"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).DecayHalfLife
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/decay-half-life"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/decay-half-life"
func (n *Interface_PenaltyBasedAied_DecayHalfLifePathAny) State() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "decay-half-life"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).DecayHalfLife
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/decay-half-life"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/decay-half-life"
func (n *Interface_PenaltyBasedAied_DecayHalfLifePath) Config() ygnmi.ConfigQuery[uint32] {
	return ygnmi.NewConfigQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "decay-half-life"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).DecayHalfLife
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/decay-half-life"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/decay-half-life"
func (n *Interface_PenaltyBasedAied_DecayHalfLifePathAny) Config() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "decay-half-life"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).DecayHalfLife
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_PenaltyBasedAied_FlapPenaltyPath represents the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/flap-penalty YANG schema element.
type Interface_PenaltyBasedAied_FlapPenaltyPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_PenaltyBasedAied_FlapPenaltyPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/flap-penalty YANG schema element.
type Interface_PenaltyBasedAied_FlapPenaltyPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/flap-penalty"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/flap-penalty"
func (n *Interface_PenaltyBasedAied_FlapPenaltyPath) State() ygnmi.SingletonQuery[uint32] {
	return ygnmi.NewSingletonQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "flap-penalty"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).FlapPenalty
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/flap-penalty"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/flap-penalty"
func (n *Interface_PenaltyBasedAied_FlapPenaltyPathAny) State() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "flap-penalty"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).FlapPenalty
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/flap-penalty"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/flap-penalty"
func (n *Interface_PenaltyBasedAied_FlapPenaltyPath) Config() ygnmi.ConfigQuery[uint32] {
	return ygnmi.NewConfigQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "flap-penalty"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).FlapPenalty
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/flap-penalty"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/flap-penalty"
func (n *Interface_PenaltyBasedAied_FlapPenaltyPathAny) Config() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "flap-penalty"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).FlapPenalty
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_PenaltyBasedAied_MaxSuppressTimePath represents the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/max-suppress-time YANG schema element.
type Interface_PenaltyBasedAied_MaxSuppressTimePath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_PenaltyBasedAied_MaxSuppressTimePathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/max-suppress-time YANG schema element.
type Interface_PenaltyBasedAied_MaxSuppressTimePathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/max-suppress-time"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/max-suppress-time"
func (n *Interface_PenaltyBasedAied_MaxSuppressTimePath) State() ygnmi.SingletonQuery[uint32] {
	return ygnmi.NewSingletonQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "max-suppress-time"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).MaxSuppressTime
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/max-suppress-time"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/max-suppress-time"
func (n *Interface_PenaltyBasedAied_MaxSuppressTimePathAny) State() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "max-suppress-time"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).MaxSuppressTime
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/max-suppress-time"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/max-suppress-time"
func (n *Interface_PenaltyBasedAied_MaxSuppressTimePath) Config() ygnmi.ConfigQuery[uint32] {
	return ygnmi.NewConfigQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "max-suppress-time"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).MaxSuppressTime
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/max-suppress-time"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/max-suppress-time"
func (n *Interface_PenaltyBasedAied_MaxSuppressTimePathAny) Config() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "max-suppress-time"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).MaxSuppressTime
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_PenaltyBasedAied_ReuseThresholdPath represents the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/reuse-threshold YANG schema element.
type Interface_PenaltyBasedAied_ReuseThresholdPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_PenaltyBasedAied_ReuseThresholdPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/reuse-threshold YANG schema element.
type Interface_PenaltyBasedAied_ReuseThresholdPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/reuse-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/reuse-threshold"
func (n *Interface_PenaltyBasedAied_ReuseThresholdPath) State() ygnmi.SingletonQuery[uint32] {
	return ygnmi.NewSingletonQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "reuse-threshold"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).ReuseThreshold
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/reuse-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/reuse-threshold"
func (n *Interface_PenaltyBasedAied_ReuseThresholdPathAny) State() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "reuse-threshold"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).ReuseThreshold
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/reuse-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/reuse-threshold"
func (n *Interface_PenaltyBasedAied_ReuseThresholdPath) Config() ygnmi.ConfigQuery[uint32] {
	return ygnmi.NewConfigQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "reuse-threshold"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).ReuseThreshold
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/reuse-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/reuse-threshold"
func (n *Interface_PenaltyBasedAied_ReuseThresholdPathAny) Config() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "reuse-threshold"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).ReuseThreshold
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_PenaltyBasedAied_SuppressThresholdPath represents the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/suppress-threshold YANG schema element.
type Interface_PenaltyBasedAied_SuppressThresholdPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_PenaltyBasedAied_SuppressThresholdPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/penalty-based-aied/state/suppress-threshold YANG schema element.
type Interface_PenaltyBasedAied_SuppressThresholdPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/suppress-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/suppress-threshold"
func (n *Interface_PenaltyBasedAied_SuppressThresholdPath) State() ygnmi.SingletonQuery[uint32] {
	return ygnmi.NewSingletonQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "suppress-threshold"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).SuppressThreshold
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/suppress-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/state/suppress-threshold"
func (n *Interface_PenaltyBasedAied_SuppressThresholdPathAny) State() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "suppress-threshold"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).SuppressThreshold
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/suppress-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/suppress-threshold"
func (n *Interface_PenaltyBasedAied_SuppressThresholdPath) Config() ygnmi.ConfigQuery[uint32] {
	return ygnmi.NewConfigQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "suppress-threshold"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).SuppressThreshold
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "config/suppress-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/config/suppress-threshold"
func (n *Interface_PenaltyBasedAied_SuppressThresholdPathAny) Config() ygnmi.WildcardQuery[uint32] {
	return ygnmi.NewWildcardQuery[uint32](
		"Interface_PenaltyBasedAied",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "suppress-threshold"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint32, bool) {
			ret := gs.(*oc.Interface_PenaltyBasedAied).SuppressThreshold
			if ret == nil {
				var zero uint32
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_PenaltyBasedAied) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_PenaltyBasedAiedPath represents the /openconfig-interfaces/interfaces/interface/penalty-based-aied YANG schema element.
type Interface_PenaltyBasedAiedPath struct {
	*ygnmi.NodePath
}

// Interface_PenaltyBasedAiedPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/penalty-based-aied YANG schema element.
type Interface_PenaltyBasedAiedPathAny struct {
	*ygnmi.NodePath
}

// DecayHalfLife (leaf): The amount of time after which an interface's penalty is decreased by half. Decay-half-time should not be more than max-suppress-time.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/decay-half-life"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/decay-half-life"
func (n *Interface_PenaltyBasedAiedPath) DecayHalfLife() *Interface_PenaltyBasedAied_DecayHalfLifePath {
	ps := &Interface_PenaltyBasedAied_DecayHalfLifePath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "decay-half-life"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// DecayHalfLife (leaf): The amount of time after which an interface's penalty is decreased by half. Decay-half-time should not be more than max-suppress-time.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/decay-half-life"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/decay-half-life"
func (n *Interface_PenaltyBasedAiedPathAny) DecayHalfLife() *Interface_PenaltyBasedAied_DecayHalfLifePathAny {
	ps := &Interface_PenaltyBasedAied_DecayHalfLifePathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "decay-half-life"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// FlapPenalty (leaf): A penalty that each down event costs. A value of 0 indicates the config is disabled.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/flap-penalty"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/flap-penalty"
func (n *Interface_PenaltyBasedAiedPath) FlapPenalty() *Interface_PenaltyBasedAied_FlapPenaltyPath {
	ps := &Interface_PenaltyBasedAied_FlapPenaltyPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "flap-penalty"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// FlapPenalty (leaf): A penalty that each down event costs. A value of 0 indicates the config is disabled.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/flap-penalty"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/flap-penalty"
func (n *Interface_PenaltyBasedAiedPathAny) FlapPenalty() *Interface_PenaltyBasedAied_FlapPenaltyPathAny {
	ps := &Interface_PenaltyBasedAied_FlapPenaltyPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "flap-penalty"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// MaxSuppressTime (leaf): Maximum time an interface can remain damped since the last link down event no matter how unstable it has been prior to this period of stability. In a damped state, the interface's state change will not be advertised.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/max-suppress-time"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/max-suppress-time"
func (n *Interface_PenaltyBasedAiedPath) MaxSuppressTime() *Interface_PenaltyBasedAied_MaxSuppressTimePath {
	ps := &Interface_PenaltyBasedAied_MaxSuppressTimePath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "max-suppress-time"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// MaxSuppressTime (leaf): Maximum time an interface can remain damped since the last link down event no matter how unstable it has been prior to this period of stability. In a damped state, the interface's state change will not be advertised.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/max-suppress-time"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/max-suppress-time"
func (n *Interface_PenaltyBasedAiedPathAny) MaxSuppressTime() *Interface_PenaltyBasedAied_MaxSuppressTimePathAny {
	ps := &Interface_PenaltyBasedAied_MaxSuppressTimePathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "max-suppress-time"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// ReuseThreshold (leaf): When the accumulated penalty decreases to this reuse threshold, the interface is not damped anymore. Interface state changes are advertised to applications. A value of 0 indicates config is disabled.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/reuse-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/reuse-threshold"
func (n *Interface_PenaltyBasedAiedPath) ReuseThreshold() *Interface_PenaltyBasedAied_ReuseThresholdPath {
	ps := &Interface_PenaltyBasedAied_ReuseThresholdPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "reuse-threshold"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// ReuseThreshold (leaf): When the accumulated penalty decreases to this reuse threshold, the interface is not damped anymore. Interface state changes are advertised to applications. A value of 0 indicates config is disabled.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/reuse-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/reuse-threshold"
func (n *Interface_PenaltyBasedAiedPathAny) ReuseThreshold() *Interface_PenaltyBasedAied_ReuseThresholdPathAny {
	ps := &Interface_PenaltyBasedAied_ReuseThresholdPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "reuse-threshold"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// SuppressThreshold (leaf): The accumulated penalty that triggers the damping of an interface. A value of 0 indicates config is disabled.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/suppress-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/suppress-threshold"
func (n *Interface_PenaltyBasedAiedPath) SuppressThreshold() *Interface_PenaltyBasedAied_SuppressThresholdPath {
	ps := &Interface_PenaltyBasedAied_SuppressThresholdPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "suppress-threshold"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// SuppressThreshold (leaf): The accumulated penalty that triggers the damping of an interface. A value of 0 indicates config is disabled.
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/suppress-threshold"
//	Path from root:       "/interfaces/interface/penalty-based-aied/*/suppress-threshold"
func (n *Interface_PenaltyBasedAiedPathAny) SuppressThreshold() *Interface_PenaltyBasedAied_SuppressThresholdPathAny {
	ps := &Interface_PenaltyBasedAied_SuppressThresholdPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "suppress-threshold"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_PenaltyBasedAiedPath) State() ygnmi.SingletonQuery[*oc.Interface_PenaltyBasedAied] {
	return ygnmi.NewSingletonQuery[*oc.Interface_PenaltyBasedAied](
		"Interface_PenaltyBasedAied",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_PenaltyBasedAiedPathAny) State() ygnmi.WildcardQuery[*oc.Interface_PenaltyBasedAied] {
	return ygnmi.NewWildcardQuery[*oc.Interface_PenaltyBasedAied](
		"Interface_PenaltyBasedAied",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_PenaltyBasedAiedPath) Config() ygnmi.ConfigQuery[*oc.Interface_PenaltyBasedAied] {
	return ygnmi.NewConfigQuery[*oc.Interface_PenaltyBasedAied](
		"Interface_PenaltyBasedAied",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_PenaltyBasedAiedPathAny) Config() ygnmi.WildcardQuery[*oc.Interface_PenaltyBasedAied] {
	return ygnmi.NewWildcardQuery[*oc.Interface_PenaltyBasedAied](
		"Interface_PenaltyBasedAied",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_RoutedVlan_VlanPath represents the /openconfig-interfaces/interfaces/interface/routed-vlan/state/vlan YANG schema element.
type Interface_RoutedVlan_VlanPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_RoutedVlan_VlanPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/routed-vlan/state/vlan YANG schema element.
type Interface_RoutedVlan_VlanPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/vlan"
//	Path from root:       "/interfaces/interface/routed-vlan/state/vlan"
func (n *Interface_RoutedVlan_VlanPath) State() ygnmi.SingletonQuery[oc.Interface_RoutedVlan_Vlan_Union] {
	return ygnmi.NewSingletonQuery[oc.Interface_RoutedVlan_Vlan_Union](
		"Interface_RoutedVlan",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.Interface_RoutedVlan_Vlan_Union, bool) {
			ret := gs.(*oc.Interface_RoutedVlan).Vlan
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "state/vlan"
//	Path from root:       "/interfaces/interface/routed-vlan/state/vlan"
func (n *Interface_RoutedVlan_VlanPathAny) State() ygnmi.WildcardQuery[oc.Interface_RoutedVlan_Vlan_Union] {
	return ygnmi.NewWildcardQuery[oc.Interface_RoutedVlan_Vlan_Union](
		"Interface_RoutedVlan",
		true,
		false,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.Interface_RoutedVlan_Vlan_Union, bool) {
			ret := gs.(*oc.Interface_RoutedVlan).Vlan
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/vlan"
//	Path from root:       "/interfaces/interface/routed-vlan/config/vlan"
func (n *Interface_RoutedVlan_VlanPath) Config() ygnmi.ConfigQuery[oc.Interface_RoutedVlan_Vlan_Union] {
	return ygnmi.NewConfigQuery[oc.Interface_RoutedVlan_Vlan_Union](
		"Interface_RoutedVlan",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.Interface_RoutedVlan_Vlan_Union, bool) {
			ret := gs.(*oc.Interface_RoutedVlan).Vlan
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-vlan"
//	Path from parent:     "config/vlan"
//	Path from root:       "/interfaces/interface/routed-vlan/config/vlan"
func (n *Interface_RoutedVlan_VlanPathAny) Config() ygnmi.WildcardQuery[oc.Interface_RoutedVlan_Vlan_Union] {
	return ygnmi.NewWildcardQuery[oc.Interface_RoutedVlan_Vlan_Union](
		"Interface_RoutedVlan",
		false,
		true,
		true,
		false,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "vlan"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (oc.Interface_RoutedVlan_Vlan_Union, bool) {
			ret := gs.(*oc.Interface_RoutedVlan).Vlan
			return ret, !reflect.ValueOf(ret).IsZero()
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_RoutedVlanPath represents the /openconfig-interfaces/interfaces/interface/routed-vlan YANG schema element.
type Interface_RoutedVlanPath struct {
	*ygnmi.NodePath
}

// Interface_RoutedVlanPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/routed-vlan YANG schema element.
type Interface_RoutedVlanPathAny struct {
	*ygnmi.NodePath
}

// Ipv4 (container): Parameters for the IPv4 address family.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "ipv4"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4"
func (n *Interface_RoutedVlanPath) Ipv4() *Interface_RoutedVlan_Ipv4Path {
	ps := &Interface_RoutedVlan_Ipv4Path{
		NodePath: ygnmi.NewNodePath(
			[]string{"ipv4"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Ipv4 (container): Parameters for the IPv4 address family.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "ipv4"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4"
func (n *Interface_RoutedVlanPathAny) Ipv4() *Interface_RoutedVlan_Ipv4PathAny {
	ps := &Interface_RoutedVlan_Ipv4PathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"ipv4"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Ipv6 (container): Parameters for the IPv6 address family.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "ipv6"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv6"
func (n *Interface_RoutedVlanPath) Ipv6() *Interface_RoutedVlan_Ipv6Path {
	ps := &Interface_RoutedVlan_Ipv6Path{
		NodePath: ygnmi.NewNodePath(
			[]string{"ipv6"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Ipv6 (container): Parameters for the IPv6 address family.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "ipv6"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv6"
func (n *Interface_RoutedVlanPathAny) Ipv6() *Interface_RoutedVlan_Ipv6PathAny {
	ps := &Interface_RoutedVlan_Ipv6PathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"ipv6"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Vlan (leaf): References the VLAN for which this IP interface
// provides routing services -- similar to a switch virtual
// interface (SVI), or integrated routing and bridging interface
// (IRB) in some implementations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/vlan"
//	Path from root:       "/interfaces/interface/routed-vlan/*/vlan"
func (n *Interface_RoutedVlanPath) Vlan() *Interface_RoutedVlan_VlanPath {
	ps := &Interface_RoutedVlan_VlanPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "vlan"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Vlan (leaf): References the VLAN for which this IP interface
// provides routing services -- similar to a switch virtual
// interface (SVI), or integrated routing and bridging interface
// (IRB) in some implementations.
//
//	Defining module:      "openconfig-vlan"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/vlan"
//	Path from root:       "/interfaces/interface/routed-vlan/*/vlan"
func (n *Interface_RoutedVlanPathAny) Vlan() *Interface_RoutedVlan_VlanPathAny {
	ps := &Interface_RoutedVlan_VlanPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "vlan"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_RoutedVlanPath) State() ygnmi.SingletonQuery[*oc.Interface_RoutedVlan] {
	return ygnmi.NewSingletonQuery[*oc.Interface_RoutedVlan](
		"Interface_RoutedVlan",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_RoutedVlanPathAny) State() ygnmi.WildcardQuery[*oc.Interface_RoutedVlan] {
	return ygnmi.NewWildcardQuery[*oc.Interface_RoutedVlan](
		"Interface_RoutedVlan",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_RoutedVlanPath) Config() ygnmi.ConfigQuery[*oc.Interface_RoutedVlan] {
	return ygnmi.NewConfigQuery[*oc.Interface_RoutedVlan](
		"Interface_RoutedVlan",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_RoutedVlanPathAny) Config() ygnmi.WildcardQuery[*oc.Interface_RoutedVlan] {
	return ygnmi.NewWildcardQuery[*oc.Interface_RoutedVlan](
		"Interface_RoutedVlan",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_RoutedVlan_Ipv4_DhcpClientPath represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/dhcp-client YANG schema element.
type Interface_RoutedVlan_Ipv4_DhcpClientPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_RoutedVlan_Ipv4_DhcpClientPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/dhcp-client YANG schema element.
type Interface_RoutedVlan_Ipv4_DhcpClientPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "state/dhcp-client"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/state/dhcp-client"
func (n *Interface_RoutedVlan_Ipv4_DhcpClientPath) State() ygnmi.SingletonQuery[bool] {
	return ygnmi.NewSingletonQuery[bool](
		"Interface_RoutedVlan_Ipv4",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "dhcp-client"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).DhcpClient
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "state/dhcp-client"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/state/dhcp-client"
func (n *Interface_RoutedVlan_Ipv4_DhcpClientPathAny) State() ygnmi.WildcardQuery[bool] {
	return ygnmi.NewWildcardQuery[bool](
		"Interface_RoutedVlan_Ipv4",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "dhcp-client"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).DhcpClient
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "config/dhcp-client"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/config/dhcp-client"
func (n *Interface_RoutedVlan_Ipv4_DhcpClientPath) Config() ygnmi.ConfigQuery[bool] {
	return ygnmi.NewConfigQuery[bool](
		"Interface_RoutedVlan_Ipv4",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "dhcp-client"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).DhcpClient
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "config/dhcp-client"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/config/dhcp-client"
func (n *Interface_RoutedVlan_Ipv4_DhcpClientPathAny) Config() ygnmi.WildcardQuery[bool] {
	return ygnmi.NewWildcardQuery[bool](
		"Interface_RoutedVlan_Ipv4",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "dhcp-client"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).DhcpClient
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_RoutedVlan_Ipv4_EnabledPath represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/enabled YANG schema element.
type Interface_RoutedVlan_Ipv4_EnabledPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_RoutedVlan_Ipv4_EnabledPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/enabled YANG schema element.
type Interface_RoutedVlan_Ipv4_EnabledPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "state/enabled"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/state/enabled"
func (n *Interface_RoutedVlan_Ipv4_EnabledPath) State() ygnmi.SingletonQuery[bool] {
	return ygnmi.NewSingletonQuery[bool](
		"Interface_RoutedVlan_Ipv4",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "enabled"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).Enabled
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "state/enabled"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/state/enabled"
func (n *Interface_RoutedVlan_Ipv4_EnabledPathAny) State() ygnmi.WildcardQuery[bool] {
	return ygnmi.NewWildcardQuery[bool](
		"Interface_RoutedVlan_Ipv4",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "enabled"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).Enabled
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "config/enabled"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/config/enabled"
func (n *Interface_RoutedVlan_Ipv4_EnabledPath) Config() ygnmi.ConfigQuery[bool] {
	return ygnmi.NewConfigQuery[bool](
		"Interface_RoutedVlan_Ipv4",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "enabled"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).Enabled
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "config/enabled"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/config/enabled"
func (n *Interface_RoutedVlan_Ipv4_EnabledPathAny) Config() ygnmi.WildcardQuery[bool] {
	return ygnmi.NewWildcardQuery[bool](
		"Interface_RoutedVlan_Ipv4",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "enabled"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (bool, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).Enabled
			if ret == nil {
				var zero bool
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_RoutedVlan_Ipv4_MtuPath represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/mtu YANG schema element.
type Interface_RoutedVlan_Ipv4_MtuPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_RoutedVlan_Ipv4_MtuPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/mtu YANG schema element.
type Interface_RoutedVlan_Ipv4_MtuPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "state/mtu"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/state/mtu"
func (n *Interface_RoutedVlan_Ipv4_MtuPath) State() ygnmi.SingletonQuery[uint16] {
	return ygnmi.NewSingletonQuery[uint16](
		"Interface_RoutedVlan_Ipv4",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "mtu"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).Mtu
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "state/mtu"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/state/mtu"
func (n *Interface_RoutedVlan_Ipv4_MtuPathAny) State() ygnmi.WildcardQuery[uint16] {
	return ygnmi.NewWildcardQuery[uint16](
		"Interface_RoutedVlan_Ipv4",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "mtu"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).Mtu
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "config/mtu"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/config/mtu"
func (n *Interface_RoutedVlan_Ipv4_MtuPath) Config() ygnmi.ConfigQuery[uint16] {
	return ygnmi.NewConfigQuery[uint16](
		"Interface_RoutedVlan_Ipv4",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "mtu"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).Mtu
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "config/mtu"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/config/mtu"
func (n *Interface_RoutedVlan_Ipv4_MtuPathAny) Config() ygnmi.WildcardQuery[uint16] {
	return ygnmi.NewWildcardQuery[uint16](
		"Interface_RoutedVlan_Ipv4",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "mtu"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (uint16, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4).Mtu
			if ret == nil {
				var zero uint16
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_RoutedVlan_Ipv4Path represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4 YANG schema element.
type Interface_RoutedVlan_Ipv4Path struct {
	*ygnmi.NodePath
}

// Interface_RoutedVlan_Ipv4PathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4 YANG schema element.
type Interface_RoutedVlan_Ipv4PathAny struct {
	*ygnmi.NodePath
}

// AddressAny (list): The list of configured IPv4 addresses on the interface.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "addresses/address"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address"
func (n *Interface_RoutedVlan_Ipv4Path) AddressAny() *Interface_RoutedVlan_Ipv4_AddressPathAny {
	ps := &Interface_RoutedVlan_Ipv4_AddressPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"addresses", "address"},
			map[string]interface{}{"ip": "*"},
			n,
		),
	}
	return ps
}

// AddressAny (list): The list of configured IPv4 addresses on the interface.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "addresses/address"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address"
func (n *Interface_RoutedVlan_Ipv4PathAny) AddressAny() *Interface_RoutedVlan_Ipv4_AddressPathAny {
	ps := &Interface_RoutedVlan_Ipv4_AddressPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"addresses", "address"},
			map[string]interface{}{"ip": "*"},
			n,
		),
	}
	return ps
}

// Address (list): The list of configured IPv4 addresses on the interface.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "addresses/address"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address"
//
//	Ip: string
func (n *Interface_RoutedVlan_Ipv4Path) Address(Ip string) *Interface_RoutedVlan_Ipv4_AddressPath {
	ps := &Interface_RoutedVlan_Ipv4_AddressPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"addresses", "address"},
			map[string]interface{}{"ip": Ip},
			n,
		),
	}
	return ps
}

// Address (list): The list of configured IPv4 addresses on the interface.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "addresses/address"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address"
//
//	Ip: string
func (n *Interface_RoutedVlan_Ipv4PathAny) Address(Ip string) *Interface_RoutedVlan_Ipv4_AddressPathAny {
	ps := &Interface_RoutedVlan_Ipv4_AddressPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"addresses", "address"},
			map[string]interface{}{"ip": Ip},
			n,
		),
	}
	return ps
}

// AddressMap (list): The list of configured IPv4 addresses on the interface.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "addresses/address"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address"
func (n *Interface_RoutedVlan_Ipv4Path) AddressMap() *Interface_RoutedVlan_Ipv4_AddressPathMap {
	ps := &Interface_RoutedVlan_Ipv4_AddressPathMap{
		NodePath: ygnmi.NewNodePath(
			[]string{"addresses"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// AddressMap (list): The list of configured IPv4 addresses on the interface.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "addresses/address"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address"
func (n *Interface_RoutedVlan_Ipv4PathAny) AddressMap() *Interface_RoutedVlan_Ipv4_AddressPathMapAny {
	ps := &Interface_RoutedVlan_Ipv4_AddressPathMapAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"addresses"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Counters (container): Packet and byte counters for IP transmission and
// reception for the address family.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/counters"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/state/counters"
func (n *Interface_RoutedVlan_Ipv4Path) Counters() *Interface_RoutedVlan_Ipv4_CountersPath {
	ps := &Interface_RoutedVlan_Ipv4_CountersPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "counters"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Counters (container): Packet and byte counters for IP transmission and
// reception for the address family.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "state/counters"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/state/counters"
func (n *Interface_RoutedVlan_Ipv4PathAny) Counters() *Interface_RoutedVlan_Ipv4_CountersPathAny {
	ps := &Interface_RoutedVlan_Ipv4_CountersPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"state", "counters"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// DhcpClient (leaf): Enables a DHCP client on the interface in order to request
// an address
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/dhcp-client"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/*/dhcp-client"
func (n *Interface_RoutedVlan_Ipv4Path) DhcpClient() *Interface_RoutedVlan_Ipv4_DhcpClientPath {
	ps := &Interface_RoutedVlan_Ipv4_DhcpClientPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "dhcp-client"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// DhcpClient (leaf): Enables a DHCP client on the interface in order to request
// an address
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/dhcp-client"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/*/dhcp-client"
func (n *Interface_RoutedVlan_Ipv4PathAny) DhcpClient() *Interface_RoutedVlan_Ipv4_DhcpClientPathAny {
	ps := &Interface_RoutedVlan_Ipv4_DhcpClientPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "dhcp-client"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Enabled (leaf): Controls whether IPv4 is enabled or disabled on this
// interface.  When IPv4 is enabled, this interface is
// connected to an IPv4 stack, and the interface can send
// and receive IPv4 packets.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/enabled"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/*/enabled"
func (n *Interface_RoutedVlan_Ipv4Path) Enabled() *Interface_RoutedVlan_Ipv4_EnabledPath {
	ps := &Interface_RoutedVlan_Ipv4_EnabledPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "enabled"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Enabled (leaf): Controls whether IPv4 is enabled or disabled on this
// interface.  When IPv4 is enabled, this interface is
// connected to an IPv4 stack, and the interface can send
// and receive IPv4 packets.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/enabled"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/*/enabled"
func (n *Interface_RoutedVlan_Ipv4PathAny) Enabled() *Interface_RoutedVlan_Ipv4_EnabledPathAny {
	ps := &Interface_RoutedVlan_Ipv4_EnabledPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "enabled"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Mtu (leaf): The size, in octets, of the largest IPv4 packet that the
// interface will send and receive.
//
// The server may restrict the allowed values for this leaf,
// depending on the interface's type.
//
// If this leaf is not configured, the operationally used MTU
// depends on the interface's type.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/mtu"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/*/mtu"
func (n *Interface_RoutedVlan_Ipv4Path) Mtu() *Interface_RoutedVlan_Ipv4_MtuPath {
	ps := &Interface_RoutedVlan_Ipv4_MtuPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "mtu"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// Mtu (leaf): The size, in octets, of the largest IPv4 packet that the
// interface will send and receive.
//
// The server may restrict the allowed values for this leaf,
// depending on the interface's type.
//
// If this leaf is not configured, the operationally used MTU
// depends on the interface's type.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "*/mtu"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/*/mtu"
func (n *Interface_RoutedVlan_Ipv4PathAny) Mtu() *Interface_RoutedVlan_Ipv4_MtuPathAny {
	ps := &Interface_RoutedVlan_Ipv4_MtuPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"*", "mtu"},
			map[string]interface{}{},
			n,
		),
		parent: n,
	}
	return ps
}

// NeighborAny (list): A list of mappings from IPv4 addresses to
// link-layer addresses.
//
// Entries in this list are used as static entries in the
// ARP Cache.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "neighbors/neighbor"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor"
func (n *Interface_RoutedVlan_Ipv4Path) NeighborAny() *Interface_RoutedVlan_Ipv4_NeighborPathAny {
	ps := &Interface_RoutedVlan_Ipv4_NeighborPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"neighbors", "neighbor"},
			map[string]interface{}{"ip": "*"},
			n,
		),
	}
	return ps
}

// NeighborAny (list): A list of mappings from IPv4 addresses to
// link-layer addresses.
//
// Entries in this list are used as static entries in the
// ARP Cache.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "neighbors/neighbor"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor"
func (n *Interface_RoutedVlan_Ipv4PathAny) NeighborAny() *Interface_RoutedVlan_Ipv4_NeighborPathAny {
	ps := &Interface_RoutedVlan_Ipv4_NeighborPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"neighbors", "neighbor"},
			map[string]interface{}{"ip": "*"},
			n,
		),
	}
	return ps
}

// Neighbor (list): A list of mappings from IPv4 addresses to
// link-layer addresses.
//
// Entries in this list are used as static entries in the
// ARP Cache.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "neighbors/neighbor"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor"
//
//	Ip: string
func (n *Interface_RoutedVlan_Ipv4Path) Neighbor(Ip string) *Interface_RoutedVlan_Ipv4_NeighborPath {
	ps := &Interface_RoutedVlan_Ipv4_NeighborPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"neighbors", "neighbor"},
			map[string]interface{}{"ip": Ip},
			n,
		),
	}
	return ps
}

// Neighbor (list): A list of mappings from IPv4 addresses to
// link-layer addresses.
//
// Entries in this list are used as static entries in the
// ARP Cache.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "neighbors/neighbor"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor"
//
//	Ip: string
func (n *Interface_RoutedVlan_Ipv4PathAny) Neighbor(Ip string) *Interface_RoutedVlan_Ipv4_NeighborPathAny {
	ps := &Interface_RoutedVlan_Ipv4_NeighborPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"neighbors", "neighbor"},
			map[string]interface{}{"ip": Ip},
			n,
		),
	}
	return ps
}

// NeighborMap (list): A list of mappings from IPv4 addresses to
// link-layer addresses.
//
// Entries in this list are used as static entries in the
// ARP Cache.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "neighbors/neighbor"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor"
func (n *Interface_RoutedVlan_Ipv4Path) NeighborMap() *Interface_RoutedVlan_Ipv4_NeighborPathMap {
	ps := &Interface_RoutedVlan_Ipv4_NeighborPathMap{
		NodePath: ygnmi.NewNodePath(
			[]string{"neighbors"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// NeighborMap (list): A list of mappings from IPv4 addresses to
// link-layer addresses.
//
// Entries in this list are used as static entries in the
// ARP Cache.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "neighbors/neighbor"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor"
func (n *Interface_RoutedVlan_Ipv4PathAny) NeighborMap() *Interface_RoutedVlan_Ipv4_NeighborPathMapAny {
	ps := &Interface_RoutedVlan_Ipv4_NeighborPathMapAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"neighbors"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// ProxyArp (container): Configuration and operational state parameters
// relating to proxy ARP. This functionality allows a
// system to respond to ARP requests that are not
// explicitly destined to the local system.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "proxy-arp"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/proxy-arp"
func (n *Interface_RoutedVlan_Ipv4Path) ProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArpPath {
	ps := &Interface_RoutedVlan_Ipv4_ProxyArpPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"proxy-arp"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// ProxyArp (container): Configuration and operational state parameters
// relating to proxy ARP. This functionality allows a
// system to respond to ARP requests that are not
// explicitly destined to the local system.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "proxy-arp"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/proxy-arp"
func (n *Interface_RoutedVlan_Ipv4PathAny) ProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArpPathAny {
	ps := &Interface_RoutedVlan_Ipv4_ProxyArpPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"proxy-arp"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Unnumbered (container): Top-level container for setting unnumbered interfaces.
// Includes reference the interface that provides the
// address information
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "unnumbered"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/unnumbered"
func (n *Interface_RoutedVlan_Ipv4Path) Unnumbered() *Interface_RoutedVlan_Ipv4_UnnumberedPath {
	ps := &Interface_RoutedVlan_Ipv4_UnnumberedPath{
		NodePath: ygnmi.NewNodePath(
			[]string{"unnumbered"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// Unnumbered (container): Top-level container for setting unnumbered interfaces.
// Includes reference the interface that provides the
// address information
//
//	Defining module:      "openconfig-interfaces"
//	Instantiating module: "openconfig-interfaces"
//	Path from parent:     "unnumbered"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/unnumbered"
func (n *Interface_RoutedVlan_Ipv4PathAny) Unnumbered() *Interface_RoutedVlan_Ipv4_UnnumberedPathAny {
	ps := &Interface_RoutedVlan_Ipv4_UnnumberedPathAny{
		NodePath: ygnmi.NewNodePath(
			[]string{"unnumbered"},
			map[string]interface{}{},
			n,
		),
	}
	return ps
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_RoutedVlan_Ipv4Path) State() ygnmi.SingletonQuery[*oc.Interface_RoutedVlan_Ipv4] {
	return ygnmi.NewSingletonQuery[*oc.Interface_RoutedVlan_Ipv4](
		"Interface_RoutedVlan_Ipv4",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
func (n *Interface_RoutedVlan_Ipv4PathAny) State() ygnmi.WildcardQuery[*oc.Interface_RoutedVlan_Ipv4] {
	return ygnmi.NewWildcardQuery[*oc.Interface_RoutedVlan_Ipv4](
		"Interface_RoutedVlan_Ipv4",
		true,
		false,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_RoutedVlan_Ipv4Path) Config() ygnmi.ConfigQuery[*oc.Interface_RoutedVlan_Ipv4] {
	return ygnmi.NewConfigQuery[*oc.Interface_RoutedVlan_Ipv4](
		"Interface_RoutedVlan_Ipv4",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
func (n *Interface_RoutedVlan_Ipv4PathAny) Config() ygnmi.WildcardQuery[*oc.Interface_RoutedVlan_Ipv4] {
	return ygnmi.NewWildcardQuery[*oc.Interface_RoutedVlan_Ipv4](
		"Interface_RoutedVlan_Ipv4",
		false,
		true,
		false,
		false,
		true,
		false,
		n,
		nil,
		nil,
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Interface_RoutedVlan_Ipv4_Address_IpPath represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address/state/ip YANG schema element.
type Interface_RoutedVlan_Ipv4_Address_IpPath struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// Interface_RoutedVlan_Ipv4_Address_IpPathAny represents the wildcard version of the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address/state/ip YANG schema element.
type Interface_RoutedVlan_Ipv4_Address_IpPathAny struct {
	*ygnmi.NodePath
	parent ygnmi.PathStruct
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "state/ip"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address/state/ip"
func (n *Interface_RoutedVlan_Ipv4_Address_IpPath) State() ygnmi.SingletonQuery[string] {
	return ygnmi.NewSingletonQuery[string](
		"Interface_RoutedVlan_Ipv4_Address",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "ip"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4_Address).Ip
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4_Address) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// State returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "state/ip"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address/state/ip"
func (n *Interface_RoutedVlan_Ipv4_Address_IpPathAny) State() ygnmi.WildcardQuery[string] {
	return ygnmi.NewWildcardQuery[string](
		"Interface_RoutedVlan_Ipv4_Address",
		true,
		false,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"state", "ip"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4_Address).Ip
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4_Address) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "config/ip"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address/config/ip"
func (n *Interface_RoutedVlan_Ipv4_Address_IpPath) Config() ygnmi.ConfigQuery[string] {
	return ygnmi.NewConfigQuery[string](
		"Interface_RoutedVlan_Ipv4_Address",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "ip"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4_Address).Ip
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4_Address) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}

// Config returns a Query that can be used in gNMI operations.
//
//	Defining module:      "openconfig-if-ip"
//	Instantiating module: "openconfig-if-ip"
//	Path from parent:     "config/ip"
//	Path from root:       "/interfaces/interface/routed-vlan/ipv4/addresses/address/config/ip"
func (n *Interface_RoutedVlan_Ipv4_Address_IpPathAny) Config() ygnmi.WildcardQuery[string] {
	return ygnmi.NewWildcardQuery[string](
		"Interface_RoutedVlan_Ipv4_Address",
		false,
		true,
		true,
		true,
		true,
		false,
		ygnmi.NewNodePath(
			[]string{"config", "ip"},
			nil,
			n.parent,
		),
		func(gs ygot.ValidatedGoStruct) (string, bool) {
			ret := gs.(*oc.Interface_RoutedVlan_Ipv4_Address).Ip
			if ret == nil {
				var zero string
				return zero, false
			}
			return *ret, true
		},
		func() ygot.ValidatedGoStruct { return new(oc.Interface_RoutedVlan_Ipv4_Address) },
		func() *ytypes.Schema {
			return &ytypes.Schema{
				Root:       &oc.Root{},
				SchemaTree: oc.SchemaTree,
				Unmarshal:  oc.Unmarshal,
			}
		},
		nil,
		nil,
	)
}
